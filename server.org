 -*- Mode: POLY-ORG ;  indent-tabs-mode: nil; lsp-diagnostics-provider: :none -*- ---
#+Title: ast
#+OPTIONS: tex:verbatim toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+STARTUP: noindent
#+STARTUP: inlineimages
#+PROPERTY: literate-lang python
#+PROPERTY: literate-load yes
#+PROPERTY: literate-insert-header no
#+PROPERTY: header-args :results silent :session
#+PROPERTY: LITERATE_ORG_LANGUAGE python
#+PROPERTY: LITERATE_ORG_ROOT_MODULE marimo._server
#+PROPERTY: LITERATE_ORG_ROOT_MODULE_PATH ~/projects/marimo
#+PROPERTY: LITERATE_ORG_MODULE_CREATE_METHOD import
* __init__
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.__init__
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/__init__.py
:END:
** Comment
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.

#+END_SRC
* asgi
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.asgi
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/asgi.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import abc
from typing import TYPE_CHECKING, List, Optional, Tuple

#+END_SRC
** Class ASGIAppBuilder
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.types import ASGIApp


class ASGIAppBuilder(abc.ABC):
    @abc.abstractmethod
    def with_app(self, *, path: str, root: str) -> "ASGIAppBuilder":
        pass

    @abc.abstractmethod
    def build(self) -> "ASGIApp":
        pass

#+END_SRC
** Function create_asgi_app
#+BEGIN_SRC python
def create_asgi_app(
    *,
    quiet: bool = False,
    include_code: bool = False,
    token: Optional[str] = None,
) -> ASGIAppBuilder:
    """
    Public API to create an ASGI app that can serve multiple notebooks.
    This only works for application that are in Run mode.

    **Examples.**

    You can create an ASGI app, and serve the application with a
    server like `uvicorn`:

    ```python
    import uvicorn

    builder = (
        create_asgi_app()
        .with_app(path="/app", root="app.py")
        .with_app(path="/app2", root="app2.py")
        .with_app(path="/", root="home.py")
    )
    app = builder.build()

    if __name__ == "__main__":
        uvicorn.run(app, port=8000)
    ```

    Or you can further integrate it with a FastAPI app:

    ```python
    import uvicorn
    from fastapi import FastAPI
    import my_middlewares
    import my_routes

    app = FastAPI()

    builder = (
        create_asgi_app()
        .with_app(path="/app", root="app.py")
        .with_app(path="/app2", root="app2.py")
    )

    # Add middlewares
    app.add_middleware(my_middlewares.auth_middleware)


    # Add routes
    @app.get("/login")
    async def root():
        pass


    # Add the marimo app
    app.mount("/", builder.build())

    if __name__ == "__main__":
        uvicorn.run(app, port=8000)
    ```

    **Args.**

    - quiet (bool, optional): Suppress standard out
    - include_code (bool, optional): Include notebook code in the app
    - token (str, optional): Auth token to use for the app.
        If not provided, an empty token is used.

    **Returns.**

    - ASGIAppBuilder: A builder object to create multiple ASGI apps
    """
    from starlette.applications import Starlette
    from starlette.responses import RedirectResponse

    import marimo._server.api.lifespans as lifespans
    from marimo._config.manager import UserConfigManager
    from marimo._server.file_router import AppFileRouter
    from marimo._server.main import create_starlette_app
    from marimo._server.model import SessionMode
    from marimo._server.sessions import NoopLspServer, SessionManager
    from marimo._server.tokens import AuthToken
    from marimo._server.utils import initialize_asyncio
    from marimo._utils.marimo_path import MarimoPath

    user_config_mgr = UserConfigManager()
    base_app = Starlette()

    # Default to an empty token
    # If a user is using the create_asgi_app API,
    # they likely want to provide their own authN/authZ
    if not token:
        auth_token = AuthToken("")
    else:
        auth_token = AuthToken(token)

    # We call the entrypoint `root` instead of `filename` incase we want to
    # support directories or code in the future
    class Builder(ASGIAppBuilder):
        def __init__(self) -> None:
            self._mount_configs: List[Tuple[str, str]] = []

        def with_app(self, *, path: str, root: str) -> "ASGIAppBuilder":
            self._mount_configs.append((path, root))
            return self

        def _build_app(self, path: str, root: str) -> "ASGIAppBuilder":
            session_manager = SessionManager(
                file_router=AppFileRouter.from_filename(MarimoPath(root)),
                mode=SessionMode.RUN,
                development_mode=False,
                quiet=quiet,
                include_code=include_code,
                # Currently we only support run mode,
                # which doesn't require an LSP server
                lsp_server=NoopLspServer(),
                user_config_manager=user_config_mgr,
                # We don't pass any CLI args for now
                # since we don't want to read arbitrary args and apply them
                # to each application
                cli_args={},
                auth_token=auth_token,
            )
            app = create_starlette_app(
                base_url="",
                lifespan=lifespans.Lifespans(
                    [
                        # Not all lifespans are needed for run mode
                        lifespans.etc,
                        lifespans.signal_handler,
                    ]
                ),
                enable_auth=not AuthToken.is_empty(auth_token),
                allow_origins=("*",),
            )
            app.state.session_manager = session_manager
            app.state.base_url = path
            app.state.config_manager = user_config_mgr

            base_app.mount(path, app)

            # If path is not empty,
            # add a redirect from /{path} to /{path}/
            # otherwise, we get a 404
            if path:
                base_app.add_route(
                    path,
                    lambda _: RedirectResponse(
                        url=f"{path}/", status_code=301
                    ),
                )

            return self

        def build(self) -> "ASGIApp":
            # First sort the mount configs by path length
            # This is to ensure that the root app is mounted last
            self._mount_configs = sorted(
                self._mount_configs, key=lambda x: -len(x[0])
            )

            for path, root in self._mount_configs:
                self._build_app(path, root)

            return base_app

    initialize_asyncio()
    return Builder()

#+END_SRC
* exceptions
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.exceptions
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/exceptions.py
:END:
** Class InvalidSessionException
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
class InvalidSessionException(Exception):
    def __init__(self, message: str) -> None:
        super().__init__(message)

#+END_SRC
* file_manager
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.file_manager
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/file_manager.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import os
import pathlib
import shutil
from typing import Any, Dict, Optional

from marimo import _loggers
from marimo._ast import codegen
from marimo._ast.app import App, InternalApp, _AppConfig
from marimo._ast.cell import CellConfig
from marimo._config.config import WidthType
from marimo._runtime.layout.layout import (
    LayoutConfig,
    read_layout_config,
    save_layout_config,
)
from marimo._server.api.status import HTTPException, HTTPStatus
from marimo._server.models.models import (
    CopyNotebookRequest,
    SaveNotebookRequest,
)
from marimo._server.utils import canonicalize_filename

#+END_SRC
** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
** Class AppFileManager
#+BEGIN_SRC python
class AppFileManager:
    def __init__(
        self, filename: Optional[str], default_width: WidthType | None = None
    ) -> None:
        self.filename = filename
        self._default_width: WidthType | None = default_width
        self.app = self._load_app(self.path)

    @staticmethod
    def from_app(app: InternalApp) -> AppFileManager:
        manager = AppFileManager(None)
        manager.app = app
        return manager

    def reload(self) -> None:
        """Reload the app from the file."""
        self.app = self._load_app(self.path)

    def _is_same_path(self, filename: str) -> bool:
        if self.filename is None:
            return False
        return os.path.abspath(self.filename) == os.path.abspath(filename)

    def _assert_path_does_not_exist(self, filename: str) -> None:
        if os.path.exists(filename):
            raise HTTPException(
                status_code=HTTPStatus.BAD_REQUEST,
                detail="File {0} already exists".format(filename),
            )

    def _assert_path_is_the_same(self, filename: str) -> None:
        if self.filename is not None and not self._is_same_path(filename):
            raise HTTPException(
                status_code=HTTPStatus.BAD_REQUEST,
                detail="Save handler cannot rename files.",
            )

    def _create_parent_directories(self, filename: str) -> None:
        try:
            pathlib.Path(filename).parent.mkdir(parents=True, exist_ok=True)
        except Exception:
            pass

    def _create_file(
        self,
        filename: str,
        contents: str = "",
    ) -> None:
        self._create_parent_directories(filename)
        try:
            with open(filename, "w", encoding="utf-8") as f:
                f.write(contents)
        except Exception as err:
            raise HTTPException(
                status_code=HTTPStatus.SERVER_ERROR,
                detail="Failed to save file {0}".format(filename),
            ) from err

    def _rename_file(self, new_filename: str) -> None:
        assert self.filename is not None
        self._create_parent_directories(new_filename)
        try:
            os.rename(self.filename, new_filename)
        except Exception as err:
            raise HTTPException(
                status_code=HTTPStatus.SERVER_ERROR,
                detail="Failed to rename from {0} to {1}".format(
                    self.filename, new_filename
                ),
            ) from err

    def _save_file(
        self,
        filename: str,
        codes: list[str],
        names: list[str],
        configs: list[CellConfig],
        app_config: _AppConfig,
        # Whether or not to persist the app to the file system
        persist: bool,
    ) -> str:
        LOGGER.debug("Saving app to %s", filename)
        if filename.endswith(".md"):
            # TODO: Remember just proof of concept, potentially needs
            # restructuring.
            from marimo._server.export.exporter import Exporter

            contents, _ = Exporter().export_as_md(self)
        else:
            # Header might be better kept on the AppConfig side, opposed to
            # reparsing it. Also would allow for md equivalent in a field like
            # `description`.
            header_comments = codegen.get_header_comments(filename)
            # try to save the app under the name `filename`
            contents = codegen.generate_filecontents(
                codes,
                names,
                cell_configs=configs,
                config=app_config,
                header_comments=header_comments,
            )

        if persist:
            self._create_file(filename, contents)

        if self._is_unnamed():
            self.rename(filename)

        return contents

    def _load_app(self, path: Optional[str]) -> InternalApp:
        """Read the app from the file."""
        app = codegen.get_app(path)
        if app is None:
            kwargs = (
                {"width": self._default_width}
                if self._default_width is not None
                # App decides its own default width
                else {}
            )
            empty_app = InternalApp(App(**kwargs))
            empty_app.cell_manager.register_cell(
                cell_id=None,
                code="",
                config=CellConfig(),
            )
            return empty_app
        return InternalApp(app)

    def rename(self, new_filename: str) -> None:
        """Rename the file."""
        new_filename = canonicalize_filename(new_filename)

        if self._is_same_path(new_filename):
            return

        self._assert_path_does_not_exist(new_filename)

        need_save = False
        # Check if filename is not None to satisfy mypy's type checking.
        # This ensures that filename is treated as a non-optional str,
        # preventing potential type errors in subsequent code.
        if self._is_named() and self.filename is not None:
            # Force a save after rename in case filetype changed.
            need_save = self.filename[-3:] != new_filename[-3:]
            self._rename_file(new_filename)
        else:
            self._create_file(new_filename)

        self.filename = new_filename
        if need_save:
            self._save_file(
                self.filename,
                list(self.app.cell_manager.codes()),
                list(self.app.cell_manager.names()),
                list(self.app.cell_manager.configs()),
                self.app.config,
                persist=True,
            )

    def read_layout_config(self) -> Optional[LayoutConfig]:
        if self.app.config.layout_file is not None and isinstance(
            self.filename, str
        ):
            app_dir = os.path.dirname(self.filename)
            layout = read_layout_config(app_dir, self.app.config.layout_file)
            return layout

        return None

    def read_css_file(self) -> Optional[str]:
        css_file = self.app.config.css_file
        if not css_file or not self.filename:
            return None
        return read_css_file(css_file, self.filename)

    def read_html_head_file(self) -> Optional[str]:
        html_head_file = self.app.config.html_head_file
        if not html_head_file or not self.filename:
            return None
        return read_html_head_file(html_head_file, self.filename)

    @property
    def path(self) -> Optional[str]:
        if self.filename is None:
            return None
        try:
            return os.path.abspath(self.filename)
        except AttributeError:
            return None

    def save_app_config(self, config: Dict[str, Any]) -> str:
        """Save the app configuration."""
        # Update the file with the latest app config
        # TODO(akshayka): Only change the `app = marimo.App` line (at top level
        # of file), instead of overwriting the whole file.
        new_config = self.app.update_config(config)
        if self.filename is not None:
            return self._save_file(
                self.filename,
                list(self.app.cell_manager.codes()),
                list(self.app.cell_manager.names()),
                list(self.app.cell_manager.configs()),
                new_config,
                persist=True,
            )
        return ""

    def save(self, request: SaveNotebookRequest) -> str:
        """Save the current app."""
        cell_ids, codes, configs, names, filename, layout = (
            request.cell_ids,
            request.codes,
            request.configs,
            request.names,
            request.filename,
            request.layout,
        )
        filename = canonicalize_filename(filename)
        self.app.with_data(
            cell_ids=cell_ids,
            codes=codes,
            names=names,
            configs=configs,
        )

        if self._is_named() and not self._is_same_path(filename):
            raise HTTPException(
                status_code=HTTPStatus.BAD_REQUEST,
                detail="Save handler cannot rename files.",
            )

        # save layout
        if layout is not None:
            app_dir = os.path.dirname(filename)
            app_name = os.path.basename(filename)
            layout_filename = save_layout_config(
                app_dir, app_name, LayoutConfig(**layout)
            )
            self.app.update_config({"layout_file": layout_filename})
        else:
            # Remove the layout from the config
            # We don't remove the layout file from the disk to avoid
            # deleting state that the user might want to keep
            self.app.update_config({"layout_file": None})
        return self._save_file(
            filename,
            codes,
            names,
            configs,
            self.app.config,
            persist=request.persist,
        )

    def copy(self, request: CopyNotebookRequest) -> str:
        source, destination = request.source, request.destination
        shutil.copy(source, destination)
        return os.path.basename(destination)

    def to_code(self) -> str:
        """Read the contents of the unsaved file."""
        contents = codegen.generate_filecontents(
            codes=list(self.app.cell_manager.codes()),
            names=list(self.app.cell_manager.names()),
            cell_configs=list(self.app.cell_manager.configs()),
            config=self.app.config,
        )
        return contents

    def _is_unnamed(self) -> bool:
        return self.filename is None

    def _is_named(self) -> bool:
        return self.filename is not None

    def read_file(self) -> str:
        """Read the contents of the file."""
        if self.filename is None:
            raise HTTPException(
                status_code=HTTPStatus.BAD_REQUEST,
                detail="Cannot read code from an unnamed notebook",
            )
        with open(self.filename, "r", encoding="utf-8") as f:
            contents = f.read().strip()
        return contents

#+END_SRC
** Function read_css_file
#+BEGIN_SRC python
def read_css_file(css_file: str, filename: Optional[str]) -> Optional[str]:
    if not css_file or not filename:
        return None

    app_dir = os.path.dirname(filename)
    filepath = os.path.join(app_dir, css_file)
    if not os.path.exists(filepath):
        LOGGER.error("CSS file %s does not exist", css_file)
        return None
    try:
        with open(filepath) as f:
            return f.read()
    except OSError as e:
        LOGGER.warning(
            "Failed to open custom CSS file %s for reading: %s",
            filepath,
            str(e),
        )
        return None

#+END_SRC
** Function read_html_head_file
#+BEGIN_SRC python
def read_html_head_file(
    html_head_file: str, filename: Optional[str]
) -> Optional[str]:
    if not html_head_file or not filename:
        return None

    app_dir = os.path.dirname(filename)
    filepath = os.path.join(app_dir, html_head_file)
    if not os.path.exists(filepath):
        LOGGER.error("HTML head file %s does not exist", html_head_file)
        return None
    try:
        with open(filepath) as f:
            return f.read()
    except OSError as e:
        LOGGER.warning(
            "Failed to open HTML head file %s for reading: %s",
            filepath,
            str(e),
        )
        return None

#+END_SRC
* file_router
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.file_router
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/file_router.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import abc
import os
import pathlib
import signal
from contextlib import contextmanager
from typing import TYPE_CHECKING, Generator, List, Optional

from marimo import _loggers
from marimo._config.config import WidthType
from marimo._server.api.status import HTTPException, HTTPStatus
from marimo._server.file_manager import AppFileManager
from marimo._server.files.os_file_system import natural_sort_file
from marimo._server.models.files import FileInfo
from marimo._server.models.home import MarimoFile
from marimo._utils.marimo_path import MarimoPath

#+END_SRC
** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from types import FrameType

LOGGER = _loggers.marimo_logger()

#+END_SRC
** Assignment MarimoFileKey = str
#+BEGIN_SRC python
# Some unique identifier for a file
MarimoFileKey = str

#+END_SRC
** Class AppFileRouter
#+BEGIN_SRC python
class AppFileRouter(abc.ABC):
    """
    Abstract class for routing files to an AppFileManager.
    """

    NEW_FILE: MarimoFileKey = "__new__"

    @property
    def directory(self) -> str | None:
        return None

    @staticmethod
    def infer(path: str) -> AppFileRouter:
        if os.path.isfile(path):
            LOGGER.debug("Routing to file %s", path)
            return AppFileRouter.from_filename(MarimoPath(path))
        if os.path.isdir(path):
            LOGGER.debug("Routing to directory %s", path)
            return AppFileRouter.from_directory(path)
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="Path {0} is not a valid file or directory".format(path),
        )

    @staticmethod
    def from_filename(file: MarimoPath) -> AppFileRouter:
        files = [
            MarimoFile(
                name=file.relative_name,
                path=file.absolute_name,
                last_modified=file.last_modified,
            )
        ]
        return ListOfFilesAppFileRouter(files)

    @staticmethod
    def from_directory(directory: str) -> AppFileRouter:
        return LazyListOfFilesAppFileRouter(directory, include_markdown=False)

    @staticmethod
    def from_files(files: List[MarimoFile]) -> AppFileRouter:
        return ListOfFilesAppFileRouter(files)

    @staticmethod
    def new_file() -> AppFileRouter:
        return NewFileAppFileRouter()

    def get_single_app_file_manager(
        self, default_width: WidthType | None = None
    ) -> AppFileManager:
        key = self.get_unique_file_key()
        assert key is not None, "Expected a single file"
        return self.get_file_manager(key, default_width)

    def get_file_manager(
        self,
        key: MarimoFileKey,
        default_width: WidthType | None = None,
    ) -> AppFileManager:
        """
        Given a key, return an AppFileManager.
        """
        if key.startswith(AppFileRouter.NEW_FILE):
            return AppFileManager(None, default_width)

        if os.path.exists(key):
            return AppFileManager(key, default_width)

        raise HTTPException(
            status_code=HTTPStatus.NOT_FOUND,
            detail="File {0} not found".format(key),
        )

    @abc.abstractmethod
    def get_unique_file_key(self) -> Optional[MarimoFileKey]:
        """
        If there is a unique file key, return it. Otherwise, return None.
        """
        pass

    @abc.abstractmethod
    def maybe_get_single_file(self) -> Optional[MarimoFile]:
        """
        If there is a single file, return it. Otherwise, return None.
        """
        pass

    @property
    @abc.abstractmethod
    def files(self) -> List[FileInfo]:
        """
        Get all files in a recursive tree.
        """
        pass

#+END_SRC
** Class NewFileAppFileRouter
#+BEGIN_SRC python
class NewFileAppFileRouter(AppFileRouter):
    def get_unique_file_key(self) -> Optional[MarimoFileKey]:
        return AppFileRouter.NEW_FILE

    def maybe_get_single_file(self) -> Optional[MarimoFile]:
        return None

    @property
    def files(self) -> List[FileInfo]:
        return []

#+END_SRC
** Class ListOfFilesAppFileRouter
#+BEGIN_SRC python
class ListOfFilesAppFileRouter(AppFileRouter):
    def __init__(self, files: List[MarimoFile]) -> None:
        self._files = files

    @property
    def files(self) -> List[FileInfo]:
        return [
            FileInfo(
                id=file.path,
                name=file.name,
                path=file.path,
                last_modified=file.last_modified,
                is_directory=False,
                is_marimo_file=True,
            )
            for file in self._files
        ]

    def get_unique_file_key(self) -> Optional[MarimoFileKey]:
        if len(self.files) == 1:
            return self.files[0].path
        return None

    def maybe_get_single_file(self) -> Optional[MarimoFile]:
        if len(self.files) == 1:
            file = self.files[0]
            return MarimoFile(
                name=file.name,
                path=file.path,
                last_modified=file.last_modified,
            )
        return None

#+END_SRC
** Class LazyListOfFilesAppFileRouter
#+BEGIN_SRC python
class LazyListOfFilesAppFileRouter(AppFileRouter):
    def __init__(self, directory: str, include_markdown: bool) -> None:
        # pass through Path to canonicalize, strips trailing slashes
        self._directory = str(pathlib.Path(directory))
        self.include_markdown = include_markdown
        self._lazy_files: Optional[List[FileInfo]] = None

    @property
    def directory(self) -> str:
        return self._directory

    def toggle_markdown(
        self, include_markdown: bool
    ) -> LazyListOfFilesAppFileRouter:
        # Only create a new instance if the include_markdown flag is different
        if include_markdown != self.include_markdown:
            return LazyListOfFilesAppFileRouter(
                self.directory, include_markdown
            )
        return self

    def mark_stale(self) -> None:
        self._lazy_files = None

    @property
    def files(self) -> List[FileInfo]:
        if self._lazy_files is None:
            self._lazy_files = self._load_files()
        return self._lazy_files

    def _load_files(self) -> List[FileInfo]:
        import time

        start_time = time.time()
        MAX_EXECUTION_TIME = 5  # 5 seconds timeout

        def recurse(
            directory: str, depth: int = 0
        ) -> Optional[List[FileInfo]]:
            if depth > MAX_DEPTH:
                return None

            if time.time() - start_time > MAX_EXECUTION_TIME:
                raise HTTPException(
                    status_code=HTTPStatus.REQUEST_TIMEOUT,
                    detail="Request timed out: Loading workspace files took too long.",  # noqa: E501
                )

            try:
                entries = os.scandir(directory)
            except OSError as e:
                LOGGER.debug("OSError scanning directory: %s", str(e))
                return None

            files: List[FileInfo] = []
            folders: List[FileInfo] = []

            for entry in entries:
                # Skip hidden files and directories
                if entry.name.startswith("."):
                    continue

                if entry.is_dir():
                    if entry.name in skip_dirs or depth == MAX_DEPTH:
                        continue
                    children = recurse(entry.path, depth + 1)
                    if children:
                        folders.append(
                            FileInfo(
                                id=entry.path,
                                path=entry.path,
                                name=entry.name,
                                is_directory=True,
                                is_marimo_file=False,
                                children=children,
                            )
                        )
                elif entry.name.endswith(tuple(allowed_extensions)):
                    if self._is_marimo_app(entry.path):
                        files.append(
                            FileInfo(
                                id=entry.path,
                                path=entry.path,
                                name=entry.name,
                                is_directory=False,
                                is_marimo_file=True,
                                last_modified=entry.stat().st_mtime,
                            )
                        )

            # Sort folders then files, based on natural sort (alpha, then num)
            return sorted(folders, key=natural_sort_file) + sorted(
                files, key=natural_sort_file
            )

        MAX_DEPTH = 5
        skip_dirs = {
            "venv",
            "__pycache__",
            "node_modules",
            "site-packages",
            "eggs",
        }
        allowed_extensions = (
            (".py", ".md") if self.include_markdown else (".py",)
        )

        return recurse(self.directory) or []

    def _is_marimo_app(self, full_path: str) -> bool:
        try:
            path = MarimoPath(full_path)
            contents = path.read_text()
            if path.is_markdown():
                return "marimo-version:" in contents
            if path.is_python():
                return "marimo.App" in contents and "import marimo" in contents
            return False
        except Exception as e:
            LOGGER.debug("Error reading file %s: %s", full_path, e)
            return False

    def get_unique_file_key(self) -> str | None:
        return None

    def maybe_get_single_file(self) -> MarimoFile | None:
        return None

#+END_SRC
** @contextmanager: Function timeout
#+BEGIN_SRC python
@contextmanager
def timeout(seconds: int, message: str) -> Generator[None, None, None]:
    def timeout_handler(signum: int, frame: Optional[FrameType]) -> None:
        del signum, frame
        raise HTTPException(
            status_code=HTTPStatus.REQUEST_TIMEOUT,
            detail="Request timed out: {0}".format(message),
        )

    # Set the timeout handler
    original_handler = signal.signal(signal.SIGALRM, timeout_handler)
    try:
        signal.alarm(seconds)
        yield
    finally:
        signal.alarm(0)
        signal.signal(signal.SIGALRM, original_handler)

#+END_SRC
* ids
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.ids
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/ids.py
:END:
** Assignment SessionId = str
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

SessionId = str

#+END_SRC
** Assignment ConsumerId = str
#+BEGIN_SRC python
ConsumerId = str

#+END_SRC
* main
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.main
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/main.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING, Any, List, Optional

from starlette.applications import Starlette
from starlette.exceptions import HTTPException
from starlette.middleware import Middleware
from starlette.middleware.authentication import AuthenticationMiddleware
from starlette.middleware.cors import CORSMiddleware
from starlette.responses import JSONResponse

from marimo import _loggers
from marimo._server.api.auth import (
    RANDOM_SECRET,
    CustomSessionMiddleware,
    on_auth_error,
)
from marimo._server.api.middleware import (
    AuthBackend,
    OpenTelemetryMiddleware,
    ProxyMiddleware,
    SkewProtectionMiddleware,
)
from marimo._server.api.router import build_routes
from marimo._server.api.status import (
    HTTPException as MarimoHTTPException,
    is_client_error,
)

#+END_SRC
** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request
    from starlette.types import Lifespan

LOGGER = _loggers.marimo_logger()

#+END_SRC
** Function handle_error
#+BEGIN_SRC python
# Convert exceptions to JSON responses
async def handle_error(request: Request, response: Any) -> Any:
    del request
    if isinstance(response, HTTPException):
        # Turn 403s into 401s to collect auth
        if response.status_code == 403:
            return JSONResponse(
                status_code=401,
                content={"detail": "Authorization header required"},
                headers={"WWW-Authenticate": "Basic"},
            )
        return JSONResponse(
            {"detail": response.detail},
            status_code=response.status_code,
            headers=response.headers,
        )
    if isinstance(response, MarimoHTTPException):
        # Log server errors
        if not is_client_error(response.status_code):
            LOGGER.exception(response)
        return JSONResponse(
            {"detail": response.detail},
            status_code=response.status_code,
        )
    if isinstance(response, NotImplementedError):
        return JSONResponse({"detail": "Not supported"}, status_code=501)
    if isinstance(response, TypeError):
        return JSONResponse({"detail": str(response)}, status_code=500)
    if isinstance(response, Exception):
        return JSONResponse({"detail": str(response)}, status_code=500)
    return response

#+END_SRC
** Function create_starlette_app
#+BEGIN_SRC python
# Create app
def create_starlette_app(
    *,
    base_url: str,
    host: Optional[str] = None,
    middleware: Optional[List[Middleware]] = None,
    lifespan: Optional[Lifespan[Starlette]] = None,
    enable_auth: bool = True,
    allow_origins: Optional[tuple[str, ...]] = None,
    lsp_port: Optional[int] = None,
) -> Starlette:
    final_middlewares: List[Middleware] = []

    if allow_origins is None:
        allow_origins = ("localhost", "127.0.0.1") + (
            (host,) if host is not None else ()
        )

    if enable_auth:
        final_middlewares.extend(
            [
                Middleware(
                    CustomSessionMiddleware,
                    secret_key=RANDOM_SECRET,
                ),
            ]
        )

    final_middlewares.extend(
        [
            Middleware(OpenTelemetryMiddleware),
            Middleware(
                AuthenticationMiddleware,
                backend=AuthBackend(should_authenticate=enable_auth),
                on_error=on_auth_error,
            ),
            Middleware(
                CORSMiddleware,
                allow_origins=allow_origins,
                allow_credentials=True,
                allow_methods=["*"],
                allow_headers=["*"],
            ),
            Middleware(SkewProtectionMiddleware),
            _create_mpl_proxy_middleware(),
        ]
    )

    if lsp_port is not None:
        final_middlewares.append(_create_lsp_proxy_middleware(lsp_port))

    if middleware:
        final_middlewares.extend(middleware)

    return Starlette(
        routes=build_routes(base_url=base_url),
        middleware=final_middlewares,
        lifespan=lifespan,
        exception_handlers={
            Exception: handle_error,
            HTTPException: handle_error,
            MarimoHTTPException: handle_error,
        },
    )

#+END_SRC
** Function _create_mpl_proxy_middleware
#+BEGIN_SRC python
def _create_mpl_proxy_middleware() -> Middleware:
    # MPL proxy logic
    def mpl_target_url(path: str) -> str:
        # Path format: /mpl/<port>/rest/of/path
        port = path.split("/", 3)[2]
        return f"http://localhost:{port}"

    def mpl_path_rewrite(path: str) -> str:
        # Remove the /mpl/<port>/ prefix
        rest = path.split("/", 3)[3]
        return f"/{rest}"

    return Middleware(
        ProxyMiddleware,
        proxy_path="/mpl",
        target_url=mpl_target_url,
        path_rewrite=mpl_path_rewrite,
    )

#+END_SRC
** Function _create_lsp_proxy_middleware
#+BEGIN_SRC python
def _create_lsp_proxy_middleware(lsp_port: int) -> Middleware:
    return Middleware(
        ProxyMiddleware,
        proxy_path="/lsp",
        target_url=f"http://localhost:{lsp_port}",
        # Remove the /lsp prefix
        path_rewrite=lambda path: path.replace("/lsp", ""),
    )

#+END_SRC
* model
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.model
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/model.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import abc
from enum import Enum
from typing import TYPE_CHECKING, Callable

from marimo._server.ids import ConsumerId

#+END_SRC
** Class ConnectionState
#+BEGIN_SRC python
if TYPE_CHECKING:
    from marimo._messaging.ops import MessageOperation
    from marimo._messaging.types import KernelMessage


class ConnectionState(Enum):
    """Connection state for a session"""

    OPEN = 0
    CLOSED = 1
    ORPHANED = 2

#+END_SRC
** Class SessionMode
#+BEGIN_SRC python
class SessionMode(str, Enum):
    """Session mode for a session"""

    # read-write
    EDIT = "edit"
    # read-only
    RUN = "run"

#+END_SRC
** Class SessionConsumer
#+BEGIN_SRC python
class SessionConsumer(metaclass=abc.ABCMeta):
    """
    Consumer for a session

    This allows use to communicate with a session via different
    connection types. Currently we consume a session via WebSocket
    """

    def __init__(self, consumer_id: ConsumerId) -> None:
        self.consumer_id = consumer_id

    @abc.abstractmethod
    def on_start(
        self,
    ) -> Callable[[KernelMessage], None]:
        """
        Start the session consumer
        and return a subscription function for the session consumer
        """
        raise NotImplementedError

    @abc.abstractmethod
    def on_stop(self) -> None:
        raise NotImplementedError

    @abc.abstractmethod
    def write_operation(self, op: MessageOperation) -> None:
        raise NotImplementedError

    @abc.abstractmethod
    def connection_state(self) -> ConnectionState:
        raise NotImplementedError

#+END_SRC
* print
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.print
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/print.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import os
import sys
from typing import Optional

from marimo._server.utils import print_, print_tabbed

#+END_SRC
** Assignment UTF8_SUPPORTED = False
#+BEGIN_SRC python
UTF8_SUPPORTED = False

#+END_SRC
** Function print_startup
#+BEGIN_SRC python
try:
    "🌊🍃".encode(sys.stdout.encoding)
    UTF8_SUPPORTED = True
except Exception:
    pass


def print_startup(
    file_name: Optional[str], url: str, run: bool, new: bool
) -> None:
    print_()
    if file_name is not None and not run:
        print_tabbed(
            f"\033[1;32mEdit {os.path.basename(file_name)} "
            "in your browser\033[0m " + _utf8("📝")
        )
    elif file_name is not None and run:
        print_tabbed(
            f"\033[1;32mRunning {os.path.basename(file_name)}"
            "\033[0m " + _utf8("⚡")
        )
    elif new:
        print_tabbed(
            "\033[1;32mCreate a new notebook in your browser\033[0m "
            + _utf8("📝")
        )
    else:
        print_tabbed(
            "\033[1;32mCreate or edit notebooks in your "
            "browser\033[0m " + _utf8("📝")
        )
    print_()
    print_tabbed(f"\033[32mURL\033[0m: \033[1m{url}\033[0m")
    print_()

#+END_SRC
** Function print_shutdown
#+BEGIN_SRC python
def print_shutdown() -> None:
    print_()
    print_tabbed("\033[32mThanks for using marimo!\033[0m %s" % _utf8("🌊🍃"))
    print_()

#+END_SRC
** Function _utf8
#+BEGIN_SRC python
def _utf8(msg: str) -> str:
    return msg if UTF8_SUPPORTED else ""

#+END_SRC
* recents
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.recents
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/recents.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import os
import pathlib
from dataclasses import dataclass, field
from typing import List

from marimo._server.models.home import MarimoFile
from marimo._utils.config.config import ConfigReader
from marimo._utils.paths import pretty_path

#+END_SRC
** @dataclass: Class RecentFilesState
#+BEGIN_SRC python
@dataclass
class RecentFilesState:
    files: List[str] = field(default_factory=list)

#+END_SRC
** Assignment _IGNORED_FOLDERS = ("/tmp", "/var")
#+BEGIN_SRC python
_IGNORED_FOLDERS = ("/tmp", "/var")

#+END_SRC
** Function _is_tmp_file
#+BEGIN_SRC python
def _is_tmp_file(filename: str) -> bool:
    return any(
        filename.startswith(folder_name) for folder_name in _IGNORED_FOLDERS
    )

#+END_SRC
** Class RecentFilesManager
#+BEGIN_SRC python
class RecentFilesManager:
    MAX_FILES = 5
    LOCATION = "recent_files.toml"

    def __init__(self) -> None:
        self.config = ConfigReader.for_filename(self.LOCATION)

    def touch(self, filename: str) -> None:
        if not self.config:
            return

        if _is_tmp_file(filename):
            return

        state = self.config.read_toml(
            RecentFilesState, fallback=RecentFilesState()
        )
        if filename in state.files:
            state.files.remove(filename)
        state.files.insert(0, filename)
        state.files = state.files[: self.MAX_FILES]
        self.config.write_toml(state)

    def rename(self, old_filename: str, new_filename: str) -> None:
        if not self.config:
            return

        state = self.config.read_toml(
            RecentFilesState, fallback=RecentFilesState()
        )
        if old_filename in state.files:
            state.files.remove(old_filename)
            state.files.insert(0, new_filename)
            state.files = state.files[: self.MAX_FILES]

            self.config.write_toml(state)

    def get_recents(self) -> List[MarimoFile]:
        if not self.config:
            return []

        state = self.config.read_toml(
            RecentFilesState, fallback=RecentFilesState()
        )
        files: List[MarimoFile] = []

        cwd = pathlib.Path.cwd()
        limited_files = state.files[: self.MAX_FILES]
        for file in limited_files:
            file_path = pathlib.Path(file)
            if _is_tmp_file(file) or cwd not in file_path.parents:
                continue
            if not os.path.exists(file):
                continue
            files.append(
                MarimoFile(
                    name=os.path.basename(file),
                    path=pretty_path(file),
                    last_modified=os.path.getmtime(file),
                )
            )

        return files

#+END_SRC
* router
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.router
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/router.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import dataclasses
import json
from asyncio import iscoroutine
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any, Callable, Optional, TypeVar

from starlette.responses import (
    FileResponse,
    HTMLResponse,
    JSONResponse,
    PlainTextResponse,
    RedirectResponse,
    Response,
    StreamingResponse,
)
from starlette.routing import Mount, Router

from marimo import _loggers
from marimo._server.models.base import deep_to_camel_case

#+END_SRC
** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
** Assignment DecoratedCallable = TypeVar("DecoratedCallable", bound=Callable[..., Any])
#+BEGIN_SRC python
DecoratedCallable = TypeVar("DecoratedCallable", bound=Callable[..., Any])

#+END_SRC
** @dataclass: Class APIRouter
#+BEGIN_SRC python
@dataclass
class APIRouter(Router):
    def __init__(self, prefix: str = "") -> None:
        self.prefix = prefix
        super().__init__()

    def __post_init__(self) -> None:
        if self.prefix:
            assert self.prefix.startswith(
                "/"
            ), "Path prefix must start with '/'"
            assert not self.prefix.endswith(
                "/"
            ), "Path prefix must not end with '/'"

    def post(
        self, path: str
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """Post method that returns a JSON response"""

        def decorator(func: DecoratedCallable) -> DecoratedCallable:
            async def wrapper_func(request: Request) -> Response:
                response = await func(request=request)
                if isinstance(response, FileResponse):
                    return response
                if isinstance(response, StreamingResponse):
                    return response
                if isinstance(response, HTMLResponse):
                    return response
                if isinstance(response, PlainTextResponse):
                    return response
                if isinstance(response, RedirectResponse):
                    return response
                if isinstance(response, JSONResponse):
                    return response

                if dataclasses.is_dataclass(response):
                    return JSONResponse(
                        content=deep_to_camel_case(
                            dataclasses.asdict(response)
                        )
                    )

                return JSONResponse(content=json.dumps(response))

            # Set docstring of wrapper_func to the docstring of func
            wrapper_func.__doc__ = func.__doc__

            self.add_route(
                path=self.prefix + path,
                endpoint=wrapper_func,
                methods=["POST"],
            )

            return wrapper_func  # type: ignore[return-value]

        return decorator

    def get(
        self,
        path: str,
        include_in_schema: bool = True,
        name: Optional[str] = None,
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """Get method."""

        def decorator(func: DecoratedCallable) -> DecoratedCallable:
            async def wrapper_func(request: Request) -> Response:
                response = func(request=request)
                if iscoroutine(response):
                    response = await response
                if isinstance(response, FileResponse):
                    return response
                if isinstance(response, StreamingResponse):
                    return response
                if isinstance(response, PlainTextResponse):
                    return response
                if isinstance(response, RedirectResponse):
                    return response
                if isinstance(response, HTMLResponse):
                    return response

                if dataclasses.is_dataclass(response):
                    return JSONResponse(
                        content=deep_to_camel_case(
                            dataclasses.asdict(response)
                        )
                    )

                return response  # type: ignore[no-any-return]

            # Set docstring of wrapper_func to the docstring of func
            wrapper_func.__doc__ = func.__doc__

            self.add_route(
                path=self.prefix + path,
                endpoint=wrapper_func,
                methods=["GET"],
                include_in_schema=include_in_schema,
                name=name,
            )
            return func

        return decorator

    def delete(
        self, path: str, include_in_schema: bool = True
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """Delete method."""

        def decorator(func: DecoratedCallable) -> DecoratedCallable:
            self.add_route(
                path=self.prefix + path,
                endpoint=func,
                methods=["DELETE"],
                include_in_schema=include_in_schema,
            )
            return func

        return decorator

    def websocket(
        self, path: str
    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
        """Websocket method."""

        def decorator(func: DecoratedCallable) -> DecoratedCallable:
            self.add_websocket_route(path=self.prefix + path, endpoint=func)
            return func

        return decorator

    def include_router(
        self, router: APIRouter, prefix: str = "", name: Optional[str] = None
    ) -> None:
        """Include another router in this one."""
        # Merge Mounts with the same path
        resolved_prefix = self.prefix + prefix
        for route in self.routes:
            if isinstance(route, Mount) and route.path == resolved_prefix:
                # NOTE: We don't merge middleware here, because it's not
                # clear what the correct behavior is.
                route.routes.extend(router.routes)
                return

        self.mount(path=resolved_prefix, app=router, name=name)

#+END_SRC
* Client session management
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.sessions
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/sessions.py
:END:
** Docstring
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
"""Client session management

This module encapsulates session management: each client gets a unique session,
and each session wraps a Python kernel and a websocket connection through which
the kernel can send messages to the frontend. Sessions do not share kernels or
websockets.

In run mode, in which we may have many clients connected to the server, a
session is closed as soon as its websocket connection is severed. In edit mode,
in which we have at most one connected client, a session may be kept around
even if its socket is closed.
"""

#+END_SRC
** Import statements
#+BEGIN_SRC python
from __future__ import annotations

import asyncio
import multiprocessing as mp
import os
import queue
import shutil
import signal
import subprocess
import sys
import threading
import time
from multiprocessing import connection
from multiprocessing.queues import Queue as MPQueue
from pathlib import Path
from typing import Any, Dict, Optional, Union
from uuid import uuid4

from marimo import _loggers
from marimo._ast.cell import CellConfig, CellId_t
from marimo._cli.print import red
from marimo._config.manager import UserConfigManager
from marimo._config.settings import GLOBAL_SETTINGS
from marimo._messaging.ops import (
    Alert,
    FocusCell,
    MessageOperation,
    Reload,
    UpdateCellCodes,
)
from marimo._messaging.types import KernelMessage
from marimo._output.formatters.formatters import register_formatters
from marimo._runtime import requests, runtime
from marimo._runtime.requests import (
    AppMetadata,
    CreationRequest,
    ExecuteMultipleRequest,
    ExecutionRequest,
    SerializedCLIArgs,
    SerializedQueryParams,
    SetUIElementValueRequest,
)
from marimo._server.exceptions import InvalidSessionException
from marimo._server.file_manager import AppFileManager
from marimo._server.file_router import AppFileRouter, MarimoFileKey
from marimo._server.ids import ConsumerId, SessionId
from marimo._server.model import ConnectionState, SessionConsumer, SessionMode
from marimo._server.models.models import InstantiateRequest
from marimo._server.recents import RecentFilesManager
from marimo._server.session.session_view import SessionView
from marimo._server.tokens import AuthToken, SkewProtectionToken
from marimo._server.types import QueueType
from marimo._server.utils import print_, print_tabbed
from marimo._tracer import server_tracer
from marimo._utils.disposable import Disposable
from marimo._utils.distributor import (
    ConnectionDistributor,
    QueueDistributor,
)
from marimo._utils.file_watcher import FileWatcher
from marimo._utils.paths import import_files
from marimo._utils.repr import format_repr
from marimo._utils.typed_connection import TypedConnection

#+END_SRC
** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
** Assignment SESSION_MANAGER: Optional["SessionManager"] = None
#+BEGIN_SRC python
SESSION_MANAGER: Optional["SessionManager"] = None

#+END_SRC
** Class QueueManager
#+BEGIN_SRC python
class QueueManager:
    """Manages queues for a session."""

    def __init__(self, use_multiprocessing: bool):
        context = mp.get_context("spawn") if use_multiprocessing else None

        # Control messages for the kernel (run, set UI element, set config, etc
        # ) are sent through the control queue
        self.control_queue: QueueType[requests.ControlRequest] = (
            context.Queue() if context is not None else queue.Queue()
        )

        # Set UI element queues are stored in both the control queue and
        # this queue, so that the backend can merge/batch set-ui-element
        # requests.
        self.set_ui_element_queue: QueueType[
            requests.SetUIElementValueRequest
        ] = context.Queue() if context is not None else queue.Queue()

        # Code completion requests are sent through a separate queue
        self.completion_queue: QueueType[requests.CodeCompletionRequest] = (
            context.Queue() if context is not None else queue.Queue()
        )

        self.win32_interrupt_queue: QueueType[bool] | None
        if sys.platform == "win32":
            self.win32_interrupt_queue = (
                context.Queue() if context is not None else queue.Queue()
            )
        else:
            self.win32_interrupt_queue = None

        # Input messages for the user's Python code are sent through the
        # input queue
        self.input_queue: QueueType[str] = (
            context.Queue(maxsize=1)
            if context is not None
            else queue.Queue(maxsize=1)
        )
        self.stream_queue: (
            "queue.Queue[Union[KernelMessage , None]]" | None
        ) = None
        if not use_multiprocessing:
            self.stream_queue = queue.Queue()

    def close_queues(self) -> None:
        if isinstance(self.control_queue, MPQueue):
            # cancel join thread because we don't care if the queues still have
            # things in it: don't want to make the child process wait for the
            # queues to empty
            self.control_queue.cancel_join_thread()
            self.control_queue.close()
        else:
            # kernel thread cleans up read/write conn and IOloop handler on
            # exit; we don't join the thread because we don't want to block
            self.control_queue.put(requests.StopRequest())

        if isinstance(self.set_ui_element_queue, MPQueue):
            self.set_ui_element_queue.cancel_join_thread()
            self.set_ui_element_queue.close()

        if isinstance(self.input_queue, MPQueue):
            # again, don't make the child process wait for the queues to empty
            self.input_queue.cancel_join_thread()
            self.input_queue.close()

        if isinstance(self.completion_queue, MPQueue):
            self.completion_queue.cancel_join_thread()
            self.completion_queue.close()

        if isinstance(self.win32_interrupt_queue, MPQueue):
            self.win32_interrupt_queue.cancel_join_thread()
            self.win32_interrupt_queue.close()

#+END_SRC
** Class KernelManager
#+BEGIN_SRC python
class KernelManager:
    def __init__(
        self,
        queue_manager: QueueManager,
        mode: SessionMode,
        configs: dict[CellId_t, CellConfig],
        app_metadata: AppMetadata,
        user_config_manager: UserConfigManager,
        virtual_files_supported: bool,
        redirect_console_to_browser: bool = False,
    ) -> None:
        self.kernel_task: Optional[threading.Thread] | Optional[mp.Process]
        self.queue_manager = queue_manager
        self.mode = mode
        self.configs = configs
        self.app_metadata = app_metadata
        self.user_config_manager = user_config_manager
        self.redirect_console_to_browser = redirect_console_to_browser

        # Only used in edit mode
        self._read_conn: Optional[TypedConnection[KernelMessage]] = None
        self._virtual_files_supported = virtual_files_supported

    def start_kernel(self) -> None:
        # We use a process in edit mode so that we can interrupt the app
        # with a SIGINT; we don't mind the additional memory consumption,
        # since there's only one client sess
        is_edit_mode = self.mode == SessionMode.EDIT
        listener = None
        if is_edit_mode:
            # Need to use a socket for windows compatibility
            listener = connection.Listener(family="AF_INET")
            self.kernel_task = mp.Process(
                target=runtime.launch_kernel,
                args=(
                    self.queue_manager.control_queue,
                    self.queue_manager.set_ui_element_queue,
                    self.queue_manager.completion_queue,
                    self.queue_manager.input_queue,
                    # stream queue unused
                    None,
                    listener.address,
                    is_edit_mode,
                    self.configs,
                    self.app_metadata,
                    self.user_config_manager.config,
                    self._virtual_files_supported,
                    self.redirect_console_to_browser,
                    self.queue_manager.win32_interrupt_queue,
                    self.profile_path,
                    GLOBAL_SETTINGS.LOG_LEVEL,
                ),
                # The process can't be a daemon, because daemonic processes
                # can't create children
                # https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.daemon  # noqa: E501
                daemon=False,
            )
        else:
            # We use threads in run mode to minimize memory consumption;
            # launching a process would copy the entire program state,
            # which (as of writing) is around 150MB

            # We can't terminate threads, so we have to wait until they
            # naturally exit before cleaning up resources
            def launch_kernel_with_cleanup(*args: Any) -> None:
                runtime.launch_kernel(*args)

            # install formatter import hooks, which will be shared by all
            # threads (in edit mode, the single kernel process installs
            # formatters ...)
            register_formatters(
                theme=self.user_config_manager.config["display"]["theme"]
            )

            assert self.queue_manager.stream_queue is not None
            # Make threads daemons so killing the server immediately brings
            # down all client sessions
            self.kernel_task = threading.Thread(
                target=launch_kernel_with_cleanup,
                args=(
                    self.queue_manager.control_queue,
                    self.queue_manager.set_ui_element_queue,
                    self.queue_manager.completion_queue,
                    self.queue_manager.input_queue,
                    self.queue_manager.stream_queue,
                    # IPC not used in run mode
                    None,
                    is_edit_mode,
                    self.configs,
                    self.app_metadata,
                    self.user_config_manager.config,
                    self._virtual_files_supported,
                    self.redirect_console_to_browser,
                    # win32 interrupt queue
                    None,
                    # profile path
                    None,
                    # log level
                    GLOBAL_SETTINGS.LOG_LEVEL,
                ),
                # daemon threads can create child processes, unlike
                # daemon processes
                daemon=True,
            )

        self.kernel_task.start()  # type: ignore
        if listener is not None:
            # First thing kernel does is connect to the socket, so it's safe to
            # call accept
            self._read_conn = TypedConnection[KernelMessage].of(
                listener.accept()
            )

    @property
    def profile_path(self) -> str | None:
        self._profile_path: str | None

        if hasattr(self, "_profile_path"):
            return self._profile_path

        profile_dir = GLOBAL_SETTINGS.PROFILE_DIR
        if profile_dir is not None:
            self._profile_path = os.path.join(
                profile_dir,
                (
                    os.path.basename(self.app_metadata.filename) + str(uuid4())
                    if self.app_metadata.filename is not None
                    else str(uuid4())
                ),
            )
        else:
            self._profile_path = None
        return self._profile_path

    def is_alive(self) -> bool:
        return self.kernel_task is not None and self.kernel_task.is_alive()

    def interrupt_kernel(self) -> None:
        if (
            isinstance(self.kernel_task, mp.Process)
            and self.kernel_task.pid is not None
        ):
            q = self.queue_manager.win32_interrupt_queue
            if sys.platform == "win32" and q is not None:
                LOGGER.debug("Queueing interrupt request for kernel.")
                q.put_nowait(True)
            else:
                LOGGER.debug("Sending SIGINT to kernel")
                os.kill(self.kernel_task.pid, signal.SIGINT)

    def close_kernel(self) -> None:
        assert self.kernel_task is not None, "kernel not started"

        if isinstance(self.kernel_task, mp.Process):
            if self.profile_path is not None and self.kernel_task.is_alive():
                self.queue_manager.control_queue.put(requests.StopRequest())
                # Hack: Wait for kernel to exit and write out profile;
                # joining the process hangs, but not sure why.
                print_(
                    "\tWriting profile statistics to",
                    self.profile_path,
                    " ...",
                )
                while not os.path.exists(self.profile_path):
                    time.sleep(0.1)
                time.sleep(1)

            self.queue_manager.close_queues()
            if self.kernel_task.is_alive():
                self.kernel_task.terminate()
            if self._read_conn is not None:
                self._read_conn.close()
        elif self.kernel_task.is_alive():
            # We don't join the kernel thread because we don't want to server
            # to block on it finishing
            self.queue_manager.control_queue.put(requests.StopRequest())

    @property
    def kernel_connection(self) -> TypedConnection[KernelMessage]:
        assert self._read_conn is not None, "connection not started"
        return self._read_conn

#+END_SRC
** Class Room
#+BEGIN_SRC python
class Room:
    """
    A room is a collection of SessionConsumers
    that can be used to broadcast messages to all
    of them.
    """

    def __init__(self) -> None:
        self.main_consumer: Optional[SessionConsumer] = None
        self.consumers: Dict[SessionConsumer, ConsumerId] = {}
        self.disposables: Dict[SessionConsumer, Disposable] = {}

    def add_consumer(
        self,
        consumer: SessionConsumer,
        dispose: Disposable,
        consumer_id: ConsumerId,
        # Whether the consumer is the main session consumer
        # We only allow one main consumer, the rest are kiosk consumers
        main: bool,
    ) -> None:
        self.consumers[consumer] = consumer_id
        self.disposables[consumer] = dispose
        if main:
            assert (
                self.main_consumer is None
            ), "Main session consumer already exists"
            self.main_consumer = consumer

    def remove_consumer(self, consumer: SessionConsumer) -> None:
        if consumer not in self.consumers:
            LOGGER.debug(
                "Attempted to remove a consumer that was not in room."
            )
            return

        if consumer == self.main_consumer:
            self.main_consumer = None
        self.consumers.pop(consumer)
        disposable = self.disposables.pop(consumer)
        try:
            consumer.on_stop()
        finally:
            disposable.dispose()

    def broadcast(self, operation: MessageOperation) -> None:
        for consumer in self.consumers:
            consumer.write_operation(operation)

    def close(self) -> None:
        for consumer in self.consumers:
            disposable = self.disposables.pop(consumer)
            consumer.on_stop()
            disposable.dispose()
        self.consumers = {}
        self.main_consumer = None

#+END_SRC
** Class Session
#+BEGIN_SRC python
class Session:
    """A client session.

    Each session has its own Python kernel, for editing and running the app,
    and its own websocket, for sending messages to the client.
    """

    TTL_SECONDS = 120

    @classmethod
    def create(
        cls,
        initialization_id: str,
        session_consumer: SessionConsumer,
        mode: SessionMode,
        app_metadata: AppMetadata,
        app_file_manager: AppFileManager,
        user_config_manager: UserConfigManager,
        virtual_files_supported: bool,
        redirect_console_to_browser: bool = False,
    ) -> Session:
        """
        Create a new session.
        """
        configs = app_file_manager.app.cell_manager.config_map()
        use_multiprocessing = mode == SessionMode.EDIT
        queue_manager = QueueManager(use_multiprocessing)
        kernel_manager = KernelManager(
            queue_manager,
            mode,
            configs,
            app_metadata,
            user_config_manager,
            virtual_files_supported=virtual_files_supported,
            redirect_console_to_browser=redirect_console_to_browser,
        )
        return cls(
            initialization_id,
            session_consumer,
            queue_manager,
            kernel_manager,
            app_file_manager,
        )

    def __init__(
        self,
        initialization_id: str,
        session_consumer: SessionConsumer,
        queue_manager: QueueManager,
        kernel_manager: KernelManager,
        app_file_manager: AppFileManager,
    ) -> None:
        """Initialize kernel and client connection to it."""
        # This is some unique ID that we can use to identify the session
        # in edit mode. We don't use the session_id because this can change if
        # the session is resumed
        self.initialization_id = initialization_id
        self.app_file_manager = app_file_manager
        self.room = Room()
        self._queue_manager = queue_manager
        self.kernel_manager = kernel_manager
        self.session_view = SessionView()

        self.kernel_manager.start_kernel()
        # Reads from the kernel connection and distributes the
        # messages to each subscriber.
        self.message_distributor: (
            ConnectionDistributor[KernelMessage]
            | QueueDistributor[KernelMessage]
        )
        if self.kernel_manager.mode == SessionMode.EDIT:
            self.message_distributor = ConnectionDistributor[KernelMessage](
                self.kernel_manager.kernel_connection
            )
        else:
            q = self._queue_manager.stream_queue
            assert q is not None
            self.message_distributor = QueueDistributor[KernelMessage](queue=q)

        self.message_distributor.add_consumer(
            lambda msg: self.session_view.add_raw_operation(msg[1])
        )
        self.connect_consumer(session_consumer, main=True)
        self.message_distributor.start()

        self.heartbeat_task: Optional[asyncio.Task[Any]] = None
        self._start_heartbeat()
        self._closed = False

    def _start_heartbeat(self) -> None:
        def _check_alive() -> None:
            if not self.kernel_manager.is_alive():
                LOGGER.debug("Closing session because kernel died")
                self.close()
                print_()
                print_tabbed(red("The Python kernel died unexpectedly."))
                print_()
                sys.exit()

        # Start a heartbeat task, which checks if the kernel is alive
        # every second

        async def _heartbeat() -> None:
            while True:
                await asyncio.sleep(1)
                _check_alive()

        try:
            loop = asyncio.get_event_loop()
            self.heartbeat_task = loop.create_task(_heartbeat())
        except RuntimeError:
            # This can happen if there is no event loop running
            self.heartbeat_task = None

    def try_interrupt(self) -> None:
        """Try to interrupt the kernel."""
        self.kernel_manager.interrupt_kernel()

    def put_control_request(self, request: requests.ControlRequest) -> None:
        """Put a control request in the control queue."""
        self._queue_manager.control_queue.put(request)
        if isinstance(request, SetUIElementValueRequest):
            self._queue_manager.set_ui_element_queue.put(request)
        # Propagate the control request to the room
        if isinstance(request, ExecuteMultipleRequest):
            self.room.broadcast(
                UpdateCellCodes(
                    cell_ids=request.cell_ids,
                    codes=request.codes,
                )
            )
            if len(request.cell_ids) == 1:
                self.room.broadcast(FocusCell(cell_id=request.cell_ids[0]))
        self.session_view.add_control_request(request)

    def put_completion_request(
        self, request: requests.CodeCompletionRequest
    ) -> None:
        """Put a code completion request in the completion queue."""
        self._queue_manager.completion_queue.put(request)

    def put_input(self, text: str) -> None:
        """Put an input() request in the input queue."""
        self._queue_manager.input_queue.put(text)
        self.session_view.add_stdin(text)

    def disconnect_consumer(self, session_consumer: SessionConsumer) -> None:
        """
        Stop the session consumer but keep the kernel running.

        This will disconnect the main session consumer,
        or a kiosk consumer.
        """
        self.room.remove_consumer(session_consumer)

    def maybe_disconnect_consumer(self) -> None:
        """
        Disconnect the main session consumer if it connected.
        """
        if self.room.main_consumer is not None:
            self.disconnect_consumer(self.room.main_consumer)

    def connect_consumer(
        self, session_consumer: SessionConsumer, *, main: bool
    ) -> None:
        """
        Connect or resume the session with a new consumer.

        If its the main consumer and one already exists,
        an exception is raised.
        """
        subscribe = session_consumer.on_start()
        unsubscribe_consumer = self.message_distributor.add_consumer(subscribe)
        self.room.add_consumer(
            session_consumer,
            unsubscribe_consumer,
            session_consumer.consumer_id,
            main=main,
        )

    def get_current_state(self) -> SessionView:
        """Return the current state of the session."""
        return self.session_view

    def connection_state(self) -> ConnectionState:
        """Return the connection state of the session."""
        if self._closed:
            return ConnectionState.CLOSED
        if self.room.main_consumer is None:
            return ConnectionState.ORPHANED
        return self.room.main_consumer.connection_state()

    def write_operation(self, operation: MessageOperation) -> None:
        """Write an operation to the session consumer and the session view."""
        self.session_view.add_operation(operation)
        self.room.broadcast(operation)

    def close(self) -> None:
        """
        Close the session.

        This will close the session consumer, kernel, and all kiosk consumers.
        """
        self._closed = True
        # Close the room
        self.room.close()
        # Close the kernel
        self.message_distributor.stop()
        if self.heartbeat_task:
            self.heartbeat_task.cancel()
        self.kernel_manager.close_kernel()

    def instantiate(self, request: InstantiateRequest) -> None:
        """Instantiate the app."""
        execution_requests = tuple(
            ExecutionRequest(cell_id=cell_data.cell_id, code=cell_data.code)
            for cell_data in self.app_file_manager.app.cell_manager.cell_data()
        )

        self.put_control_request(
            CreationRequest(
                execution_requests=execution_requests,
                set_ui_element_value_request=SetUIElementValueRequest(
                    object_ids=request.object_ids,
                    values=request.values,
                    token=str(uuid4()),
                ),
            )
        )

    def __repr__(self) -> str:
        return format_repr(
            self,
            {
                "connection_state": self.connection_state(),
                "room": self.room,
            },
        )

#+END_SRC
** Class SessionManager
#+BEGIN_SRC python
class SessionManager:
    """Mapping from client session IDs to sessions.

    Maintains a mapping from client session IDs to client sessions;
    there is exactly one session per client.

    The SessionManager also encapsulates state common to all sessions:
    - the app filename
    - the app mode (edit or run)
    - the auth token
    - the skew-protection token
    """

    def __init__(
        self,
        file_router: AppFileRouter,
        mode: SessionMode,
        development_mode: bool,
        quiet: bool,
        include_code: bool,
        lsp_server: LspServer,
        user_config_manager: UserConfigManager,
        cli_args: SerializedCLIArgs,
        auth_token: Optional[AuthToken],
        redirect_console_to_browser: bool = False,
    ) -> None:
        self.file_router = file_router
        self.mode = mode
        self.development_mode = development_mode
        self.quiet = quiet
        self.sessions: dict[SessionId, Session] = {}
        self.include_code = include_code
        self.lsp_server = lsp_server
        self.watcher: Optional[FileWatcher] = None
        self.recents = RecentFilesManager()
        self.user_config_manager = user_config_manager
        self.cli_args = cli_args
        self.redirect_console_to_browser = redirect_console_to_browser

        # Auth token and Skew-protection token
        if auth_token is not None:
            self.auth_token = auth_token
            self.skew_protection_token = SkewProtectionToken.random()
        elif mode == SessionMode.EDIT:
            # In edit mode, if no auth token is provided,
            # generate a random token
            self.auth_token = AuthToken.random()
            self.skew_protection_token = SkewProtectionToken.random()
        else:
            app = file_router.get_single_app_file_manager(
                default_width=user_config_manager.get_config()["display"][
                    "default_width"
                ]
            ).app
            codes = "".join(code for code in app.cell_manager.codes())
            # Because run-mode is read-only and we could have multiple
            # servers for the same app (going to sleep or autoscaling),
            # we default to a token based on the app's code
            self.auth_token = AuthToken.from_code(codes)
            self.skew_protection_token = SkewProtectionToken.from_code(codes)

    def app_manager(self, key: MarimoFileKey) -> AppFileManager:
        """
        Get the app manager for the given key.
        """
        return self.file_router.get_file_manager(
            key,
            default_width=self.user_config_manager.get_config()["display"][
                "default_width"
            ],
        )

    def create_session(
        self,
        session_id: SessionId,
        session_consumer: SessionConsumer,
        query_params: SerializedQueryParams,
        file_key: MarimoFileKey,
    ) -> Session:
        """Create a new session"""
        LOGGER.debug("Creating new session for id %s", session_id)
        if session_id not in self.sessions:
            app_file_manager = self.file_router.get_file_manager(
                file_key,
                default_width=self.user_config_manager.get_config()["display"][
                    "default_width"
                ],
            )

            if app_file_manager.path:
                self.recents.touch(app_file_manager.path)

            self.sessions[session_id] = Session.create(
                initialization_id=file_key,
                session_consumer=session_consumer,
                mode=self.mode,
                app_metadata=AppMetadata(
                    query_params=query_params,
                    filename=app_file_manager.path,
                    cli_args=self.cli_args,
                ),
                app_file_manager=app_file_manager,
                user_config_manager=self.user_config_manager,
                virtual_files_supported=True,
                redirect_console_to_browser=self.redirect_console_to_browser,
            )
        return self.sessions[session_id]

    def get_session(self, session_id: SessionId) -> Optional[Session]:
        session = self.sessions.get(session_id)
        if session:
            return session

        # Search for kiosk sessions
        for session in self.sessions.values():
            if session_id in session.room.consumers.values():
                return session

        return None

    def get_session_by_file_key(
        self, file_key: MarimoFileKey
    ) -> Optional[Session]:
        for session in self.sessions.values():
            if (
                session.initialization_id == file_key
                or session.app_file_manager.path == os.path.abspath(file_key)
            ):
                return session
        return None

    def maybe_resume_session(
        self, new_session_id: SessionId, file_key: MarimoFileKey
    ) -> Optional[Session]:
        """
        Try to resume a session if one is resumable.
        If it is resumable, return the session and update the session id.
        """

        # If in run mode, only resume the session if it is orphaned and has
        # the same session id, otherwise we want to create a new session
        if self.mode == SessionMode.RUN:
            maybe_session = self.get_session(new_session_id)
            if (
                maybe_session
                and maybe_session.connection_state()
                == ConnectionState.ORPHANED
            ):
                LOGGER.debug(
                    "Found a resumable RUN session: prev_id=%s",
                    new_session_id,
                )
                return maybe_session
            return None

        # Should only return an orphaned session
        sessions_with_the_same_file: dict[SessionId, Session] = {
            session_id: session
            for session_id, session in self.sessions.items()
            if session.app_file_manager.path == os.path.abspath(file_key)
        }

        if len(sessions_with_the_same_file) == 0:
            return None
        if len(sessions_with_the_same_file) > 1:
            raise InvalidSessionException(
                "Only one session should exist while editing"
            )

        (session_id, session) = next(iter(sessions_with_the_same_file.items()))
        connection_state = session.connection_state()
        if connection_state == ConnectionState.ORPHANED:
            LOGGER.debug(
                f"Found a resumable EDIT session: prev_id={session_id}"
            )
            # Set new session and remove old session
            self.sessions[new_session_id] = session
            # If the ID is the same, we don't need to delete the old session
            if new_session_id != session_id:
                del self.sessions[session_id]
            return session

        LOGGER.debug(
            "Session is not resumable, current state: %s",
            connection_state,
        )
        return None

    def any_clients_connected(self, key: MarimoFileKey) -> bool:
        """Returns True if at least one client has an open socket."""
        if key.startswith(AppFileRouter.NEW_FILE):
            return False

        for session in self.sessions.values():
            if session.connection_state() == ConnectionState.OPEN and (
                session.app_file_manager.path == os.path.abspath(key)
            ):
                return True
        return False

    async def start_lsp_server(self) -> None:
        """Starts the lsp server if it is not already started.

        Doesn't start in run mode.
        """
        if self.mode == SessionMode.RUN:
            LOGGER.warning("Cannot start LSP server in run mode")
            return

        alert = self.lsp_server.start()

        if alert is not None:
            for _, session in self.sessions.items():
                session.write_operation(alert)
            return

    def close_session(self, session_id: SessionId) -> bool:
        LOGGER.debug("Closing session %s", session_id)
        session = self.get_session(session_id)
        if session is not None:
            session.close()
            del self.sessions[session_id]
            return True
        return False

    def close_all_sessions(self) -> None:
        LOGGER.debug("Closing all sessions (sessions: %s)", self.sessions)
        for session in self.sessions.values():
            session.close()
        LOGGER.debug("Closed all sessions.")
        self.sessions = {}

    def shutdown(self) -> None:
        LOGGER.debug("Shutting down")
        self.close_all_sessions()
        self.lsp_server.stop()
        if self.watcher:
            self.watcher.stop()

    def should_send_code_to_frontend(self) -> bool:
        """Returns True if the server can send messages to the frontend."""
        return self.mode == SessionMode.EDIT or self.include_code

    def start_file_watcher(self) -> Disposable:
        """Starts the file watcher if it is not already started"""
        if self.mode == SessionMode.EDIT:
            # We don't support file watching in edit mode yet
            # as there are some edge cases that would need to be handled.
            # - what to do if the file is deleted, or is renamed
            # - do we re-run the app or just show the changed code
            # - we don't properly handle saving from the frontend
            LOGGER.warning("Cannot start file watcher in edit mode")
            return Disposable.empty()
        file = self.file_router.maybe_get_single_file()
        if not file:
            return Disposable.empty()

        file_path = file.path

        async def on_file_changed(path: Path) -> None:
            LOGGER.debug(f"{path} was modified")
            for _, session in self.sessions.items():
                session.app_file_manager.reload()
                session.write_operation(Reload())

        LOGGER.debug("Starting file watcher for %s", file_path)
        self.watcher = FileWatcher.create(Path(file_path), on_file_changed)
        self.watcher.start()
        return Disposable(self.watcher.stop)

#+END_SRC
** Class LspServer
#+BEGIN_SRC python
class LspServer:
    def __init__(self, port: int) -> None:
        self.port = port
        self.process: Optional[subprocess.Popen[bytes]] = None

    @server_tracer.start_as_current_span("lsp_server.start")
    def start(self) -> Optional[Alert]:
        if self.process is not None:
            LOGGER.debug("LSP server already started")
            return None

        binpath = shutil.which("node")
        if binpath is None:
            LOGGER.error("Node.js not found; cannot start LSP server.")
            return Alert(
                title="GitHub Copilot: Connection Error",
                description="<span><a class='hyperlink' href='https://docs.marimo.io/getting_started/index.html#github-copilot'>Install Node.js</a> to use copilot.</span>",  # noqa: E501
                variant="danger",
            )

        cmd = None
        try:
            LOGGER.debug("Starting LSP server at port %s...", self.port)
            lsp_bin = os.path.join(
                str(import_files("marimo").joinpath("_lsp")),
                "index.js",
            )

            # Check if the LSP binary exists
            if not os.path.exists(lsp_bin):
                # Only debug since this may not exist in conda environments
                LOGGER.debug("LSP binary not found at %s", lsp_bin)
                return None

            cmd = f"node {lsp_bin} --port {self.port}"
            LOGGER.debug("... running command: %s", cmd)
            self.process = subprocess.Popen(
                cmd.split(),
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                stdin=subprocess.DEVNULL,
            )
            LOGGER.debug(
                "... node process return code (`None` means success): %s",
                self.process.returncode,
            )
            LOGGER.debug("Started LSP server at port %s", self.port)
        except Exception as e:
            LOGGER.error(
                "When starting language server (%s), got error: %s",
                cmd,
                e,
            )
            self.process = None

        return None

    def is_running(self) -> bool:
        return self.process is not None

    def stop(self) -> None:
        if self.process is not None:
            self.process.terminate()
            self.process = None
            LOGGER.debug("Stopped LSP server at port %s", self.port)
        else:
            LOGGER.debug("LSP server not running")

#+END_SRC
** Class NoopLspServer
#+BEGIN_SRC python
class NoopLspServer(LspServer):
    def __init__(self) -> None:
        super().__init__(0)

    def start(self) -> None:
        pass

    def stop(self) -> None:
        pass

#+END_SRC
* start
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.start
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/start.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import os
import re
from typing import Optional

import uvicorn

import marimo._server.api.lifespans as lifespans
from marimo._config.manager import UserConfigManager
from marimo._runtime.requests import SerializedCLIArgs
from marimo._server.file_router import AppFileRouter
from marimo._server.main import create_starlette_app
from marimo._server.model import SessionMode
from marimo._server.sessions import LspServer, SessionManager
from marimo._server.tokens import AuthToken
from marimo._server.utils import (
    find_free_port,
    initialize_asyncio,
    initialize_fd_limit,
)
from marimo._server.uvicorn_utils import initialize_signals
from marimo._utils.paths import import_files

#+END_SRC
** Assignment DEFAULT_PORT = 2718
#+BEGIN_SRC python
DEFAULT_PORT = 2718

#+END_SRC
** Assignment PROXY_REGEX = re.compile(r"^(.*):(\d+)$")
#+BEGIN_SRC python
PROXY_REGEX = re.compile(r"^(.*):(\d+)$")

#+END_SRC
** Function _resolve_proxy
#+BEGIN_SRC python
def _resolve_proxy(
    port: int, host: str, proxy: Optional[str]
) -> tuple[int, str]:
    """Provided that there is a proxy, utilize the host and port of the proxy.

    -----------------         Communication has to be consistent
    |   User        | ----    so Starlette only needs to know the
    -----------------     |   external facing endpoint, while uvi-
                          |   corn handles the actual running of
                          v   the app.
                  -----------------
      e.g. nginx  |   Proxy       |
                  -----------------
                          |
                          v
                  -----------------
        the app   |   marimo      |
       (uvicorn)  -----------------


    If the proxy is provided, it will default to port 80. Otherwise if the
    proxy has a port specified, it will use that port.
    e.g. `example.com:8080`
    """
    if not proxy:
        return port, host

    match = PROXY_REGEX.match(proxy)
    # Our proxy has an explicit port defined, so return that.
    if match:
        external_host, external_port = match.groups()
        return int(external_port), external_host

    # A default to 80 is reasonable if a proxy is provided.
    return 80, proxy

#+END_SRC
** Function start
#+BEGIN_SRC python
def start(
    *,
    file_router: AppFileRouter,
    mode: SessionMode,
    development_mode: bool,
    quiet: bool,
    include_code: bool,
    headless: bool,
    port: Optional[int],
    host: str,
    proxy: Optional[str],
    watch: bool,
    cli_args: SerializedCLIArgs,
    base_url: str = "",
    allow_origins: Optional[tuple[str, ...]] = None,
    auth_token: Optional[AuthToken],
    redirect_console_to_browser: bool,
) -> None:
    """
    Start the server.
    """

    # Find a free port if none is specified
    # if the user specifies a port, we don't try to find a free one
    port = port or find_free_port(DEFAULT_PORT)
    lsp_port = find_free_port(DEFAULT_PORT + 200)  # Add 200 to avoid conflicts
    user_config_mgr = UserConfigManager()

    session_manager = SessionManager(
        file_router=file_router,
        mode=mode,
        development_mode=development_mode,
        quiet=quiet,
        include_code=include_code,
        lsp_server=LspServer(lsp_port),
        user_config_manager=user_config_mgr,
        cli_args=cli_args,
        auth_token=auth_token,
        redirect_console_to_browser=redirect_console_to_browser,
    )

    log_level = "info" if development_mode else "error"

    (external_port, external_host) = _resolve_proxy(port, host, proxy)
    app = create_starlette_app(
        base_url=base_url,
        host=external_host,
        lifespan=lifespans.Lifespans(
            [
                lifespans.lsp,
                lifespans.watcher,
                lifespans.etc,
                lifespans.signal_handler,
                lifespans.logging,
                lifespans.open_browser,
            ]
        ),
        allow_origins=allow_origins,
        enable_auth=not AuthToken.is_empty(session_manager.auth_token),
        lsp_port=lsp_port,
    )

    app.state.port = external_port
    app.state.lsp_port = lsp_port
    app.state.host = external_host

    app.state.headless = headless
    app.state.watch = watch
    app.state.session_manager = session_manager
    app.state.base_url = base_url
    app.state.config_manager = user_config_mgr

    # Resource initialization
    # Increase the limit on open file descriptors to prevent resource
    # exhaustion when opening multiple notebooks in the same server.
    initialize_fd_limit(limit=4096)
    initialize_signals()

    server = uvicorn.Server(
        uvicorn.Config(
            app,
            port=port,
            host=host,
            # TODO: cannot use reload unless the app is an import string
            # although cannot use import string because it breaks the
            # session manager
            # reload=development_mode,
            reload_dirs=(
                [
                    os.path.realpath(
                        str(import_files("marimo").joinpath("_static"))
                    )
                ]
                if development_mode
                else None
            ),
            log_level=log_level,
            # uvicorn times out HTTP connections (i.e. TCP sockets) every 5
            # seconds by default; for some reason breaks the server in
            # mysterious ways (it stops processing requests) in edit mode.
            timeout_keep_alive=300 if mode == SessionMode.RUN else int(1e9),
            # ping the websocket once a second to prevent intermittent
            # disconnections
            ws_ping_interval=1,
            # close the websocket if we don't receive a pong after 60 seconds
            ws_ping_timeout=60,
            timeout_graceful_shutdown=1,
            # Under uvloop, reading the socket we monitor under add_reader()
            # occasionally throws BlockingIOError (errno 11, or errno 35,
            # ...). RUN mode no longer uses a socket (it has no IPC) but EDIT
            # does, so force asyncio.
            loop="asyncio" if mode == SessionMode.EDIT else "auto",
        )
    )
    app.state.server = server

    initialize_asyncio()
    server.run()

#+END_SRC
* tokens
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.tokens
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/tokens.py
:END:
** import_statement
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import secrets

#+END_SRC
** Class AuthToken
#+BEGIN_SRC python
# Adapted from starlette, to avoid a dependency when running without starlette.
class AuthToken:
    """
    Holds a string value that should not be revealed in tracebacks etc.
    You should cast the value to `str` at the point it is required.
    """

    def __init__(self, value: str):
        self._value = value

    def __repr__(self) -> str:
        class_name = self.__class__.__name__
        return f"{class_name}('**********')"

    def __str__(self) -> str:
        return self._value

    def __bool__(self) -> bool:
        return bool(self._value)

    @staticmethod
    def random() -> AuthToken:
        return AuthToken(secrets.token_urlsafe(16))

    @staticmethod
    def from_code(code: str) -> AuthToken:
        return AuthToken(str(hash(code)))

    @staticmethod
    def is_empty(token: AuthToken) -> bool:
        return str(token) == ""

#+END_SRC
** Class SkewProtectionToken
#+BEGIN_SRC python
class SkewProtectionToken:
    """
    Provides a token that is sent to the client on the first request and
    is used to protect against version skew bugs.

    This can happen when new code is deployed to the server but the client
    still has only application loaded.
    """

    def __init__(self, token: str) -> None:
        self.token = token

    @staticmethod
    def from_code(code: str) -> SkewProtectionToken:
        return SkewProtectionToken(str(hash(code)))

    @staticmethod
    def random() -> SkewProtectionToken:
        return SkewProtectionToken(secrets.token_urlsafe(16))

    def __str__(self) -> str:
        return self.token

#+END_SRC
* types
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.types
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/types.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING, TypeVar, Union

#+END_SRC
** Assignment T = TypeVar("T")
#+BEGIN_SRC python
if TYPE_CHECKING:
    import multiprocessing as mp
    from queue import Queue

T = TypeVar("T")

#+END_SRC
** Assignment QueueType = Union["mp.Queue[T]", "Queue[T]"]
#+BEGIN_SRC python
# strings for python 3.8 compatibility
QueueType = Union["mp.Queue[T]", "Queue[T]"]

#+END_SRC
* utils
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.utils
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/utils.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import asyncio
import os
import sys
from typing import TYPE_CHECKING, Any, TypeVar

from marimo import _loggers
from marimo._utils.marimo_path import MarimoPath

#+END_SRC
** Assignment TAB = "        "
#+BEGIN_SRC python
if TYPE_CHECKING:
    from collections.abc import Coroutine

# use spaces instead of a tab to play well with carriage returns;
# \r\t doesn't appear to overwrite characters at the start of a line,
# but \r{TAB} does ...
TAB = "        "

#+END_SRC
** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
** Function print_tabbed
#+BEGIN_SRC python
def print_tabbed(string: str, n_tabs: int = 1) -> None:
    print_(f"{TAB * n_tabs}{string}")

#+END_SRC
** Function canonicalize_filename
#+BEGIN_SRC python
def canonicalize_filename(filename: str) -> str:
    # If its not a valid Python or Markdown file, then add .py
    if not MarimoPath.is_valid_path(filename):
        filename += ".py"
    return os.path.expanduser(filename)

#+END_SRC
** Function find_free_port
#+BEGIN_SRC python
def find_free_port(port: int, attempts: int = 100) -> int:
    """Find a free port or move to the next one recursively"""

    import socket

    # Valid port range is 1-65535
    port = max(1, min(port, 65535))

    if attempts == 0:
        raise RuntimeError("Could not find a free port")

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        try:
            in_use = sock.connect_ex(("localhost", port)) == 0
            if not in_use:
                return port
        except OSError:
            LOGGER.debug(f"Port {port} is already in use")
            pass

    # Ensure we don't exceed valid port range
    next_port = min(port + 1, 65535)
    if next_port == port:
        raise RuntimeError("No more ports available")

    return find_free_port(next_port, attempts - 1)

#+END_SRC
** Function initialize_mimetypes
#+BEGIN_SRC python
def initialize_mimetypes() -> None:
    import mimetypes

    # Fixes an issue with invalid mimetypes on windows:
    # https://github.com/encode/starlette/issues/829#issuecomment-587163696
    mimetypes.add_type("application/javascript", ".js")
    mimetypes.add_type("text/css", ".css")
    mimetypes.add_type("image/svg+xml", ".svg")

#+END_SRC
** Function initialize_asyncio
#+BEGIN_SRC python
def initialize_asyncio() -> None:
    """Platform-specific initialization of asyncio.

    Sessions use the `add_reader()` API, which is only available in the
    SelectorEventLoop policy; Windows uses the Proactor by default.
    """
    if sys.platform == "win32":
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

#+END_SRC
** Function initialize_fd_limit
#+BEGIN_SRC python
def initialize_fd_limit(limit: int) -> None:
    """Raise the limit on open file descriptors.

    Not applicable on Windows.
    """
    try:
        import resource
    except ImportError:
        # Windows
        return

    old_soft, old_hard = resource.getrlimit(resource.RLIMIT_NOFILE)
    if limit > old_soft and limit <= old_hard:
        resource.setrlimit(resource.RLIMIT_NOFILE, (limit, old_hard))

#+END_SRC
** Assignment T = TypeVar("T")
#+BEGIN_SRC python
T = TypeVar("T")

#+END_SRC
** Function asyncio_run
#+BEGIN_SRC python
def asyncio_run(coro: Coroutine[Any, Any, T], **kwargs: dict[Any, Any]) -> T:
    """asyncio.run() with platform-specific initialization.

    When using Sessions, make sure to use this method instead of `asyncio.run`.

    If not using a Session, don't call this method.

    `kwargs` are passed to `asyncio.run()`
    """
    initialize_asyncio()
    return asyncio.run(coro, **kwargs)  # type: ignore[arg-type]

#+END_SRC
** Function print_
#+BEGIN_SRC python
def print_(*args: Any, **kwargs: Any) -> None:
    try:
        import click

        click.echo(*args, **kwargs)
    except ImportError:
        print(*args, **kwargs)  # noqa: T201

#+END_SRC
* uvicorn_utils
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.uvicorn_utils
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/uvicorn_utils.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import asyncio
import signal
import sys
from typing import Any

import uvicorn

from marimo import _loggers

#+END_SRC
** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
** Function initialize_signals
#+BEGIN_SRC python
def initialize_signals() -> None:
    from packaging import version

    # 0.29.0 changed how uvicorn handles signals
    #
    # https://github.com/encode/uvicorn/pull/1600
    #
    # In 0.29.0, uvicorn re-throws signals after quitting, which leads to
    # ungraceful shutdowns since we use a SIGINT to kill uvicorn in the
    # first place
    #
    # Must be called before a uvicorn server is started
    if version.parse(uvicorn.__version__) >= version.parse("0.29.0"):

        def noop(signum: int, frame: Any) -> None:
            del signum
            del frame
            ...

        signal.signal(signal.SIGINT, noop)

#+END_SRC
** Function close_uvicorn
#+BEGIN_SRC python
def close_uvicorn(server: uvicorn.Server) -> None:
    from packaging import version

    LOGGER.debug("Shutting down uvicorn")

    # Tried using sys.exit(0) to quit instead, but that ends up not being
    # graceful due to the event loop still running
    if (
        version.parse(uvicorn.__version__) >= version.parse("0.29.0")
        # pytest appears to run tests outside the main thread, causing
        # signal functions to fail
        and "pytest" not in sys.modules
    ):
        loop = asyncio.get_running_loop()

        # remove interrupt handler -- uvicorn shouldn't re-interrupt marimo
        # only needed because uvicorn saves original handlers before
        # server.run() is called, then re-raises signals ...
        try:
            loop.remove_signal_handler(signal.SIGINT)
        except NotImplementedError:
            # Windows
            def noop(signum: int, frame: Any) -> None:
                del signum
                del frame
                ...

            signal.signal(signal.SIGINT, noop)

    server.handle_exit(signal.SIGINT, None)

    LOGGER.debug("Shut down uvicorn")

#+END_SRC
* ai
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.ai
:END:
** prompts
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.ai.prompts
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/ai/prompts.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Optional

from marimo._server.models.completion import (
    AiCompletionContext,
    Language,
)

#+END_SRC
*** Assignment language_rules
#+BEGIN_SRC python
language_rules = {
    "python": [
        "Do not describe the code, just write the code.",
        "Do not output markdown or backticks.",
        "When using matplotlib to show plots, use plt.gca() instead of plt.show().",
        "If an import already exists, do not import it again.",
        "If a variable is already defined, use another name, or make it private by adding an underscore at the beginning.",
    ],
    "markdown": [],
    "sql": [
        "The SQL must use duckdb syntax.",
    ],
}

#+END_SRC
*** Class Prompter
#+BEGIN_SRC python
class Prompter:
    def __init__(
        self,
        code: str,
        context: Optional[AiCompletionContext],
    ):
        self.code = code
        self.context = context

    @staticmethod
    def get_system_prompt(
        *, language: Language, custom_rules: Optional[str] = None
    ) -> str:
        if language in language_rules:
            all_rules = [f"You can only output {language}."] + language_rules[
                language
            ]
            rules = "\n".join(
                f"{i+1}. {rule}" for i, rule in enumerate(all_rules)
            )
            system_prompt = (
                f"You are a helpful assistant that can answer questions about {language}."
                f" Here are your rules: \n{rules}"
            )

            if custom_rules and custom_rules.strip():
                system_prompt += f"\n\nAdditional rules:\n{custom_rules}"

            return system_prompt
        else:
            return "You are a helpful assistant that can answer questions."

    def get_prompt(self, *, user_prompt: str, include_other_code: str) -> str:
        prompt = user_prompt
        if include_other_code:
            prompt += f"\n\nCode from other cells:\n{include_other_code}"
        if self.code.strip():
            prompt += f"\n\nCurrent code:\n{self.code}"
        if self.context and self.context.schema:
            schema_info = "\n\nAvailable schema:\n"
            for schema in self.context.schema:
                columns = ", ".join(
                    [f"{col.name} ({col.type})" for col in schema.columns]
                )
                schema_info += f"- {schema.name}: {columns}\n"
            prompt += schema_info
        return prompt

    @staticmethod
    def get_chat_system_prompt(
        *,
        custom_rules: Optional[str] = None,
        variables: Optional[list[str]] = None,
        context: Optional[AiCompletionContext] = None,
        include_other_code: str = "",
    ) -> str:
        system_prompt = (
            "You are a helpful assistant working in a marimo notebook. "
            "You can answer questions and help with tasks. "
            "You may respond with markdown, code, or a combination of both. "
            "If you respond in code, you must use the appropriate language block. "
            "And you only work with two languages: Python and SQL. "
            "When responding in code, think of each block of code as a separate cell in the notebook. "
            "The notebook has 2 hard rules: \n"
            "1. Do not import the same library twice. \n"
            "2. Do not define a variable if it already exists. You may reference variables from previous cells, "
            "but you may not define a variable if it already exists. \n"
        )

        for language in language_rules:
            if len(language_rules[language]) == 0:
                continue

            rules = "\n".join(
                f"{i+1}. {rule}"
                for i, rule in enumerate(language_rules[language])
            )

            system_prompt += f"\n\nRules for {language}:\n{rules}"

        if custom_rules and custom_rules.strip():
            system_prompt += f"\n\nAdditional rules:\n{custom_rules}"

        if variables:
            system_prompt += (
                f"\n\nVariables to use but not define:\n{variables}"
            )

        if include_other_code:
            system_prompt += (
                f"\n\nCode from other cells:\n{include_other_code.strip()}"
            )

        if context and context.schema:
            schema_info = "\n\nAvailable schema:\n"
            for schema in context.schema:
                columns = ", ".join(
                    [f"{col.name} ({col.type})" for col in schema.columns]
                )
                schema_info += f"- {schema.name}: {columns}\n"
            system_prompt += schema_info

        return system_prompt

#+END_SRC
* api
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api
:END:
** auth
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.auth
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/auth.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import base64
import secrets
import typing
from typing import TYPE_CHECKING, Any, Dict, Optional

import starlette
import starlette.status as status
from starlette.datastructures import Secret
from starlette.exceptions import HTTPException
from starlette.middleware.sessions import SessionMiddleware
from starlette.responses import JSONResponse

from marimo import _loggers

#+END_SRC
*** Import statements
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.authentication import AuthenticationError
    from starlette.requests import HTTPConnection
    from starlette.types import ASGIApp, Receive, Scope, Send

from marimo._server.api.deps import AppState

#+END_SRC
*** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
*** Assignment TOKEN_QUERY_PARAM = "access_token"
#+BEGIN_SRC python
TOKEN_QUERY_PARAM = "access_token"

#+END_SRC
*** Function validate_auth
#+BEGIN_SRC python
# Validates auth
# - Checking for existing session cookie (already authenticated)
# - Or authenticates by access_token in query params
# - Or authenticates by basic auth
def validate_auth(
    conn: HTTPConnection, form_dict: Optional[dict[str, str]] = None
) -> bool:
    LOGGER.debug("Validating auth")
    state = AppState.from_app(conn.app)
    auth_token = str(state.session_manager.auth_token)

    # Check for session cookie
    cookie_session = CookieSession(conn.session)
    # Validate the cookie
    if cookie_session.get_access_token() == auth_token:
        return True  # Success

    # Check for access_token
    if TOKEN_QUERY_PARAM in conn.query_params:
        # Validate the access_token
        if conn.query_params[TOKEN_QUERY_PARAM] == auth_token:
            LOGGER.debug("Validated access_token")
            # Set the cookie
            cookie_session.set_access_token(auth_token)
            return True  # Success

    # Check for form data
    if form_dict is not None:
        # Validate the access_token
        password = form_dict.get("password")
        if password == auth_token:
            LOGGER.debug("Validated access_token")
            # Set the cookie
            cookie_session.set_access_token(auth_token)
            return True
        else:
            return False

    # Check for basic auth
    auth = conn.headers.get("Authorization")
    if auth is not None:
        username, password = _parse_basic_auth_header(auth)
        if username and password == auth_token:
            LOGGER.debug("Validated basic auth")
            # Set the cookie
            cookie_session.set_access_token(auth_token)
            cookie_session.set_username(username)
            return True  # Success

    LOGGER.debug("Invalid auth")
    return False

#+END_SRC
*** Function _parse_basic_auth_header
#+BEGIN_SRC python
def _parse_basic_auth_header(
    header: str,
) -> tuple[Optional[str], Optional[str]]:
    scheme, _, credentials = header.partition(" ")

    if scheme.lower() != "basic":
        LOGGER.debug("Invalid auth scheme: %s", scheme)
        return None, None

    decoded = base64.b64decode(credentials).decode("utf-8")
    username, _, password = decoded.partition(":")

    if not password:
        return None, None

    LOGGER.debug("Validated basic auth for user: %s", username)

    return username, password

#+END_SRC
*** Function raise_basic_auth_error
#+BEGIN_SRC python
def raise_basic_auth_error() -> HTTPException:
    return HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Authorization header required",
        headers={"WWW-Authenticate": "Basic"},
    )

#+END_SRC
*** Function on_auth_error
#+BEGIN_SRC python
def on_auth_error(
    request: HTTPConnection, error: AuthenticationError
) -> JSONResponse:
    del request
    del error
    return JSONResponse(
        status_code=status.HTTP_401_UNAUTHORIZED,
        content={"detail": "Authorization header required"},
        headers={"WWW-Authenticate": "Basic"},
    )

#+END_SRC
*** Assignment RANDOM_SECRET = Secret(secrets.token_hex(32))
#+BEGIN_SRC python
# This is random/new for each server instance
RANDOM_SECRET = Secret(secrets.token_hex(32))

#+END_SRC
*** Class CookieSession
#+BEGIN_SRC python
class CookieSession:
    """
    Wrapper around starlette's Session to add typesafety
    """

    def __init__(self, session_state: Dict[str, Any]) -> None:
        self.session_state = session_state

    def get_access_token(self) -> str:
        access_token: str = self.session_state.get("access_token", "")
        return access_token

    def get_username(self) -> str:
        username: str = self.session_state.get("username", "")
        return username

    def set_access_token(self, token: str) -> None:
        self.session_state["access_token"] = token

    def set_username(self, username: str) -> None:
        self.session_state["username"] = username

#+END_SRC
*** Class CustomSessionMiddleware
#+BEGIN_SRC python
class CustomSessionMiddleware(SessionMiddleware):
    """
    Wrapper around starlette's SessionMiddleware to:
     - customize the session cookie based on the the port
     - only run in Edit mode
    """

    def __init__(
        self,
        app: ASGIApp,
        secret_key: typing.Union[str, Secret],
        session_cookie: str = "session",
        max_age: typing.Optional[int] = 14
        * 24
        * 60
        * 60,  # 14 days, in seconds
        path: str = "/",
        same_site: typing.Literal["lax", "strict", "none"] = "lax",
        https_only: bool = False,
        domain: typing.Optional[str] = None,
    ) -> None:
        from packaging import version

        # We can't update the cookie here since
        # we don't have access to the app state

        self.original_session_cookie = session_cookie

        if version.parse(starlette.__version__) >= version.parse("0.32.0"):
            # Domain was added in 0.32.0; we currently don't use it.
            super().__init__(
                app,
                secret_key,
                session_cookie,
                max_age,
                path,
                same_site,
                https_only,
                domain,
            )
        else:
            super().__init__(
                app,
                secret_key,
                session_cookie,
                max_age,
                path,
                same_site,
                https_only,
            )

    async def __call__(
        self, scope: Scope, receive: Receive, send: Send
    ) -> None:
        if scope["type"] not in ("http", "websocket"):
            await self.app(scope, receive, send)
            return

        state = AppState.from_app(scope["app"])

        # We key the token cookie by port to avoid conflicts
        # with multiple marimo instances running on the same host
        maybe_port = state.maybe_port
        if maybe_port is not None:
            self.session_cookie = (
                f"{self.original_session_cookie}_{maybe_port}"
            )

        return await super().__call__(scope, receive, send)

#+END_SRC
** deps
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.deps
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/deps.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING, Any, Optional, Union, cast

from marimo import _loggers as loggers
from marimo._config.manager import UserConfigManager
from marimo._server.ids import SessionId
from marimo._server.model import SessionMode
from marimo._server.sessions import Session, SessionManager
from marimo._server.tokens import SkewProtectionToken

#+END_SRC
*** Assignment LOGGER = loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.applications import Starlette
    from starlette.datastructures import State
    from starlette.requests import Request
    from starlette.websockets import WebSocket
    from uvicorn import Server

LOGGER = loggers.marimo_logger()

#+END_SRC
*** Class AppStateBase
#+BEGIN_SRC python
class AppStateBase:
    """The app state."""

    @staticmethod
    def from_request(request: Union[Request, WebSocket]) -> AppState:
        """Get the app state with a request."""
        return AppState(request)

    @staticmethod
    def from_app(asgi: Starlette) -> AppStateBase:
        """Get the app state with an ASGIApp app."""
        return AppStateBase(cast(Any, asgi).state)

    def __init__(self, state: State) -> None:
        """Initialize the app state."""
        self.state = state

    @property
    def session_manager(self) -> SessionManager:
        return cast(SessionManager, self.state.session_manager)

    @property
    def mode(self) -> SessionMode:
        return self.session_manager.mode

    @property
    def quiet(self) -> bool:
        return self.session_manager.quiet

    @property
    def development_mode(self) -> bool:
        return self.session_manager.development_mode

    @property
    def host(self) -> str:
        host: str = self.state.host
        return host

    @property
    def port(self) -> int:
        post: int = self.state.port
        return post

    @property
    def maybe_port(self) -> Optional[int]:
        return self.state._state.get("port")

    @property
    def base_url(self) -> str:
        base_url: str = self.state.base_url
        return base_url

    @property
    def server(self) -> Server:
        server: Server = self.state.server
        return server

    @property
    def config_manager(self) -> UserConfigManager:
        cm: UserConfigManager = self.state.config_manager
        return cm

    @property
    def watch(self) -> bool:
        watch: bool = self.state.watch
        return watch

    @property
    def headless(self) -> bool:
        headless: bool = self.state.headless
        return headless

    @property
    def skew_protection_token(self) -> SkewProtectionToken:
        return self.session_manager.skew_protection_token

#+END_SRC
*** Class AppState
#+BEGIN_SRC python
class AppState(AppStateBase):
    """The app state with a request."""

    def __init__(self, request: Union[Request, WebSocket]) -> None:
        """Initialize the app state with a request."""
        super().__init__(request.app.state)
        self.request = request

    def get_current_session_id(self) -> Optional[SessionId]:
        """Get the current session."""
        return self.request.headers.get("Marimo-Session-Id")

    def require_current_session_id(self) -> SessionId:
        """Get the current session or raise an error."""
        session_id = self.get_current_session_id()
        if session_id is None:
            raise ValueError("Missing Marimo-Session-Id header")
        return session_id

    def get_current_session(self) -> Optional[Session]:
        """Get the current session."""
        session_id = self.get_current_session_id()
        if session_id is None:
            return None
        return self.session_manager.get_session(session_id)

    def require_current_session(self) -> Session:
        """Get the current session or raise an error."""
        session_id = self.require_current_session_id()
        session = self.session_manager.get_session(session_id)
        if session is None:
            LOGGER.warning(
                "Valid sessions: %s",
                list(self.session_manager.sessions.keys()),
            )
            raise ValueError(f"Invalid session id: {session_id}")
        return session

    def require_query_params(self, param: str) -> str:
        """Get a query parameter or raise an error."""
        value = self.request.query_params[param]
        if not value:
            raise ValueError(f"Missing query parameter: {param}")
        return value

    def query_params(self, param: str) -> Optional[str]:
        """Get a query parameter."""
        if param not in self.request.query_params:
            return None
        return self.request.query_params[param]

#+END_SRC
** interrupt
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.interrupt
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/interrupt.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import asyncio
import signal
from typing import Callable

from marimo._config.settings import GLOBAL_SETTINGS
from marimo._server.utils import (
    TAB,
    print_,
)

#+END_SRC
*** Class InterruptHandler
#+BEGIN_SRC python
class InterruptHandler:
    def __init__(self, quiet: bool, shutdown: Callable[[], None]) -> None:
        self.quiet = quiet
        self.shutdown = shutdown
        self.loop = asyncio.get_event_loop()
        self.original_handler = signal.getsignal(signal.SIGINT)

    def _add_interrupt_handler(self) -> None:
        try:
            self.loop.add_signal_handler(
                signal.SIGINT, self._interrupt_handler
            )
        except NotImplementedError:
            # Windows
            signal.signal(
                signal.SIGINT,
                lambda signum, frame: self._interrupt_handler(),  # noqa: ARG005,E501
            )

    def restore_interrupt_handler(self) -> None:
        # Restore the original signal handler so re-entering Ctrl+C raises a
        # keyboard interrupt instead of calling this function again (input is
        # not re-entrant, so it's not safe to call this function again)
        try:
            self.loop.remove_signal_handler(signal.SIGINT)
        except NotImplementedError:
            # Windows
            signal.signal(signal.SIGINT, self.original_handler)

    def _interrupt_handler(self) -> None:
        # Restore the original signal handler so re-entering Ctrl+C raises a
        # keyboard interrupt instead of calling this function again (input is
        # not re-entrant, so it's not safe to call this function again)
        try:
            self.loop.remove_signal_handler(signal.SIGINT)
        except NotImplementedError:
            # Windows
            signal.signal(signal.SIGINT, self.original_handler)

        if self.quiet:
            self.shutdown()

        try:
            if GLOBAL_SETTINGS.YES:
                self.shutdown()
                return

            response = input(
                f"\r{TAB}\033[1;32mAre you sure you want to quit?\033[0m "
                "\033[1m(y/n)\033[0m: "
            )
            if response.lower().strip() == "y":
                self.shutdown()
                return
        except (KeyboardInterrupt, EOFError, asyncio.CancelledError):
            print_()
            self.shutdown()
            return

        # Program is still alive: restore the interrupt handler
        self._add_interrupt_handler()

    def register(self) -> None:
        self._add_interrupt_handler()

#+END_SRC
** lifespans
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.lifespans
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/lifespans.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import asyncio
import contextlib
import socket
import sys
from collections.abc import AsyncIterator, Callable, Sequence
from contextlib import AbstractAsyncContextManager

from starlette.applications import Starlette

from marimo._server.api.deps import AppState, AppStateBase
from marimo._server.file_router import AppFileRouter
from marimo._server.sessions import SessionManager
from marimo._server.tokens import AuthToken

#+END_SRC
*** Import statements
#+BEGIN_SRC python
if sys.version_info < (3, 10):
    from typing_extensions import TypeAlias
else:
    from typing import TypeAlias

from marimo import _loggers
from marimo._server.api.interrupt import InterruptHandler
from marimo._server.api.utils import open_url_in_browser
from marimo._server.model import SessionMode
from marimo._server.print import print_shutdown, print_startup
from marimo._server.utils import initialize_mimetypes
from marimo._server.uvicorn_utils import close_uvicorn

#+END_SRC
*** Assignment LifespanList
#+BEGIN_SRC python
LifespanList: TypeAlias = Sequence[
    Callable[[Starlette], AbstractAsyncContextManager[None]]
]

#+END_SRC
*** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
*** Class Lifespans
#+BEGIN_SRC python
# Compound lifespans
class Lifespans:
    def __init__(
        self,
        lifespans: LifespanList,
    ) -> None:
        self.lifespans = lifespans

    @contextlib.asynccontextmanager
    async def _manager(
        self,
        app: Starlette,
        lifespans: LifespanList,
    ) -> AsyncIterator[None]:
        exit_stack = contextlib.AsyncExitStack()
        try:
            async with exit_stack:
                for lifespan in lifespans:
                    LOGGER.debug(f"Setup: {lifespan.__name__}")
                    await exit_stack.enter_async_context(lifespan(app))
                yield
        except asyncio.CancelledError:
            pass

    def __call__(self, app: Starlette) -> AbstractAsyncContextManager[None]:
        return self._manager(app, lifespans=self.lifespans)

#+END_SRC
*** @contextlib.asynccontextmanager: Function lsp
#+BEGIN_SRC python
@contextlib.asynccontextmanager
async def lsp(app: Starlette) -> AsyncIterator[None]:
    state = AppState.from_app(app)
    user_config = state.config_manager.get_config()
    session_mgr = state.session_manager
    run = session_mgr.mode == SessionMode.RUN
    if not run and user_config["completion"]["copilot"]:
        LOGGER.debug("GitHub Copilot is enabled")
        await session_mgr.start_lsp_server()
    yield

#+END_SRC
*** @contextlib.asynccontextmanager: Function watcher
#+BEGIN_SRC python
@contextlib.asynccontextmanager
async def watcher(app: Starlette) -> AsyncIterator[None]:
    state = AppState.from_app(app)
    if state.watch:
        session_mgr = state.session_manager
        session_mgr.start_file_watcher()
    yield

#+END_SRC
*** @contextlib.asynccontextmanager: Function open_browser
#+BEGIN_SRC python
@contextlib.asynccontextmanager
async def open_browser(app: Starlette) -> AsyncIterator[None]:
    state = AppState.from_app(app)
    if not state.headless:
        url = _startup_url(state)
        user_config = state.config_manager.get_config()
        browser = user_config["server"]["browser"]
        # Wait 20ms for the server to start and then open the browser, but this
        # function must complete
        asyncio.get_running_loop().call_later(
            0.02, open_url_in_browser, browser, url
        )
    yield

#+END_SRC
*** @contextlib.asynccontextmanager: Function logging
#+BEGIN_SRC python
@contextlib.asynccontextmanager
async def logging(app: Starlette) -> AsyncIterator[None]:
    state = AppState.from_app(app)
    manager: SessionManager = state.session_manager
    file_router = manager.file_router

    # Startup message
    if not manager.quiet:
        file = file_router.maybe_get_single_file()
        print_startup(
            file.name if file else None,
            _startup_url(state),
            manager.mode == SessionMode.RUN,
            new=file_router.get_unique_file_key() == AppFileRouter.NEW_FILE,
        )

    yield

    # Shutdown message
    if not manager.quiet:
        print_shutdown()

#+END_SRC
*** @contextlib.asynccontextmanager: Function signal_handler
#+BEGIN_SRC python
@contextlib.asynccontextmanager
async def signal_handler(app: Starlette) -> AsyncIterator[None]:
    state = AppState.from_app(app)
    manager = state.session_manager

    # Interrupt handler
    def shutdown() -> None:
        manager.shutdown()
        if state.server:
            close_uvicorn(state.server)

    InterruptHandler(
        quiet=manager.quiet,
        shutdown=shutdown,
    ).register()
    yield

#+END_SRC
*** @contextlib.asynccontextmanager: Function etc
#+BEGIN_SRC python
@contextlib.asynccontextmanager
async def etc(app: Starlette) -> AsyncIterator[None]:
    del app
    # Mimetypes
    initialize_mimetypes()
    yield

#+END_SRC
*** Function _startup_url
#+BEGIN_SRC python
def _startup_url(state: AppStateBase) -> str:
    host = state.host
    port = state.port
    try:
        # pretty printing:
        # if the address maps to localhost, print "localhost" to stdout
        if (
            socket.getnameinfo((host, port), socket.NI_NOFQDN)[0]
            == "localhost"
        ):
            host = "localhost"
    except Exception:
        # aggressive try/except in case of platform-specific quirks;
        # nothing to handle, since the `try` logic is just for pretty
        # printing the host name
        ...

    url = f"http://{host}:{port}{state.base_url}"
    if port == 80:
        url = f"http://{host}{state.base_url}"
    elif port == 443:
        url = f"https://{host}{state.base_url}"

    if AuthToken.is_empty(state.session_manager.auth_token):
        return url
    return f"{url}?access_token={str(state.session_manager.auth_token)}"

#+END_SRC
** middleware
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.middleware
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/middleware.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import asyncio
from http.client import HTTPResponse, HTTPSConnection
from typing import (
    TYPE_CHECKING,
    Any,
    AsyncIterable,
    Callable,
    Optional,
    Union,
)
from urllib.parse import urljoin, urlparse

import starlette.status as status
from starlette.authentication import (
    AuthCredentials,
    AuthenticationBackend,
    BaseUser,
    SimpleUser,
)
from starlette.background import BackgroundTask
from starlette.middleware.base import (
    BaseHTTPMiddleware,
    DispatchFunction,
    RequestResponseEndpoint,
)
from starlette.requests import Request
from starlette.responses import JSONResponse, Response, StreamingResponse
from starlette.websockets import WebSocket, WebSocketState
from websockets import ConnectionClosed, connect

from marimo import _loggers
from marimo._config.settings import GLOBAL_SETTINGS
from marimo._dependencies.dependencies import DependencyManager
from marimo._server.api.auth import validate_auth
from marimo._server.api.deps import AppState, AppStateBase
from marimo._server.model import SessionMode
from marimo._tracer import server_tracer

#+END_SRC
*** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import HTTPConnection
    from starlette.types import ASGIApp, Receive, Scope, Send

LOGGER = _loggers.marimo_logger()

#+END_SRC
*** Class AuthBackend
#+BEGIN_SRC python
class AuthBackend(AuthenticationBackend):
    def __init__(self, should_authenticate: bool = True) -> None:
        self.should_authenticate = should_authenticate

    async def authenticate(
        self, conn: HTTPConnection
    ) -> Optional[tuple["AuthCredentials", "BaseUser"]]:
        mode = AppStateBase(conn.app.state).session_manager.mode

        # We may not need to authenticate. This can be disabled
        # because the user is running in a trusted environment
        # or authentication is handled by a layer above us
        if self.should_authenticate:
            # Valid auth header
            # This validates we have a valid Cookie (already authenticated)
            # or validates our auth (and sets the cookie)
            valid = validate_auth(conn)
            if not valid:
                return None

        # User's get Read access in Run mode
        if mode == SessionMode.RUN:
            return AuthCredentials(["read"]), SimpleUser("user")

        # User's get Read and Edit access in Edit mode
        if mode == SessionMode.EDIT:
            return AuthCredentials(["read", "edit"]), SimpleUser("user")

        raise ValueError(f"Invalid session mode: {mode}")

#+END_SRC
*** Class SkewProtectionMiddleware
#+BEGIN_SRC python
class SkewProtectionMiddleware:
    def __init__(self, app: ASGIApp) -> None:
        self.app = app

    async def __call__(
        self, scope: Scope, receive: Receive, send: Send
    ) -> None:
        if scope["type"] != "http":
            return await self.app(scope, receive, send)

        request = Request(scope)
        state = AppState.from_app(request.app)

        # If not POST request, then skip
        if request.method != "POST":
            return await self.app(scope, receive, send)
        # If is a form, then skip
        if request.headers.get("Content-Type", "").startswith(
            "application/x-www-form-urlencoded"
        ):
            return await self.app(scope, receive, send)
        # If ws, skip
        if request.url.path.startswith("/ws") or request.url.path.endswith(
            "/ws"
        ):
            return await self.app(scope, receive, send)

        expected = state.session_manager.skew_protection_token
        server_token = request.headers.get("Marimo-Server-Token")
        if server_token != str(expected):
            response = JSONResponse(
                {"error": "Invalid server token"},
                status_code=status.HTTP_401_UNAUTHORIZED,
            )
            return await response(scope, receive, send)

        # Passed
        return await self.app(scope, receive, send)

#+END_SRC
*** Class OpenTelemetryMiddleware
#+BEGIN_SRC python
class OpenTelemetryMiddleware(BaseHTTPMiddleware):
    def __init__(
        self, app: ASGIApp, dispatch: DispatchFunction | None = None
    ) -> None:
        super().__init__(app, dispatch)

        if not GLOBAL_SETTINGS.TRACING:
            return

        DependencyManager.opentelemetry.require("for tracing.")

        # Import once and store for later
        from opentelemetry import trace
        from opentelemetry.trace.status import Status, StatusCode

        self.trace = trace
        self.Status = Status
        self.StatusCode = StatusCode

    async def dispatch(
        self,
        request: Request,
        call_next: RequestResponseEndpoint,
    ) -> Response:
        if not GLOBAL_SETTINGS.TRACING:
            return await call_next(request)

        with server_tracer.start_as_current_span(
            f"{request.method} {request.url.path}",
            kind=self.trace.SpanKind.SERVER,
            attributes={
                "http.method": request.method,
                "http.target": request.url.path or "",
            },
        ) as span:
            try:
                response = await call_next(request)
                span.set_attribute("http.status_code", response.status_code)
                span.set_status(self.Status(self.StatusCode.OK))
            except Exception as e:
                span.set_status(self.Status(self.StatusCode.ERROR, str(e)))
                raise
            return response

#+END_SRC
*** Class _URLRequest
#+BEGIN_SRC python
class _URLRequest:
    def __init__(
        self, url: str, method: str, headers: dict[str, str], data: Any
    ):
        self.full_url = url
        self.method = method
        self.headers = headers
        self.data = data

#+END_SRC
*** Class _AsyncHTTPResponse
#+BEGIN_SRC python
class _AsyncHTTPResponse:
    def __init__(self, response: HTTPResponse):
        self.raw_response = response
        self.status_code = response.status
        self.headers = {k.lower(): v for k, v in response.getheaders()}

    async def aiter_raw(self) -> AsyncIterable[bytes]:
        try:
            while True:
                chunk = self.raw_response.read(8192)
                if not chunk:
                    break
                yield chunk
        except Exception:
            raise
        finally:
            await self.aclose()

    async def aclose(self) -> None:
        self.raw_response.close()

#+END_SRC
*** Class _AsyncHTTPClient
#+BEGIN_SRC python
class _AsyncHTTPClient:
    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip("/")
        parsed = urlparse(base_url)
        self.host = parsed.netloc
        self.is_https = parsed.scheme == "https"

    def build_request(
        self, method: str, url: Any, headers: dict[str, str], content: Any
    ) -> _URLRequest:
        # Combine base_url with path and query to form a full URL
        full_url = f"{self.base_url}{url.path}"
        if hasattr(url, "query") and url.query:
            full_url += f"?{url.query.decode('utf-8')}"

        headers = dict(headers)
        headers["host"] = self.host

        request = _URLRequest(
            full_url,  # Use the full URL here
            method=method,
            headers=headers,
            data=content,
        )

        request.method = method
        return request

    async def send(
        self, request: _URLRequest, stream: bool = False
    ) -> _AsyncHTTPResponse:
        del stream
        loop = asyncio.get_event_loop()

        async def collect_body() -> bytes:
            if hasattr(request, "data"):
                if request.data is None:
                    return b""
                if isinstance(request.data, AsyncIterable):
                    chunks: list[bytes] = []
                    try:
                        async for chunk in request.data:
                            if isinstance(chunk, str):
                                chunks.append(chunk.encode())
                            else:
                                chunks.append(chunk)
                        return b"".join(chunks)
                    except Exception:
                        raise
                if isinstance(request.data, str):
                    return request.data.encode()
                if isinstance(request.data, bytes):
                    return request.data
                if hasattr(request.data, "read"):
                    return request.data.read()  # type: ignore
                raise ValueError(
                    f"Unsupported request data type: {type(request.data)}"
                )
            return b""

        try:
            body = await collect_body()
        except Exception:
            raise

        def _send() -> HTTPResponse:
            from http.client import HTTPConnection

            parsed_url = urlparse(request.full_url)
            path_and_query = parsed_url.path
            if parsed_url.query:
                path_and_query += f"?{parsed_url.query}"

            conn_class = HTTPSConnection if self.is_https else HTTPConnection
            conn = conn_class(self.host)

            method = request.method if request.method is not None else "GET"

            try:
                conn.request(
                    method=method,
                    url=path_and_query,  # Only path and query
                    body=body,
                    headers=request.headers,
                )
                resp = conn.getresponse()
                return resp  # type: ignore[no-any-return]
            except Exception:
                raise

        response = await loop.run_in_executor(None, _send)
        return _AsyncHTTPResponse(response)

#+END_SRC
*** Class ProxyMiddleware
#+BEGIN_SRC python
class ProxyMiddleware:
    def __init__(
        self,
        app: ASGIApp,
        proxy_path: str,
        target_url: Union[str, Callable[[str], str]],
        path_rewrite: Callable[[str], str] | None = None,
    ) -> None:
        self.app = app
        self.path = proxy_path.rstrip("/")
        self.target_url = target_url
        self.path_rewrite = path_rewrite

    def _get_target_url(self, path: str) -> str:
        """Get target URL either from rewrite function or default MPL logic."""
        if callable(self.target_url):
            return self.target_url(path)

        return self.target_url

    async def __call__(
        self, scope: Scope, receive: Receive, send: Send
    ) -> None:
        if scope["type"] == "websocket":
            if not scope["path"].startswith(self.path):
                return await self.app(scope, receive, send)

            ws_target_url = self._get_target_url(scope["path"])
            ws_path = scope["path"]
            if self.path_rewrite:
                ws_path = self.path_rewrite(ws_path)
            ws_url = urljoin(ws_target_url, ws_path)
            if scope["scheme"] in ("http", "ws"):
                ws_url = ws_url.replace("http", "ws", 1)
            elif scope["scheme"] in ("https", "wss"):
                ws_url = ws_url.replace("https", "wss", 1)

            LOGGER.debug(f"Creating websocket proxy for {ws_url}")
            await self._proxy_websocket(scope, receive, send, ws_url)
            LOGGER.debug(f"Done with websocket proxy for {ws_url}")
            return

        if scope["type"] != "http":
            return await self.app(scope, receive, send)

        request = Request(scope, receive)
        if not scope["path"].startswith(self.path):
            await self.app(scope, receive, send)
            return

        target_base = self._get_target_url(request.url.path)
        # Remove proxy path prefix for proxied request
        target_path = request.url.path
        if self.path_rewrite:
            target_path = self.path_rewrite(target_path)
        target_query = request.url.query.encode("utf-8")

        # Create client if needed (for dynamic target URLs)
        client = _AsyncHTTPClient(base_url=target_base)

        # Construct the URL object with path and query
        url = type("URL", (), {"path": target_path, "query": target_query})()

        headers = {k.decode(): v.decode() for k, v in request.headers.raw}

        rp_req = client.build_request(
            request.method,
            url,
            headers=headers,
            content=request.stream(),
        )

        rp_resp = await client.send(rp_req, stream=True)
        response = StreamingResponse(
            rp_resp.aiter_raw(),
            status_code=rp_resp.status_code,
            headers=rp_resp.headers,
            background=BackgroundTask(rp_resp.aclose),
        )
        await response(scope, receive, send)

    async def _proxy_websocket(
        self, scope: Scope, receive: Receive, send: Send, ws_url: str
    ) -> None:
        websocket = WebSocket(scope, receive=receive, send=send)
        original_params = websocket.query_params
        if original_params:
            ws_url = f"{ws_url}?{'&'.join(f'{k}={v}' for k,v in original_params.items())}"
        await websocket.accept()

        async with connect(ws_url) as ws_client:

            async def client_to_upstream() -> None:
                try:
                    while True:
                        msg = await websocket.receive()
                        if msg["type"] == "websocket.disconnect":
                            # Cancel the other task when client disconnects
                            for task in relay_tasks:
                                if not task.done():
                                    task.cancel()
                            return

                        if "text" in msg:
                            await ws_client.send(msg["text"])
                        elif "bytes" in msg:
                            await ws_client.send(msg["bytes"])
                except ConnectionClosed:
                    return
                except Exception:
                    return

            async def upstream_to_client() -> None:
                try:
                    while True:
                        msg = await ws_client.recv()
                        if isinstance(msg, bytes):
                            await websocket.send_bytes(msg)
                        else:
                            await websocket.send_text(msg)
                except ConnectionClosed:
                    # Cancel the other task when connection closes
                    for task in relay_tasks:
                        if not task.done():
                            task.cancel()
                    return
                except Exception:
                    return

            # Run both relay loops concurrently
            relay_tasks = [
                asyncio.create_task(client_to_upstream()),
                asyncio.create_task(upstream_to_client()),
            ]

            try:
                await asyncio.gather(*relay_tasks)
            except asyncio.CancelledError:
                pass
            except Exception as e:
                raise e
            finally:
                for task in relay_tasks:
                    if not task.done():
                        task.cancel()
                if websocket.client_state != WebSocketState.DISCONNECTED:
                    await websocket.close()
                await ws_client.close()

#+END_SRC
** router
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.router
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/router.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING, List

from marimo._server.api.endpoints.ai import router as ai_router
from marimo._server.api.endpoints.assets import router as assets_router
from marimo._server.api.endpoints.config import router as config_router
from marimo._server.api.endpoints.datasources import (
    router as datasources_router,
)
from marimo._server.api.endpoints.documentation import (
    router as documentation_router,
)
from marimo._server.api.endpoints.editing import router as editing_router
from marimo._server.api.endpoints.execution import router as execution_router
from marimo._server.api.endpoints.export import router as export_router
from marimo._server.api.endpoints.file_explorer import (
    router as file_explorer_router,
)
from marimo._server.api.endpoints.files import router as files_router
from marimo._server.api.endpoints.health import router as health_router
from marimo._server.api.endpoints.home import router as home_router
from marimo._server.api.endpoints.login import router as login_router
from marimo._server.api.endpoints.packages import router as packages_router
from marimo._server.api.endpoints.terminal import router as terminal_router
from marimo._server.api.endpoints.ws import router as ws_router
from marimo._server.router import APIRouter

#+END_SRC
*** Function build_routes
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.routing import BaseRoute


# Define the app routes
def build_routes(base_url: str = "") -> List[BaseRoute]:
    app_router = APIRouter(prefix=base_url)
    app_router.include_router(
        execution_router, prefix="/api/kernel", name="execution"
    )
    app_router.include_router(
        config_router, prefix="/api/kernel", name="config"
    )
    app_router.include_router(
        editing_router, prefix="/api/kernel", name="editing"
    )
    app_router.include_router(files_router, prefix="/api/kernel", name="files")
    app_router.include_router(
        file_explorer_router, prefix="/api/files", name="file_explorer"
    )
    app_router.include_router(
        documentation_router, prefix="/api/documentation", name="documentation"
    )
    app_router.include_router(
        datasources_router, prefix="/api/datasources", name="datasources"
    )
    app_router.include_router(ai_router, prefix="/api/ai", name="ai")
    app_router.include_router(home_router, prefix="/api/home", name="home")
    app_router.include_router(login_router, prefix="/auth", name="auth")
    app_router.include_router(
        export_router, prefix="/api/export", name="export"
    )
    app_router.include_router(
        terminal_router, prefix="/terminal", name="terminal"
    )
    app_router.include_router(
        packages_router, prefix="/api/packages", name="terminal"
    )
    app_router.include_router(health_router, name="health")
    app_router.include_router(ws_router, name="ws")
    app_router.include_router(assets_router, name="assets")

    return app_router.routes

#+END_SRC
** status
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.status
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/status.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from enum import IntEnum
from typing import Optional

#+END_SRC
*** Class HTTPStatus
#+BEGIN_SRC python
class HTTPStatus(IntEnum):
    OK = 200
    NOT_MODIFIED = 304
    BAD_REQUEST = 400
    FORBIDDEN = 403
    REQUEST_TIMEOUT = 408
    NOT_FOUND = 404
    METHOD_NOT_ALLOWED = 405
    UNSUPPORTED_MEDIA_TYPE = 415
    PRECONDITION_REQUIRED = 428
    SERVER_ERROR = 500

#+END_SRC
*** Class HTTPException
#+BEGIN_SRC python
class HTTPException(Exception):
    def __init__(
        self,
        status_code: int,
        detail: Optional[str] = None,
    ) -> None:
        self.status_code = status_code
        self.detail = detail

#+END_SRC
*** Function is_client_error
#+BEGIN_SRC python
def is_client_error(status_code: int) -> bool:
    return 400 <= status_code < 500

#+END_SRC
** utils
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.utils
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/utils.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import os
import subprocess
import sys
import webbrowser
from shutil import which
from typing import TYPE_CHECKING, Optional, Type, TypeVar

from marimo._utils.parse_dataclass import parse_raw

#+END_SRC
*** Function require_header
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request


# TODO still needed?
def require_header(header: list[str] | None) -> str:
    """
    Require exactly one value in header and return it.
    """

    if header is None:
        raise ValueError("Expected exactly one value in header, got None")
    if len(header) != 1:
        raise ValueError(
            "Expected exactly one value in header, "
            f"got {len(header)} values: {header}"
        )
    return header[0]

#+END_SRC
*** Function parse_request
#+BEGIN_SRC python
async def parse_request(
    request: Request, cls: Type[T], allow_unknown_keys: bool = False
) -> T:
    """Parse the request body as a dataclass of type `cls`"""
    return parse_raw(
        await request.body(), cls=cls, allow_unknown_keys=allow_unknown_keys
    )

#+END_SRC
*** Function parse_title
#+BEGIN_SRC python
def parse_title(filepath: Optional[str]) -> str:
    """
    Create a title from a filename.
    """
    if filepath is None:
        return "marimo"

    # filename is used as title, except basename and suffix are
    # stripped and underscores are replaced with spaces
    return os.path.splitext(os.path.basename(filepath))[0].replace("_", " ")

#+END_SRC
*** Function open_url_in_browser
#+BEGIN_SRC python
def open_url_in_browser(browser: str, url: str) -> None:
    """
    Open a browser to the given URL.
    """
    if which("xdg-open") is not None and browser == "default":
        with open(os.devnull, "w") as devnull:
            if (
                sys.platform == "win32"
                or sys.platform == "cygwin"
                or sys.implementation.name == "graalpy"
            ):
                preexec_fn = None
            else:
                preexec_fn = os.setpgrp
            subprocess.Popen(
                ["xdg-open", url],
                # don't forward signals: ctrl-c shouldn't kill the browser
                # TODO: test/workaround on windows
                preexec_fn=preexec_fn,
                stdout=devnull,
                stderr=subprocess.STDOUT,
            )
    else:
        if browser == "default":
            webbrowser.open(url)
        else:
            webbrowser.get(browser).open(url)

#+END_SRC
*** Assignment T = TypeVar("T")
#+BEGIN_SRC python
T = TypeVar("T")

#+END_SRC
** endpoints
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints
:END:
*** ai
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.ai
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/ai.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING, Any, Generator, Optional, cast

from starlette.authentication import requires
from starlette.exceptions import HTTPException
from starlette.responses import StreamingResponse

from marimo import _loggers
from marimo._ai.convert import (
    convert_to_anthropic_messages,
    convert_to_google_messages,
    convert_to_openai_messages,
)
from marimo._ai.types import ChatMessage
from marimo._config.config import MarimoConfig
from marimo._server.ai.prompts import Prompter
from marimo._server.api.deps import AppState
from marimo._server.api.status import HTTPStatus
from marimo._server.api.utils import parse_request
from marimo._server.models.completion import (
    AiCompletionRequest,
    ChatRequest,
)
from marimo._server.router import APIRouter

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from anthropic import (  # type: ignore[import-not-found]
        Client,
        Stream as AnthropicStream,
    )
    from anthropic.types import (  # type: ignore[import-not-found]
        RawMessageStreamEvent,
    )
    from google.generativeai import (  # type: ignore[import-not-found]
        GenerativeModel,
    )
    from google.generativeai.types import (  # type: ignore[import-not-found]
        GenerateContentResponse,
    )
    from openai import (  # type: ignore[import-not-found]
        OpenAI,
        Stream as OpenAiStream,
    )
    from openai.types.chat import (  # type: ignore[import-not-found]
        ChatCompletionChunk,
    )
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
# Router for file ai
router = APIRouter()

#+END_SRC
**** Function get_openai_client
#+BEGIN_SRC python
def get_openai_client(config: MarimoConfig) -> "OpenAI":
    try:
        from openai import OpenAI  # type: ignore[import-not-found]
    except ImportError:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="OpenAI not installed. Add 'openai' using the package installer in the sidebar.",
        ) from None

    if "ai" not in config:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST, detail="OpenAI not configured"
        )
    if "open_ai" not in config["ai"]:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST, detail="OpenAI not configured"
        )
    if "api_key" not in config["ai"]["open_ai"]:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="OpenAI API key not configured",
        )

    key: str = config["ai"]["open_ai"]["api_key"]
    if not key:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="OpenAI API key not configured",
        )
    base_url: Optional[str] = (
        config.get("ai", {}).get("open_ai", {}).get("base_url", None)
    )
    if not base_url:
        base_url = None

    return OpenAI(
        default_headers={"api-key": key},
        api_key=key,
        base_url=base_url,
    )

#+END_SRC
**** Function get_anthropic_client
#+BEGIN_SRC python
def get_anthropic_client(config: MarimoConfig) -> "Client":
    try:
        from anthropic import Client  # type: ignore[import-not-found]
    except ImportError:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="Anthropic not installed. Add 'anthropic' using the package installer in the sidebar.",
        ) from None

    if "ai" not in config:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="Anthropic not configured",
        )
    if "anthropic" not in config["ai"]:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="Anthropic not configured",
        )
    if "api_key" not in config["ai"]["anthropic"]:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="Anthropic API key not configured",
        )

    key: str = config["ai"]["anthropic"]["api_key"]

    if not key:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="Anthropic API key not configured",
        )

    return Client(api_key=key)

#+END_SRC
**** Function get_model
#+BEGIN_SRC python
def get_model(config: MarimoConfig) -> str:
    model: str = (
        config.get("ai", {}).get("open_ai", {}).get("model", "gpt-4-turbo")
    )
    if not model:
        model = "gpt-4-turbo"
    return model

#+END_SRC
**** Function get_content
#+BEGIN_SRC python
def get_content(
    response: RawMessageStreamEvent
    | ChatCompletionChunk
    | GenerateContentResponse,
) -> str | None:
    if hasattr(response, "choices"):
        return response.choices[0].delta.content  # type: ignore

    if hasattr(response, "text"):
        return response.text  # type: ignore

    from anthropic.types import (  # type: ignore[import-not-found]
        RawContentBlockDeltaEvent,
        TextDelta,
    )

    if isinstance(response, RawContentBlockDeltaEvent):
        if isinstance(response.delta, TextDelta):
            return response.delta.text  # type: ignore

    return None

#+END_SRC
**** Function make_stream_response
#+BEGIN_SRC python
def make_stream_response(
    response: OpenAiStream[ChatCompletionChunk]
    | AnthropicStream[RawMessageStreamEvent]
    | GenerateContentResponse,
) -> Generator[str, None, None]:
    original_content = ""
    buffer = ""
    in_code_fence = False

    for chunk in response:
        content = get_content(chunk)
        if not content:
            continue

        buffer += content
        original_content += content
        first_newline = buffer.find("\n")

        # Open code-fence, with no newline
        # wait for the next newline
        if (
            buffer.startswith("```")
            and first_newline == -1
            and not in_code_fence
        ):
            continue

        if (
            buffer.startswith("```")
            and first_newline > 0
            and not in_code_fence
        ):
            # And also ends with ```
            if buffer.endswith("```"):
                yield buffer[first_newline + 1 : -3]
                buffer = ""
                in_code_fence = False
                continue

            yield buffer[first_newline + 1 :]
            buffer = ""
            in_code_fence = True
            continue

        if buffer.endswith("```") and in_code_fence:
            yield buffer[:-3]
            buffer = ""
            in_code_fence = False
            continue

        yield buffer
        buffer = ""

    LOGGER.debug(f"Completion content: {original_content}")

#+END_SRC
**** Function as_stream_response
#+BEGIN_SRC python
def as_stream_response(
    response: OpenAiStream[ChatCompletionChunk]
    | AnthropicStream[RawMessageStreamEvent]
    | GenerateContentResponse,
) -> Generator[str, None, None]:
    original_content = ""
    buffer = ""

    for chunk in response:
        content = get_content(chunk)
        if not content:
            continue

        buffer += content
        original_content += content

        yield buffer
        buffer = ""

    LOGGER.debug(f"Completion content: {original_content}")

#+END_SRC
**** Function get_google_client
#+BEGIN_SRC python
def get_google_client(config: MarimoConfig, model: str) -> "GenerativeModel":
    try:
        import google.generativeai as genai  # type: ignore[import-not-found]
    except ImportError:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail=(
                "Google AI not installed. "
                "Add 'google-generativeai' using the package installer in the sidebar."
            ),
        ) from None

    if "ai" not in config or "google" not in config["ai"]:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="Google AI not configured",
        )
    if "api_key" not in config["ai"]["google"]:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="Google AI API key not configured",
        )

    key: str = config["ai"]["google"]["api_key"]

    if not key:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="Google AI API key not configured",
        )

    genai.configure(api_key=key)
    return genai.GenerativeModel(
        model_name=model,
        generation_config=genai.GenerationConfig(
            max_output_tokens=1000,
            temperature=0,
        ),
    )

#+END_SRC
**** @router.post("/completion") requires("edit"): Function ai_completion
#+BEGIN_SRC python
@router.post("/completion")
@requires("edit")
async def ai_completion(
    *,
    request: Request,
) -> StreamingResponse:
    """
    requestBody:
        description: The prompt to get AI completion for
        required: true
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/AiCompletionRequest"
    responses:
        200:
            description: Get AI completion for a prompt
            content:
                application/json:
                    schema:
                        type: object
                        additionalProperties: true
    """
    app_state = AppState(request)
    app_state.require_current_session()
    config = app_state.config_manager.get_config(hide_secrets=False)
    body = await parse_request(request, cls=AiCompletionRequest)
    custom_rules = config.get("ai", {}).get("rules", None)

    prompter = Prompter(code=body.code, context=body.context)
    system_prompt = Prompter.get_system_prompt(
        language=body.language, custom_rules=custom_rules
    )
    prompt = prompter.get_prompt(
        user_prompt=body.prompt, include_other_code=body.include_other_code
    )

    model = get_model(config)

    # If the model starts with claude, use anthropic
    if model.startswith("claude"):
        anthropic_client = get_anthropic_client(config)
        anthropic_response = anthropic_client.messages.create(
            model=model,
            max_tokens=1000,
            messages=[
                {
                    "role": "user",
                    "content": prompt,
                }
            ],
            system=system_prompt,
            stream=True,
            temperature=0,
        )

        return StreamingResponse(
            content=make_stream_response(anthropic_response),
            media_type="application/json",
        )

    # If the model starts with google/gemini, use Google AI
    if model.startswith("google") or model.startswith("gemini"):
        google_client = get_google_client(config, model)
        google_response = google_client.generate_content(
            contents=prompt,
            stream=True,
        )

        return StreamingResponse(
            content=make_stream_response(google_response),
            media_type="application/json",
        )

    openai_client = get_openai_client(config)
    response = openai_client.chat.completions.create(
        model=get_model(config),
        messages=[
            {
                "role": "system",
                "content": system_prompt,
            },
            {
                "role": "user",
                "content": prompt,
            },
        ],
        temperature=0,
        stream=True,
        timeout=15,
    )

    return StreamingResponse(
        content=make_stream_response(response),
        media_type="application/json",
    )

#+END_SRC
**** @router.post("/chat") requires("edit"): Function ai_chat
#+BEGIN_SRC python
@router.post("/chat")
@requires("edit")
async def ai_chat(
    *,
    request: Request,
) -> StreamingResponse:
    """
    Chat endpoint that handles ongoing conversations
    """
    app_state = AppState(request)
    app_state.require_current_session()
    config = app_state.config_manager.get_config(hide_secrets=False)
    body = await parse_request(request, cls=ChatRequest)

    # Get the model from request or fallback to config
    model = body.model or get_model(config)
    messages = body.messages

    # Get the system prompt
    system_prompt = Prompter.get_chat_system_prompt(
        custom_rules=config.get("ai", {}).get("rules", None),
        variables=body.variables,
        context=body.context,
        include_other_code=body.include_other_code,
    )

    # Handle different model providers
    if model.startswith("claude"):
        anthropic_client = get_anthropic_client(config)
        response = anthropic_client.messages.create(
            model=model,
            max_tokens=1000,
            messages=cast(Any, convert_to_anthropic_messages(messages)),
            system=system_prompt,
            stream=True,
            temperature=0,
        )

        return StreamingResponse(
            content=as_stream_response(response),
            media_type="application/json",
        )

    if model.startswith("google") or model.startswith("gemini"):
        google_client = get_google_client(config, model)
        response = google_client.generate_content(
            contents=convert_to_google_messages(
                [ChatMessage(role="system", content=system_prompt)] + messages
            ),
            stream=True,
        )

        return StreamingResponse(
            content=as_stream_response(response),
            media_type="application/json",
        )

    # Default to OpenAI
    openai_client = get_openai_client(config)
    response = openai_client.chat.completions.create(
        model=model,
        messages=cast(
            Any,
            convert_to_openai_messages(
                [ChatMessage(role="system", content=system_prompt)] + messages
            ),
        ),
        temperature=0,
        stream=True,
        timeout=15,
    )

    return StreamingResponse(
        content=as_stream_response(response),
        media_type="application/json",
    )

#+END_SRC
*** assets
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.assets
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/assets.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import mimetypes
import os
import re
from typing import TYPE_CHECKING

from starlette.authentication import requires
from starlette.exceptions import HTTPException
from starlette.responses import FileResponse, HTMLResponse, Response
from starlette.staticfiles import StaticFiles

from marimo import _loggers
from marimo._config.manager import UserConfigManager
from marimo._runtime.virtual_file import EMPTY_VIRTUAL_FILE, read_virtual_file
from marimo._server.api.deps import AppState
from marimo._server.router import APIRouter
from marimo._server.templates.templates import (
    home_page_template,
    notebook_page_template,
)
from marimo._utils.paths import import_files

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
# Router for serving static assets
router = APIRouter()

#+END_SRC
**** Assignment root = os.path.realpath(str(import_files("marimo").joinpath("_static")))
#+BEGIN_SRC python
# Root directory for static assets
root = os.path.realpath(str(import_files("marimo").joinpath("_static")))

#+END_SRC
**** Assignment config = UserConfigManager().get_config().get("server", {})
#+BEGIN_SRC python
config = UserConfigManager().get_config().get("server", {})

#+END_SRC
**** Call router.mount
#+BEGIN_SRC python
router.mount(
    "/assets",
    app=StaticFiles(
        directory=os.path.join(root, "assets"),
        follow_symlink=config.get("follow_symlink", False),
    ),
    name="assets",
)

#+END_SRC
**** Assignment FILE_QUERY_PARAM_KEY = "file"
#+BEGIN_SRC python
FILE_QUERY_PARAM_KEY = "file"

#+END_SRC
**** @router.get("/") requires("read", redirect="auth:login_page"): Function index
#+BEGIN_SRC python
@router.get("/")
@requires("read", redirect="auth:login_page")
async def index(request: Request) -> HTMLResponse:
    app_state = AppState(request)
    user_config = app_state.config_manager.get_config()
    index_html = os.path.join(root, "index.html")

    file_key = (
        app_state.query_params(FILE_QUERY_PARAM_KEY)
        or app_state.session_manager.file_router.get_unique_file_key()
    )

    with open(index_html, "r") as f:  # noqa: ASYNC101 ASYNC230
        html = f.read()

    if not file_key:
        # We don't know which file to use, so we need to render a homepage
        LOGGER.debug("No file key provided, serving homepage")
        html = home_page_template(
            html=html,
            base_url=app_state.base_url,
            user_config=user_config,
            server_token=app_state.skew_protection_token,
        )
    else:
        # We have a file key, so we can render the app with the file
        LOGGER.debug(f"File key provided: {file_key}")
        app_manager = app_state.session_manager.app_manager(file_key)
        app_config = app_manager.app.config

        html = notebook_page_template(
            html=html,
            base_url=app_state.base_url,
            user_config=user_config,
            server_token=app_state.skew_protection_token,
            app_config=app_config,
            filename=app_manager.filename,
            mode=app_state.mode,
        )

    return HTMLResponse(html)

#+END_SRC
**** Assignment STATIC_FILES
#+BEGIN_SRC python
STATIC_FILES = [
    r"(favicon\.ico)",
    r"(circle-check\.ico)",
    r"(circle-play\.ico)",
    r"(circle-x\.ico)",
    r"(manifest\.json)",
    r"(android-chrome-(192x192|512x512)\.png)",
    r"(apple-touch-icon\.png)",
    r"(logo\.png)",
]

#+END_SRC
**** @router.get("/@file/{filename_and_length:path}") requires("read"): Function virtual_file
#+BEGIN_SRC python
@router.get("/@file/{filename_and_length:path}")
@requires("read")
def virtual_file(
    request: Request,
) -> Response:
    """
    parameters:
        - in: path
          name: filename_and_length
          required: true
          schema:
            type: string
          description: The filename and byte length of the virtual file
    responses:
        200:
            description: Get a virtual file
            content:
                application/octet-stream:
                    schema:
                        type: string
        404:
            description: Invalid virtual file request
        404:
            description: Invalid byte length in virtual file request
    """
    filename_and_length = request.path_params["filename_and_length"]

    LOGGER.debug("Getting virtual file: %s", filename_and_length)
    if filename_and_length == EMPTY_VIRTUAL_FILE.filename:
        return Response(content=b"", media_type="application/octet-stream")
    if "-" not in filename_and_length:
        raise HTTPException(
            status_code=404,
            detail="Invalid virtual file request",
        )

    byte_length, filename = filename_and_length.split("-", 1)
    if not byte_length.isdigit():
        raise HTTPException(
            status_code=404,
            detail="Invalid byte length in virtual file request",
        )

    buffer_contents = read_virtual_file(filename, int(byte_length))
    mimetype, _ = mimetypes.guess_type(filename)
    return Response(
        content=buffer_contents,
        media_type=mimetype,
        headers={"Cache-Control": "max-age=86400"},
    )

#+END_SRC
**** @router.get("/{path:path}"): Function serve_static
#+BEGIN_SRC python
# Catch all for serving static files
@router.get("/{path:path}")
async def serve_static(request: Request) -> FileResponse:
    path = request.path_params["path"]
    if any(re.match(pattern, path) for pattern in STATIC_FILES):
        return FileResponse(os.path.join(root, path))

    raise HTTPException(status_code=404, detail="Not Found")

#+END_SRC
*** config
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.config
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/config.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING

from starlette.authentication import requires

from marimo import _loggers
from marimo._runtime.requests import SetUserConfigRequest
from marimo._server.api.deps import AppState
from marimo._server.api.utils import parse_request
from marimo._server.models.models import (
    BaseResponse,
    SaveUserConfigurationRequest,
    SuccessResponse,
)
from marimo._server.router import APIRouter

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
# Router for config endpoints
router = APIRouter()

#+END_SRC
**** @router.post("/save_user_config") requires("edit"): Function save_user_config
#+BEGIN_SRC python
@router.post("/save_user_config")
@requires("edit")
async def save_user_config(
    *,
    request: Request,
) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/SaveUserConfigurationRequest"
    responses:
        200:
            description: Update the user config on disk and in the kernel. Only allowed in edit mode.
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """  # noqa: E501
    app_state = AppState(request)
    # Allow unknown keys to handle backward/forward compatibility
    body = await parse_request(
        request, cls=SaveUserConfigurationRequest, allow_unknown_keys=True
    )
    config = app_state.config_manager.save_config(body.config)

    # Update the server's view of the config
    if config["completion"]["copilot"]:
        LOGGER.debug("Starting copilot server")
        await app_state.session_manager.start_lsp_server()

    # Update the kernel's view of the config
    # Session could be None if the user is on the home page
    session = app_state.get_current_session()
    if session is not None:
        session.put_control_request(SetUserConfigRequest(body.config))
    return SuccessResponse()

#+END_SRC
*** datasources
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.datasources
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/datasources.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING

from starlette.authentication import requires

from marimo import _loggers
from marimo._runtime.requests import PreviewDatasetColumnRequest
from marimo._server.api.deps import AppState
from marimo._server.api.utils import parse_request
from marimo._server.models.models import BaseResponse, SuccessResponse
from marimo._server.router import APIRouter

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
# Router for data source endpoints
router = APIRouter()

#+END_SRC
**** @router.post("/preview_column") requires("edit"): Function preview_column
#+BEGIN_SRC python
@router.post("/preview_column")
@requires("edit")
async def preview_column(
    request: Request,
) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/PreviewDatasetColumnRequest"
    responses:
        200:
            description: Preview a column in a dataset
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    app_state = AppState(request)
    body = await parse_request(request, PreviewDatasetColumnRequest)
    app_state.require_current_session().put_control_request(body)
    return SuccessResponse()

#+END_SRC
*** documentation
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.documentation
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/documentation.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING

from marimo import _loggers
from marimo._server.router import APIRouter
from marimo._snippets.snippets import Snippets, read_snippets

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
# Router for documentation
router = APIRouter()

#+END_SRC
**** Assignment _SNIPPETS: list[Snippets] = []
#+BEGIN_SRC python
_SNIPPETS: list[Snippets] = []

#+END_SRC
**** @router.get("/snippets"): Function load_snippets
#+BEGIN_SRC python
@router.get("/snippets")
async def load_snippets(
    request: Request,
) -> Snippets:
    """
    responses:
        200:
            description: Load the snippets for the documentation page
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/Snippets"
    """
    del request
    if not _SNIPPETS:
        _SNIPPETS.append(await read_snippets())
    return _SNIPPETS[0]

#+END_SRC
*** editing
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.editing
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/editing.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING

from starlette.authentication import requires

from marimo._messaging.ops import UpdateCellIdsRequest
from marimo._runtime.requests import (
    CodeCompletionRequest,
    DeleteCellRequest,
    InstallMissingPackagesRequest,
    SetCellConfigRequest,
)
from marimo._server.api.deps import AppState
from marimo._server.api.utils import parse_request
from marimo._server.models.models import (
    BaseResponse,
    FormatRequest,
    FormatResponse,
    StdinRequest,
    SuccessResponse,
)
from marimo._server.router import APIRouter
from marimo._utils.formatter import DefaultFormatter

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

# Router for editing endpoints
router = APIRouter()

#+END_SRC
**** @router.post("/code_autocomplete") requires("edit"): Function code_complete
#+BEGIN_SRC python
@router.post("/code_autocomplete")
@requires("edit")
async def code_complete(request: Request) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/CodeCompletionRequest"
    responses:
        200:
            description: Complete a code fragment
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=CodeCompletionRequest)
    app_state.require_current_session().put_completion_request(body)

    return SuccessResponse()

#+END_SRC
**** @router.post("/delete") requires("edit"): Function delete_cell
#+BEGIN_SRC python
@router.post("/delete")
@requires("edit")
async def delete_cell(request: Request) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/DeleteCellRequest"
    responses:
        200:
            description: Delete a cell
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=DeleteCellRequest)
    app_state.require_current_session().put_control_request(body)

    return SuccessResponse()

#+END_SRC
**** @router.post("/sync/cell_ids") requires("edit"): Function sync_cell_ids
#+BEGIN_SRC python
@router.post("/sync/cell_ids")
@requires("edit")
async def sync_cell_ids(request: Request) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/UpdateCellIdsRequest"
    responses:
        200:
            description: Sync cell ids
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=UpdateCellIdsRequest)
    app_state.require_current_session().write_operation(body)
    return SuccessResponse()

#+END_SRC
**** @router.post("/format") requires("edit"): Function format_cell
#+BEGIN_SRC python
@router.post("/format")
@requires("edit")
async def format_cell(request: Request) -> FormatResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/FormatRequest"
    responses:
        200:
            description: Format code
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/FormatResponse"
    """
    body = await parse_request(request, cls=FormatRequest)
    formatter = DefaultFormatter(line_length=body.line_length)

    return FormatResponse(codes=formatter.format(body.codes))

#+END_SRC
**** @router.post("/set_cell_config") requires("edit"): Function set_cell_config
#+BEGIN_SRC python
@router.post("/set_cell_config")
@requires("edit")
async def set_cell_config(request: Request) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/SetCellConfigRequest"
    responses:
        200:
            description: Set the configuration of a cell
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=SetCellConfigRequest)
    app_state.require_current_session().put_control_request(body)

    return SuccessResponse()

#+END_SRC
**** @router.post("/stdin") requires("edit"): Function stdin
#+BEGIN_SRC python
@router.post("/stdin")
@requires("edit")
async def stdin(request: Request) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/StdinRequest"
    responses:
        200:
            description: Send input to the stdin stream
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=StdinRequest)
    app_state.require_current_session().put_input(body.text)

    return SuccessResponse()

#+END_SRC
**** @router.post("/install_missing_packages") requires("edit"): Function install_missing_packages
#+BEGIN_SRC python
@router.post("/install_missing_packages")
@requires("edit")
async def install_missing_packages(request: Request) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/InstallMissingPackagesRequest"
    responses:
        200:
            description: Install missing packages
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=InstallMissingPackagesRequest)
    app_state.require_current_session().put_control_request(body)
    return SuccessResponse()

#+END_SRC
*** execution
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.execution
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/execution.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import asyncio
from typing import TYPE_CHECKING, Optional
from uuid import uuid4

from starlette.authentication import requires
from starlette.responses import JSONResponse

from marimo import _loggers
from marimo._messaging.ops import Alert
from marimo._runtime.requests import (
    FunctionCallRequest,
    SetUIElementValueRequest,
)
from marimo._server.api.deps import AppState
from marimo._server.api.endpoints.ws import FILE_QUERY_PARAM_KEY
from marimo._server.api.utils import parse_request
from marimo._server.file_router import MarimoFileKey
from marimo._server.models.models import (
    BaseResponse,
    InstantiateRequest,
    RunRequest,
    RunScratchpadRequest,
    SuccessResponse,
    UpdateComponentValuesRequest,
)
from marimo._server.router import APIRouter
from marimo._server.uvicorn_utils import close_uvicorn

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
# Router for execution endpoints
router = APIRouter()

#+END_SRC
**** @router.post("/set_ui_element_value"): Function set_ui_element_values
#+BEGIN_SRC python
@router.post("/set_ui_element_value")
async def set_ui_element_values(
    *,
    request: Request,
) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/UpdateComponentValuesRequest"
    responses:
        200:
            description: Set UI element values
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=UpdateComponentValuesRequest)
    app_state.require_current_session().put_control_request(
        SetUIElementValueRequest(
            object_ids=body.object_ids, values=body.values, token=str(uuid4())
        )
    )

    return SuccessResponse()

#+END_SRC
**** @router.post("/instantiate"): Function instantiate
#+BEGIN_SRC python
@router.post("/instantiate")
async def instantiate(
    *,
    request: Request,
) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/InstantiateRequest"
    responses:
        200:
            description: Instantiate a component
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=InstantiateRequest)
    app_state.require_current_session().instantiate(body)

    return SuccessResponse()

#+END_SRC
**** @router.post("/function_call"): Function function_call
#+BEGIN_SRC python
@router.post("/function_call")
async def function_call(
    *,
    request: Request,
) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/FunctionCallRequest"
    responses:
        200:
            description: Invoke an RPC
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=FunctionCallRequest)
    app_state.require_current_session().put_control_request(body)

    return SuccessResponse()

#+END_SRC
**** @router.post("/interrupt") requires("edit"): Function interrupt
#+BEGIN_SRC python
@router.post("/interrupt")
@requires("edit")
async def interrupt(
    *,
    request: Request,
) -> BaseResponse:
    """
    responses:
        200:
            description: Interrupt the kernel's execution
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    app_state = AppState(request)
    app_state.require_current_session().try_interrupt()

    return SuccessResponse()

#+END_SRC
**** @router.post("/run") requires("edit"): Function run_cell
#+BEGIN_SRC python
@router.post("/run")
@requires("edit")
async def run_cell(
    *,
    request: Request,
) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/RunRequest"
    responses:
        200:
            description: Run a cell. Updates cell code in the kernel if needed; registers new cells for unseen cell IDs. Only allowed in edit mode.
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """  # noqa: E501
    app_state = AppState(request)
    body = await parse_request(request, cls=RunRequest)
    app_state.require_current_session().put_control_request(
        body.as_execution_request()
    )

    return SuccessResponse()

#+END_SRC
**** @router.post("/scratchpad/run") requires("edit"): Function run_scratchpad
#+BEGIN_SRC python
@router.post("/scratchpad/run")
@requires("edit")
async def run_scratchpad(
    *,
    request: Request,
) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/RunScratchpadRequest"
    responses:
        200:
            description: Run the scratchpad
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """  # noqa: E501
    app_state = AppState(request)
    body = await parse_request(request, cls=RunScratchpadRequest)
    app_state.require_current_session().put_control_request(
        body.as_execution_request()
    )

    return SuccessResponse()

#+END_SRC
**** @router.post("/restart_session") requires("edit"): Function restart_session
#+BEGIN_SRC python
@router.post("/restart_session")
@requires("edit")
async def restart_session(
    *,
    request: Request,
) -> BaseResponse:
    """
    responses:
        200:
            description: Restart the current session without affecting other sessions.
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """  # noqa: E501
    app_state = AppState(request)
    # This just closes the session, and the frontend will
    # do a full reload, which will restart the session.
    session_id = app_state.require_current_session_id()
    app_state.session_manager.close_session(session_id)

    return SuccessResponse()

#+END_SRC
**** @router.post("/shutdown") requires("edit"): Function shutdown
#+BEGIN_SRC python
@router.post("/shutdown")
@requires("edit")
async def shutdown(
    *,
    request: Request,
) -> BaseResponse:
    """
    responses:
        200:
            description: Shutdown the kernel
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    LOGGER.debug("Received shutdown request")
    app_state = AppState(request)
    session_manager = app_state.session_manager
    file_router = session_manager.file_router

    def shutdown_server() -> None:
        app_state.session_manager.shutdown()
        close_uvicorn(app_state.server)

    # If we are only operating on a single file (new or explicit file),
    # and there are no other sessions (user may have opened another notebook
    # from the file explorer) then we should shutdown the whole server
    key = file_router.get_unique_file_key()
    if key and len(session_manager.sessions) <= 1:
        shutdown_server()
        return SuccessResponse()

    # Otherwise, get the session
    session_id = app_state.get_current_session_id()
    if not session_id:
        shutdown_server()
        return SuccessResponse()

    was_shutdown = session_manager.close_session(session_id)
    if not was_shutdown:
        shutdown_server()

    return SuccessResponse()

#+END_SRC
**** @router.post("/takeover") requires("edit"): Function takeover_endpoint
#+BEGIN_SRC python
@router.post("/takeover")
@requires("edit")
async def takeover_endpoint(
    *,
    request: Request,
) -> JSONResponse:
    """
    responses:
    200:
        description: Successfully closed existing sessions
        content:
            application/json:
                schema:
                    type: object
                    properties:
                        status:
                            type: string
    """
    app_state = AppState(request)

    file_key: Optional[MarimoFileKey] = (
        app_state.query_params(FILE_QUERY_PARAM_KEY)
        or app_state.session_manager.file_router.get_unique_file_key()
    )
    if file_key is None:
        LOGGER.error("No file key provided")
        return JSONResponse(
            status_code=400,
            content={"error": "Cannot take over session."},
        )

    # Find and close any existing sessions for this file
    existing_session = app_state.session_manager.get_session_by_file_key(
        file_key
    )
    if existing_session is not None:
        # Send a disconnect message to the client
        existing_session.write_operation(
            Alert(
                title="Session taken over",
                description="Another user has taken over this session.",
                variant="danger",
            )
        )
        # Wait 100ms to ensure the client has received the message
        await asyncio.sleep(0.1)
        existing_session.maybe_disconnect_consumer()
    else:
        LOGGER.warning("No existing session found for file key %s", file_key)

    return JSONResponse(status_code=200, content={"status": "ok"})

#+END_SRC
*** export
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.export
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/export.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING

from starlette.authentication import requires
from starlette.exceptions import HTTPException
from starlette.responses import HTMLResponse, PlainTextResponse

from marimo import _loggers
from marimo._server.api.deps import AppState
from marimo._server.api.status import HTTPStatus
from marimo._server.api.utils import parse_request
from marimo._server.export.exporter import AutoExporter, Exporter
from marimo._server.model import SessionMode
from marimo._server.models.export import (
    ExportAsHTMLRequest,
    ExportAsMarkdownRequest,
    ExportAsScriptRequest,
)
from marimo._server.models.models import SuccessResponse
from marimo._server.router import APIRouter

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
# Router for export endpoints
router = APIRouter()

#+END_SRC
**** @router.post("/html") requires("read"): Function export_as_html
#+BEGIN_SRC python
@router.post("/html")
@requires("read")
async def export_as_html(
    *,
    request: Request,
) -> HTMLResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/ExportAsHTMLRequest"
    responses:
        200:
            description: Export the notebook as HTML
            content:
                text/html:
                    schema:
                        type: string
        400:
            description: File must be saved before downloading
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=ExportAsHTMLRequest)
    session = app_state.require_current_session()

    # Only include the code and console if we are in edit mode
    if app_state.mode != SessionMode.EDIT:
        body.include_code = False

    html, filename = Exporter().export_as_html(
        file_manager=session.app_file_manager,
        session_view=session.session_view,
        display_config=app_state.session_manager.user_config_manager.get_config()[
            "display"
        ],
        request=body,
    )

    if body.download:
        headers = {"Content-Disposition": f"attachment; filename={filename}"}
    else:
        headers = {}

    # Download the HTML
    return HTMLResponse(
        content=html,
        headers=headers,
    )

#+END_SRC
**** @router.post("/auto_export/html") requires("edit"): Function auto_export_as_html
#+BEGIN_SRC python
@router.post("/auto_export/html")
@requires("edit")
async def auto_export_as_html(
    *,
    request: Request,
) -> SuccessResponse | PlainTextResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/ExportAsHTMLRequest"
    responses:
        200:
            description: Export the notebook as HTML
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
        400:
            description: File must be saved before downloading
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=ExportAsHTMLRequest)
    session = app_state.require_current_session()
    session_view = session.session_view

    # If we have already exported to HTML, don't do it again
    if session_view.has_auto_exported_html:
        LOGGER.debug("Already auto-exported to HTML")
        return PlainTextResponse(status_code=HTTPStatus.NOT_MODIFIED)

    # Reload the file manager to get the latest state
    session.app_file_manager.reload()

    html, _filename = Exporter().export_as_html(
        file_manager=session.app_file_manager,
        session_view=session_view,
        display_config=app_state.session_manager.user_config_manager.get_config()[
            "display"
        ],
        request=body,
    )

    # Save the HTML file to disk, at `.marimo/<filename>.html`
    AutoExporter().save_html(
        file_manager=session.app_file_manager,
        html=html,
    )
    session_view.mark_auto_export_html()

    return SuccessResponse()

#+END_SRC
**** @router.post("/script") requires("edit"): Function export_as_script
#+BEGIN_SRC python
@router.post("/script")
@requires("edit")
async def export_as_script(
    *,
    request: Request,
) -> PlainTextResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/ExportAsScriptRequest"
    responses:
        200:
            description: Export the notebook as a script
            content:
                text/plain:
                    schema:
                        type: string
        400:
            description: File must be saved before downloading
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=ExportAsScriptRequest)
    session = app_state.require_current_session()

    python, filename = Exporter().export_as_script(
        file_manager=session.app_file_manager,
    )

    if body.download:
        headers = {"Content-Disposition": f"attachment; filename={filename}"}
    else:
        headers = {}

    # Download the Script
    return PlainTextResponse(
        content=python,
        headers=headers,
    )

#+END_SRC
**** @router.post("/markdown") requires("edit"): Function export_as_markdown
#+BEGIN_SRC python
@router.post("/markdown")
@requires("edit")
async def export_as_markdown(
    *,
    request: Request,
) -> PlainTextResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/ExportAsMarkdownRequest"
    responses:
        200:
            description: Export the notebook as a markdown
            content:
                text/plain:
                    schema:
                        type: string
        400:
            description: File must be saved before downloading
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=ExportAsMarkdownRequest)
    app_file_manager = app_state.require_current_session().app_file_manager
    # Reload the file manager to get the latest state
    app_file_manager.reload()

    if not app_file_manager.path:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="File must be saved before downloading",
        )

    markdown, filename = Exporter().export_as_md(
        file_manager=app_file_manager,
    )

    if body.download:
        headers = {"Content-Disposition": f"attachment; filename={filename}"}
    else:
        headers = {}

    # Download the Markdown
    return PlainTextResponse(
        content=markdown,
        headers=headers,
    )

#+END_SRC
**** @router.post("/auto_export/markdown") requires("edit"): Function auto_export_as_markdown
#+BEGIN_SRC python
@router.post("/auto_export/markdown")
@requires("edit")
async def auto_export_as_markdown(
    *,
    request: Request,
) -> SuccessResponse | PlainTextResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/ExportAsMarkdownRequest"
    responses:
        200:
            description: Export the notebook as a markdown
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
        400:
            description: File must be saved before downloading
    """
    app_state = AppState(request)
    session = app_state.require_current_session()
    session_view = session.session_view

    # If we have already exported to Markdown, don't do it again
    if session_view.has_auto_exported_md:
        LOGGER.debug("Already auto-exported to Markdown")
        return PlainTextResponse(status_code=HTTPStatus.NOT_MODIFIED)

    # Reload the file manager to get the latest state
    session.app_file_manager.reload()

    markdown, _filename = Exporter().export_as_md(
        file_manager=session.app_file_manager,
    )

    # Save the Markdown file to disk, at `.marimo/<filename>.md`
    AutoExporter().save_md(
        file_manager=session.app_file_manager,
        markdown=markdown,
    )
    session_view.mark_auto_export_md()

    return SuccessResponse()

#+END_SRC
*** file_explorer
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.file_explorer
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/file_explorer.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import base64
from typing import TYPE_CHECKING

from starlette.authentication import requires

from marimo import _loggers
from marimo._server.api.utils import parse_request
from marimo._server.files.os_file_system import OSFileSystem
from marimo._server.models.files import (
    FileCreateRequest,
    FileCreateResponse,
    FileDeleteRequest,
    FileDeleteResponse,
    FileDetailsRequest,
    FileDetailsResponse,
    FileListRequest,
    FileListResponse,
    FileMoveRequest,
    FileMoveResponse,
    FileUpdateRequest,
    FileUpdateResponse,
)
from marimo._server.router import APIRouter

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
# Router for file system endpoints
router = APIRouter()

#+END_SRC
**** Assignment file_system = OSFileSystem()
#+BEGIN_SRC python
file_system = OSFileSystem()

#+END_SRC
**** @router.post("/list_files") requires("edit"): Function list_files
#+BEGIN_SRC python
@router.post("/list_files")
@requires("edit")
async def list_files(
    *,
    request: Request,
) -> FileListResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/FileListRequest"
    responses:
        200:
            description: List files and directories in a given path
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/FileListResponse"
    """
    body = await parse_request(request, cls=FileListRequest)
    root = body.path or file_system.get_root()
    files = file_system.list_files(root)
    return FileListResponse(files=files, root=root)

#+END_SRC
**** @router.post("/file_details") requires("edit"): Function file_details
#+BEGIN_SRC python
@router.post("/file_details")
@requires("edit")
async def file_details(
    *,
    request: Request,
) -> FileDetailsResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/FileDetailsRequest"
    responses:
        200:
            description: Get details of a specific file or directory
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/FileDetailsResponse"
    """
    body = await parse_request(request, cls=FileDetailsRequest)
    # This fails if the file isn't encoded as utf-8
    # TODO: support returning raw bytes
    return file_system.get_details(body.path)

#+END_SRC
**** @router.post("/create") requires("edit"): Function create_file_or_directory
#+BEGIN_SRC python
@router.post("/create")
@requires("edit")
async def create_file_or_directory(
    *,
    request: Request,
) -> FileCreateResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/FileCreateRequest"
    responses:
        200:
            description: Create a new file or directory
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/FileCreateResponse"
    """
    body = await parse_request(request, cls=FileCreateRequest)
    try:
        decoded_contents = (
            base64.b64decode(body.contents)
            if body.contents is not None
            else None
        )

        info = file_system.create_file_or_directory(
            body.path, body.type, body.name, decoded_contents
        )
        return FileCreateResponse(success=True, info=info)
    except Exception as e:
        LOGGER.error(f"Error creating file or directory: {e}")
        return FileCreateResponse(success=False, message=str(e))

#+END_SRC
**** @router.post("/delete") requires("edit"): Function delete_file_or_directory
#+BEGIN_SRC python
@router.post("/delete")
@requires("edit")
async def delete_file_or_directory(
    *,
    request: Request,
) -> FileDeleteResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/FileDeleteRequest"
    responses:
        200:
            description: Delete a file or directory
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/FileDeleteResponse"
    """
    body = await parse_request(request, cls=FileDeleteRequest)
    try:
        file_system.get_details(body.path)
        success = file_system.delete_file_or_directory(body.path)
        return FileDeleteResponse(success=success)
    except Exception as e:
        LOGGER.error(f"Error deleting file or directory: {e}")
        return FileDeleteResponse(success=False, message=str(e))

#+END_SRC
**** @router.post("/move") requires("edit"): Function move_file_or_directory
#+BEGIN_SRC python
@router.post("/move")
@requires("edit")
async def move_file_or_directory(
    *,
    request: Request,
) -> FileMoveResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/FileMoveRequest"
    responses:
        200:
            description: Move a file or directory
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/FileMoveResponse"
    """
    body = await parse_request(request, cls=FileMoveRequest)
    try:
        file_system.get_details(body.path)
        info = file_system.move_file_or_directory(body.path, body.new_path)
        return FileMoveResponse(success=True, info=info)
    except Exception as e:
        LOGGER.error(f"Error updating file or directory: {e}")
        return FileMoveResponse(success=False, message=str(e))

#+END_SRC
**** @router.post("/update") requires("edit"): Function update_file
#+BEGIN_SRC python
@router.post("/update")
@requires("edit")
async def update_file(
    *,
    request: Request,
) -> FileUpdateResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/FileUpdateRequest"
    responses:
        200:
            description: Update a file or directory
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/FileUpdateResponse"
    """
    body = await parse_request(request, cls=FileUpdateRequest)
    try:
        file_system.get_details(body.path)
        info = file_system.update_file(body.path, body.contents)
        return FileUpdateResponse(success=True, info=info)
    except Exception as e:
        LOGGER.error(f"Error updating file or directory: {e}")
        return FileUpdateResponse(success=False, message=str(e))

#+END_SRC
*** files
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.files
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/files.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import os
from typing import TYPE_CHECKING

from starlette.authentication import requires
from starlette.exceptions import HTTPException
from starlette.responses import PlainTextResponse

from marimo import _loggers
from marimo._ast import codegen
from marimo._server.api.deps import AppState
from marimo._server.api.status import HTTPStatus
from marimo._server.api.utils import parse_request
from marimo._server.models.models import (
    BaseResponse,
    CopyNotebookRequest,
    OpenFileRequest,
    ReadCodeResponse,
    RenameFileRequest,
    SaveAppConfigurationRequest,
    SaveNotebookRequest,
    SuccessResponse,
)
from marimo._server.router import APIRouter

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
# Router for file endpoints
router = APIRouter()

#+END_SRC
**** @router.post("/read_code") requires("edit"): Function read_code
#+BEGIN_SRC python
@router.post("/read_code")
@requires("edit")
async def read_code(
    *,
    request: Request,
) -> ReadCodeResponse:
    """
    responses:
        200:
            description: Read the code from the server
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/ReadCodeResponse"
        400:
            description: File must be saved before downloading
    """
    app_state = AppState(request)
    session = app_state.require_current_session()

    if not session.app_file_manager.path:
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail="File must be saved before downloading",
        )

    contents = session.app_file_manager.read_file()

    return ReadCodeResponse(contents=contents)

#+END_SRC
**** @router.post("/rename") requires("edit"): Function rename_file
#+BEGIN_SRC python
@router.post("/rename")
@requires("edit")
async def rename_file(
    *,
    request: Request,
) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/RenameFileRequest"
    responses:
        200:
            description: Rename the current app
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
    """
    body = await parse_request(request, cls=RenameFileRequest)
    app_state = AppState(request)
    session = app_state.require_current_session()
    prev_path = session.app_file_manager.path

    session.app_file_manager.rename(body.filename)
    new_path = session.app_file_manager.path

    if prev_path and new_path:
        app_state.session_manager.recents.rename(prev_path, new_path)
    elif new_path:
        app_state.session_manager.recents.touch(new_path)

    app_state.require_current_session().put_control_request(
        body.as_execution_request()
    )

    return SuccessResponse()

#+END_SRC
**** @router.post("/open") requires("edit"): Function open_file
#+BEGIN_SRC python
@router.post("/open")
@requires("edit")
async def open_file(
    *,
    request: Request,
) -> BaseResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/OpenFileRequest"
    responses:
        200:
            description: Open a file
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/SuccessResponse"
        400:
            description: File does not exist
    """
    body = await parse_request(request, cls=OpenFileRequest)

    # Validate file exists
    if not os.path.exists(body.path):
        raise HTTPException(
            status_code=HTTPStatus.BAD_REQUEST,
            detail=f"File {body.path} does not exist",
        )

    # Get relative path
    filename = os.path.relpath(body.path)

    try:
        app = codegen.get_app(filename)
        if app is None:
            raise HTTPException(
                status_code=HTTPStatus.BAD_REQUEST,
                detail=f"File {filename} is not a valid marimo app",
            )
    except Exception as e:
        raise HTTPException(
            status_code=HTTPStatus.SERVER_ERROR,
            detail=f"Failed to read file: {str(e)}",
        ) from e

    return SuccessResponse()

#+END_SRC
**** @router.post("/save") requires("edit"): Function save
#+BEGIN_SRC python
@router.post("/save")
@requires("edit")
async def save(
    *,
    request: Request,
) -> PlainTextResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/SaveNotebookRequest"
    responses:
        200:
            description: Save the current app
            content:
                text/plain:
                    schema:
                        type: string
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=SaveNotebookRequest)
    session = app_state.require_current_session()
    contents = session.app_file_manager.save(body)

    return PlainTextResponse(content=contents)

#+END_SRC
**** @router.post("/copy") requires("edit"): Function copy
#+BEGIN_SRC python
@router.post("/copy")
@requires("edit")
async def copy(
    *,
    request: Request,
) -> PlainTextResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/CopyNotebookRequest"
    responses:
        200:
            description: Copy notebook
            content:
                text/plain:
                    schema:
                        type: string
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=CopyNotebookRequest)
    session = app_state.require_current_session()
    contents = session.app_file_manager.copy(body)

    return PlainTextResponse(content=contents)

#+END_SRC
**** @router.post("/save_app_config") requires("edit"): Function save_app_config
#+BEGIN_SRC python
@router.post("/save_app_config")
@requires("edit")
async def save_app_config(
    *,
    request: Request,
) -> PlainTextResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/SaveAppConfigurationRequest"
    responses:
        200:
            description: Save the app configuration
            content:
                text/plain:
                    schema:
                        type: string
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=SaveAppConfigurationRequest)
    session = app_state.require_current_session()
    contents = session.app_file_manager.save_app_config(body.config)

    return PlainTextResponse(content=contents)

#+END_SRC
*** health
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.health
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/health.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from multiprocessing import Process
from typing import TYPE_CHECKING, Optional

from starlette.authentication import requires
from starlette.responses import JSONResponse, PlainTextResponse

from marimo import __version__, _loggers
from marimo._server.api.deps import AppState
from marimo._server.router import APIRouter
from marimo._utils.health import (
    get_node_version,
    get_python_version,
    get_required_modules_list,
)

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
# Router for health/status endpoints
router = APIRouter()

#+END_SRC
**** Function health_check
#+BEGIN_SRC python
async def health_check(request: Request) -> JSONResponse:
    del request  # Unused
    return JSONResponse({"status": "healthy"})

#+END_SRC
**** Call router.add_route("/health", health_check, methods=["GET"])
#+BEGIN_SRC python
# Multiple health endpoints to make it easier on the consumer
router.add_route("/health", health_check, methods=["GET"])

#+END_SRC
**** Call router.add_route("/healthz", health_check, methods=["GET"])
#+BEGIN_SRC python
router.add_route("/healthz", health_check, methods=["GET"])

#+END_SRC
**** @router.get("/api/status") requires("edit"): Function status
#+BEGIN_SRC python
@router.get("/api/status")
@requires("edit")
async def status(request: Request) -> JSONResponse:
    """
    responses:
        200:
            description: Get the status of the application
            content:
                application/json:
                    schema:
                        type: object
                        properties:
                            status:
                                type: string
                            filenames:
                                type: array
                                items:
                                    type: string
                            mode:
                                type: string
                            sessions:
                                type: integer
                            version:
                                type: string
                            requirements:
                                type: array
                                items:
                                    type: string
                            node_version:
                                type: string
                            lsp_running:
                                type: boolean
    """
    app_state = AppState(request)
    files = [
        session.app_file_manager.filename or "__new__"
        for session in app_state.session_manager.sessions.values()
    ]
    return JSONResponse(
        {
            "status": "healthy",
            "filenames": files,
            "mode": app_state.mode,
            "sessions": len(app_state.session_manager.sessions),
            "version": __version__,
            "python_version": get_python_version(),
            "requirements": get_required_modules_list(),
            "node_version": get_node_version(),
            "lsp_running": app_state.session_manager.lsp_server.is_running(),
        }
    )

#+END_SRC
**** @router.get("/api/version"): Function version
#+BEGIN_SRC python
@router.get("/api/version")
async def version(request: Request) -> PlainTextResponse:
    """
    responses:
        200:
            description: Get the version of the application
            content:
                text/plain:
                    schema:
                        type: string
    """
    del request  # Unused
    return PlainTextResponse(__version__)

#+END_SRC
**** @router.get("/api/usage") requires("edit"): Function usage
#+BEGIN_SRC python
@router.get("/api/usage")
@requires("edit")
async def usage(request: Request) -> JSONResponse:
    """
    responses:
        200:
            description: Get the current memory and CPU usage of the application
            content:
                application/json:
                    schema:
                        type: object
                        properties:
                            memory:
                                type: object
                                properties:
                                    total:
                                        type: integer
                                    available:
                                        type: integer
                                    percent:
                                        type: number
                                    used:
                                        type: integer
                                    free:
                                        type: integer
                                required:
                                    - total
                                    - available
                                    - percent
                                    - used
                                    - free
                            server:
                                type: object
                                properties:
                                    memory:
                                        type: integer
                                required:
                                    - memory
                            kernel:
                                type: object
                                properties:
                                    memory:
                                        type: integer
                            cpu:
                                type: object
                                properties:
                                    percent:
                                        type: number
                                required:
                                    - percent
                        required:
                            - memory
                            - cpu

    """  # noqa: E501
    import psutil

    memory = psutil.virtual_memory()
    # interval=None is nonblocking; first value is meaningless but after
    # that it's useful.
    cpu = psutil.cpu_percent(interval=None)

    # Server memory (and children)
    main_process = psutil.Process()
    server_memory = main_process.memory_info().rss
    children = main_process.children(recursive=True)
    for child in children:
        try:
            server_memory += child.memory_info().rss
        except psutil.NoSuchProcess:
            pass

    # Kernel memory
    kernel_memory: Optional[int] = None
    session = AppState(request).get_current_session()
    if session and isinstance(session.kernel_manager.kernel_task, Process):
        kernel_process = psutil.Process(session.kernel_manager.kernel_task.pid)
        kernel_memory = kernel_process.memory_info().rss
        kernel_children = kernel_process.children(recursive=True)
        for child in kernel_children:
            try:
                kernel_memory += child.memory_info().rss
            except psutil.NoSuchProcess:
                pass

    return JSONResponse(
        {
            # computer memory
            "memory": {
                "total": memory.total,
                "available": memory.available,
                "percent": memory.percent,
                "used": memory.used,
                "free": memory.free,
            },
            # marimo server
            "server": {
                "memory": server_memory,
            },
            # marimo kernel (for the given session)
            "kernel": {
                "memory": kernel_memory,
            },
            "cpu": {
                "percent": cpu,
            },
        }
    )

#+END_SRC
*** home
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.home
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/home.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import os
import tempfile
from typing import TYPE_CHECKING, List

from starlette.authentication import requires
from starlette.responses import JSONResponse

from marimo import _loggers
from marimo._server.api.deps import AppState
from marimo._server.api.utils import parse_request
from marimo._server.file_router import LazyListOfFilesAppFileRouter
from marimo._server.model import ConnectionState
from marimo._server.models.home import (
    MarimoFile,
    OpenTutorialRequest,
    RecentFilesResponse,
    RunningNotebooksResponse,
    ShutdownSessionRequest,
    WorkspaceFilesRequest,
    WorkspaceFilesResponse,
)
from marimo._server.router import APIRouter
from marimo._tutorials import create_temp_tutorial_file
from marimo._utils.paths import pretty_path

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
# Router for home endpoints
router = APIRouter()

#+END_SRC
**** @router.post("/recent_files") requires("edit"): Function read_code
#+BEGIN_SRC python
@router.post("/recent_files")
@requires("edit")
async def read_code(
    *,
    request: Request,
) -> RecentFilesResponse:
    """
    responses:
        200:
            description: Get the recent files
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/RecentFilesResponse"
    """
    app_state = AppState(request)
    files = app_state.session_manager.recents.get_recents()
    return RecentFilesResponse(files=files)

#+END_SRC
**** @router.post("/workspace_files") requires("edit"): Function workspace_files
#+BEGIN_SRC python
@router.post("/workspace_files")
@requires("edit")
async def workspace_files(
    *,
    request: Request,
) -> WorkspaceFilesResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/WorkspaceFilesRequest"
    responses:
        200:
            description: Get the files in the workspace
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/WorkspaceFilesResponse"
    """
    body = await parse_request(request, cls=WorkspaceFilesRequest)
    session_manager = AppState(request).session_manager

    # Maybe enable markdown
    root = ""
    if isinstance(session_manager.file_router, LazyListOfFilesAppFileRouter):
        # Mark stale in case new files are added
        session_manager.file_router.mark_stale()
        # Toggle markdown
        session_manager.file_router = (
            session_manager.file_router.toggle_markdown(body.include_markdown)
        )
        root = session_manager.file_router.directory

    files = session_manager.file_router.files
    return WorkspaceFilesResponse(files=files, root=root)

#+END_SRC
**** Function _get_active_sessions
#+BEGIN_SRC python
def _get_active_sessions(app_state: AppState) -> List[MarimoFile]:
    files: List[MarimoFile] = []
    for session_id, session in app_state.session_manager.sessions.items():
        state = session.connection_state()
        if state == ConnectionState.OPEN or state == ConnectionState.ORPHANED:
            filename = session.app_file_manager.filename
            basename = os.path.basename(filename) if filename else None
            files.append(
                MarimoFile(
                    name=(basename or "new notebook"),
                    path=(pretty_path(filename) if filename else session_id),
                    last_modified=0,
                    session_id=session_id,
                    initialization_id=session.initialization_id,
                )
            )
    # These are better in reverse
    return files[::-1]

#+END_SRC
**** @router.post("/running_notebooks") requires("edit"): Function running_notebooks
#+BEGIN_SRC python
@router.post("/running_notebooks")
@requires("edit")
async def running_notebooks(
    *,
    request: Request,
) -> RunningNotebooksResponse:
    """
    responses:
        200:
            description: Get the running files
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/RunningNotebooksResponse"
    """
    app_state = AppState(request)
    return RunningNotebooksResponse(files=_get_active_sessions(app_state))

#+END_SRC
**** @router.post("/shutdown_session") requires("edit"): Function shutdown_session
#+BEGIN_SRC python
@router.post("/shutdown_session")
@requires("edit")
async def shutdown_session(
    *,
    request: Request,
) -> RunningNotebooksResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/ShutdownSessionRequest"
    responses:
        200:
            description: Shutdown the current session
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/RunningNotebooksResponse"
    """
    app_state = AppState(request)
    body = await parse_request(request, cls=ShutdownSessionRequest)
    app_state.session_manager.close_session(body.session_id)
    return RunningNotebooksResponse(files=_get_active_sessions(app_state))

#+END_SRC
**** @router.post("/tutorial/open") requires("edit"): Function tutorial
#+BEGIN_SRC python
@router.post("/tutorial/open")
@requires("edit")
async def tutorial(
    *,
    request: Request,
) -> MarimoFile | JSONResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/OpenTutorialRequest"
    responses:
        200:
            description: Open a new tutorial
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/MarimoFile"
    """
    # Create a new tutorial file and return the filepath
    try:
        body = await parse_request(request, cls=OpenTutorialRequest)
    except ValueError:
        return JSONResponse({"detail": "Tutorial not found"}, status_code=400)
    temp_dir = tempfile.TemporaryDirectory()
    path = create_temp_tutorial_file(body.tutorial_id, temp_dir)

    import atexit

    atexit.register(temp_dir.cleanup)

    return MarimoFile(
        name=os.path.basename(path.absolute_name),
        path=path.absolute_name,
    )

#+END_SRC
*** login
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.login
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/login.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING
from urllib.parse import parse_qsl, urlparse

from starlette.responses import (
    HTMLResponse,
    RedirectResponse,
    Response,
)

from marimo._server.api.auth import validate_auth
from marimo._server.router import APIRouter

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

router = APIRouter()

#+END_SRC
**** Assignment LOGIN_PAGE
#+BEGIN_SRC python
# Minimal login page
LOGIN_PAGE = """
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>marimo</title>
</head>
<body style="
    background-color: #f4f4f9;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;">
  <form method="POST" action="/auth/login" style="
    padding: 20px;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    width: 300px;
    text-align: center;">
    <div style="margin-bottom: 20px;">
      <label for="password" style="
        display: block;
        margin-bottom: 5px;
        font-size: 16px;
        color: #333;">Access Token / Password</label>
      <input id="password" name="password" type="password" style="
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;">
    </div>
    <button type="submit" style="
        background-color: #1C7362;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        width: 100%;
        font-size: 16px;">Login</button>
    <p style="color: red;">{error}</p>
  </form>
</body>
</html>
"""

#+END_SRC
**** @router.post("/login"): Function login_submit
#+BEGIN_SRC python
@router.post("/login")
async def login_submit(request: Request) -> Response:
    """
    tags: [auth]
    summary: Submit login form
    requestBody:
        content:
            application/x-www-form-urlencoded:
                schema:
                    type: object
                    properties:
                        password:
                            type: string
                            description: Access token or password
    responses:
        302:
            description: Redirect to the next URL
            headers:
                Location:
                    schema:
                        type: string
        200:
            description: Login page
            content:
                text/html:
                    schema:
                        type: string
    """
    error = ""
    redirect_url = request.query_params.get("next", "/")

    # Ensure redirect URL uses same protocol as request
    parsed = urlparse(redirect_url)
    if parsed.scheme:
        redirect_url = parsed._replace(scheme=request.url.scheme).geturl()

    if request.user.is_authenticated:
        return RedirectResponse("/", 302)

    if request.method == "POST":
        body = (await request.body()).decode()
        data = dict(parse_qsl(body))
        password = data.get("password", "")
        if not password:
            error = "Password is required"
        else:
            success = validate_auth(request, data)
            if success:
                return RedirectResponse(redirect_url, 302)
            else:
                error = "Invalid password"

    return HTMLResponse(content=LOGIN_PAGE.format(error=error))

#+END_SRC
**** @router.get("/login", name="login_page"): Function login_page
#+BEGIN_SRC python
@router.get("/login", name="login_page")
async def login_page(request: Request) -> HTMLResponse:
    del request
    return HTMLResponse(content=LOGIN_PAGE.format(error=""))

#+END_SRC
*** packages
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.packages
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/packages.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING, Optional

from starlette.authentication import requires

from marimo._config.settings import GLOBAL_SETTINGS
from marimo._runtime.packages.package_manager import PackageManager
from marimo._runtime.packages.package_managers import create_package_manager
from marimo._runtime.packages.utils import split_packages
from marimo._server.api.deps import AppState
from marimo._server.api.utils import parse_request
from marimo._server.models.packages import (
    AddPackageRequest,
    ListPackagesResponse,
    PackageOperationResponse,
    RemovePackageRequest,
)
from marimo._server.router import APIRouter

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from starlette.requests import Request

# Router for packages endpoints
router = APIRouter()

#+END_SRC
**** @router.post("/add") requires("edit"): Function add_package
#+BEGIN_SRC python
@router.post("/add")
@requires("edit")
async def add_package(request: Request) -> PackageOperationResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/AddPackageRequest"
    responses:
        200:
            description: Install package
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/PackageOperationResponse"
    """
    body = await parse_request(request, cls=AddPackageRequest)

    package_manager = _get_package_manager(request)
    if not package_manager.is_manager_installed():
        package_manager.alert_not_installed()
        return PackageOperationResponse.of_failure(
            f"{package_manager.name} is not available. "
            f"Check out the docs for installation instructions: {package_manager.docs_url}"  # noqa: E501
        )

    success = await package_manager.install(body.package, version=None)

    # Update the script metadata
    filename = _get_filename(request)
    if filename is not None and GLOBAL_SETTINGS.MANAGE_SCRIPT_METADATA:
        package_manager.update_notebook_script_metadata(
            filepath=filename,
            packages_to_add=split_packages(body.package),
        )

    if success:
        return PackageOperationResponse.of_success()

    return PackageOperationResponse.of_failure(
        f"Failed to install {body.package}. See terminal for error logs."
    )

#+END_SRC
**** @router.post("/remove") requires("edit"): Function remove_package
#+BEGIN_SRC python
@router.post("/remove")
@requires("edit")
async def remove_package(request: Request) -> PackageOperationResponse:
    """
    requestBody:
        content:
            application/json:
                schema:
                    $ref: "#/components/schemas/RemovePackageRequest"
    responses:
        200:
            description: Uninstall package
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/PackageOperationResponse"
    """
    body = await parse_request(request, cls=RemovePackageRequest)

    package_manager = _get_package_manager(request)
    if not package_manager.is_manager_installed():
        package_manager.alert_not_installed()
        return PackageOperationResponse.of_failure(
            f"{package_manager.name} is not available. "
            f"Check out the docs for installation instructions: {package_manager.docs_url}"  # noqa: E501
        )

    success = await package_manager.uninstall(body.package)

    # Update the script metadata
    filename = _get_filename(request)
    if filename is not None and GLOBAL_SETTINGS.MANAGE_SCRIPT_METADATA:
        package_manager.update_notebook_script_metadata(
            filepath=filename,
            packages_to_remove=split_packages(body.package),
        )

    if success:
        return PackageOperationResponse.of_success()

    return PackageOperationResponse.of_failure(
        f"Failed to uninstall {body.package}. See terminal for error logs."
    )

#+END_SRC
**** @router.get("/list") requires("edit"): Function list_packages
#+BEGIN_SRC python
@router.get("/list")
@requires("edit")
async def list_packages(request: Request) -> ListPackagesResponse:
    """
    responses:
        200:
            description: List installed packages
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/ListPackagesResponse"
    """
    package_manager = _get_package_manager(request)
    if not package_manager.is_manager_installed():
        package_manager.alert_not_installed()
        return ListPackagesResponse(packages=[])

    packages = package_manager.list_packages()

    return ListPackagesResponse(packages=packages)

#+END_SRC
**** Function _get_package_manager
#+BEGIN_SRC python
def _get_package_manager(request: Request) -> PackageManager:
    config_manager = AppState(request).config_manager
    return create_package_manager(
        config_manager.get_config()["package_management"]["manager"]
    )

#+END_SRC
**** Function _get_filename
#+BEGIN_SRC python
def _get_filename(request: Request) -> Optional[str]:
    session = AppState(request).get_current_session()
    if session is None:
        return None
    return session.app_file_manager.filename

#+END_SRC
*** terminal
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.terminal
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/terminal.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import asyncio
import os
import select
import signal
import subprocess

from starlette.websockets import WebSocket, WebSocketDisconnect, WebSocketState

from marimo import _loggers
from marimo._server.api.deps import AppState
from marimo._server.model import SessionMode
from marimo._server.router import APIRouter

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
router = APIRouter()

#+END_SRC
**** Function _read_from_pty
#+BEGIN_SRC python
async def _read_from_pty(master: int, websocket: WebSocket) -> None:
    loop = asyncio.get_running_loop()
    try:
        # TODO: loop.add_reader would likely be better in this case
        # but when the program is closed from the terminal, it hangs
        # for an additional second before the process is killed.
        with os.fdopen(master, "rb", buffering=0) as master_file:
            while True:
                try:
                    r, _, _ = await loop.run_in_executor(
                        None, select.select, [master_file], [], [], 0.1
                    )
                    if not r:
                        await asyncio.sleep(0.1)  # Prevent busy-waiting
                        continue
                    data = os.read(master, 1024)
                    if not data:
                        break
                    await websocket.send_text(data.decode())
                except (asyncio.CancelledError, WebSocketDisconnect):
                    break
    except OSError as e:
        if e.errno == 9:  # Bad file descriptor
            LOGGER.debug("File descriptor closed, stopping read loop")
            return
        raise  # Re-raise other OSErrors

#+END_SRC
**** Function _write_to_pty
#+BEGIN_SRC python
async def _write_to_pty(master: int, websocket: WebSocket) -> None:
    try:
        buffer = ""
        with os.fdopen(master, "wb", buffering=0) as master_file:
            while True:
                try:
                    data = await websocket.receive_text()
                    LOGGER.debug("Received: %s", data)

                    buffer += data
                    if data in ["\r", "\n"]:  # Check for line ending
                        if buffer.strip().lower() == "exit":
                            LOGGER.debug(
                                "Exit command received, closing connection"
                            )
                            # End the connection
                            return
                        buffer = ""  # Reset buffer after processing a command

                    master_file.write(data.encode())
                    master_file.flush()
                except (asyncio.CancelledError, WebSocketDisconnect):
                    break
    except OSError as e:
        if e.errno == 9:  # Bad file descriptor
            LOGGER.debug("File descriptor closed, stopping write loop")
            return
        raise

#+END_SRC
**** @router.websocket("/ws"): Function websocket_endpoint
#+BEGIN_SRC python
@router.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket) -> None:
    app_state = AppState(websocket)
    if app_state.mode != SessionMode.EDIT:
        await websocket.close()
        return

    await websocket.accept()
    LOGGER.debug("Terminal websocket accepted")
    import pty

    child_pid, fd = pty.fork()
    if child_pid == 0:
        default_shell = os.environ.get("SHELL", "/bin/bash")
        subprocess.run([default_shell], shell=True)  ## noqa: ASYNC221
        return

    reader_task = asyncio.create_task(_read_from_pty(fd, websocket))
    writer_task = asyncio.create_task(_write_to_pty(fd, websocket))

    try:
        _done, pending = await asyncio.wait(
            [reader_task, writer_task], return_when=asyncio.FIRST_COMPLETED
        )
        for task in pending:
            task.cancel()
    except WebSocketDisconnect:
        pass
    except Exception as e:
        LOGGER.exception(e)
    finally:
        try:
            if websocket.application_state != WebSocketState.DISCONNECTED:
                await websocket.close()
        except RuntimeError:
            pass
        if reader_task and not reader_task.done():
            reader_task.cancel()
        if writer_task and not writer_task.done():
            writer_task.cancel()
        os.kill(child_pid, signal.SIGKILL)
        os.waitpid(child_pid, 0)  ## noqa: ASYNC222
    LOGGER.debug("Terminal websocket closed")

#+END_SRC
*** ws
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.api.endpoints.ws
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/api/endpoints/ws.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import asyncio
import json
from enum import IntEnum
from typing import Any, Callable, Optional

from starlette.websockets import WebSocket, WebSocketDisconnect, WebSocketState

from marimo import _loggers
from marimo._ast.cell import CellConfig, CellId_t
from marimo._cli.upgrade import check_for_updates
from marimo._config.settings import GLOBAL_SETTINGS
from marimo._messaging.ops import (
    Alert,
    Banner,
    CompletionResult,
    FocusCell,
    KernelCapabilities,
    KernelReady,
    MessageOperation,
    Reconnected,
    UpdateCellCodes,
    UpdateCellIdsRequest,
    serialize,
)
from marimo._messaging.types import KernelMessage, NoopStream
from marimo._plugins.core.json_encoder import WebComponentEncoder
from marimo._plugins.core.web_component import JSONType
from marimo._runtime.params import QueryParams
from marimo._server.api.deps import AppState
from marimo._server.file_router import MarimoFileKey
from marimo._server.ids import ConsumerId
from marimo._server.model import (
    ConnectionState,
    SessionConsumer,
    SessionMode,
)
from marimo._server.router import APIRouter
from marimo._server.sessions import Session, SessionManager

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment router = APIRouter()
#+BEGIN_SRC python
router = APIRouter()

#+END_SRC
**** Assignment SESSION_QUERY_PARAM_KEY = "session_id"
#+BEGIN_SRC python
SESSION_QUERY_PARAM_KEY = "session_id"

#+END_SRC
**** Assignment FILE_QUERY_PARAM_KEY = "file"
#+BEGIN_SRC python
FILE_QUERY_PARAM_KEY = "file"

#+END_SRC
**** Assignment KIOSK_QUERY_PARAM_KEY = "kiosk"
#+BEGIN_SRC python
KIOSK_QUERY_PARAM_KEY = "kiosk"

#+END_SRC
**** Class WebSocketCodes
#+BEGIN_SRC python
class WebSocketCodes(IntEnum):
    ALREADY_CONNECTED = 1003
    NORMAL_CLOSE = 1000
    FORBIDDEN = 1008

#+END_SRC
**** @router.websocket("/ws"): Function websocket_endpoint
#+BEGIN_SRC python
@router.websocket("/ws")
async def websocket_endpoint(
    websocket: WebSocket,
) -> None:
    """
    responses:
        200:
            description: Websocket endpoint
    """
    app_state = AppState(websocket)
    session_id = app_state.query_params(SESSION_QUERY_PARAM_KEY)
    if session_id is None:
        await websocket.close(
            WebSocketCodes.NORMAL_CLOSE, "MARIMO_NO_SESSION_ID"
        )
        return

    file_key: Optional[MarimoFileKey] = (
        app_state.query_params(FILE_QUERY_PARAM_KEY)
        or app_state.session_manager.file_router.get_unique_file_key()
    )

    if file_key is None:
        await websocket.close(
            WebSocketCodes.NORMAL_CLOSE, "MARIMO_NO_FILE_KEY"
        )
        return

    kiosk = app_state.query_params(KIOSK_QUERY_PARAM_KEY) == "true"

    await WebsocketHandler(
        websocket=websocket,
        manager=app_state.session_manager,
        session_id=session_id,
        mode=app_state.mode,
        file_key=file_key,
        kiosk=kiosk,
    ).start()

#+END_SRC
**** Assignment KIOSK_ONLY_OPERATIONS
#+BEGIN_SRC python
KIOSK_ONLY_OPERATIONS = {
    FocusCell.name,
    UpdateCellCodes.name,
    UpdateCellIdsRequest.name,
}

#+END_SRC
**** Assignment KIOSK_EXCLUDED_OPERATIONS = {     CompletionResult.name, }
#+BEGIN_SRC python
KIOSK_EXCLUDED_OPERATIONS = {
    CompletionResult.name,
}

#+END_SRC
**** Class WebsocketHandler
#+BEGIN_SRC python
class WebsocketHandler(SessionConsumer):
    """WebSocket that sessions use to send messages to frontends.

    Each new socket gets a unique session. At most one session can exist when
    in edit mode.
    """

    def __init__(
        self,
        websocket: WebSocket,
        manager: SessionManager,
        session_id: str,
        mode: SessionMode,
        file_key: MarimoFileKey,
        kiosk: bool,
    ):
        self.websocket = websocket
        self.manager = manager
        self.session_id = session_id
        self.file_key = file_key
        self.mode = mode
        self.status: ConnectionState
        self.kiosk = kiosk
        self.cancel_close_handle: Optional[asyncio.TimerHandle] = None
        self.heartbeat_task: Optional[asyncio.Task[None]] = None
        # Messages from the kernel are put in this queue
        # to be sent to the frontend
        self.message_queue: asyncio.Queue[KernelMessage]

        super().__init__(consumer_id=ConsumerId(session_id))

    def _write_kernel_ready(
        self,
        session: Session,
        resumed: bool,
        ui_values: dict[str, JSONType],
        last_executed_code: dict[CellId_t, str],
        last_execution_time: dict[CellId_t, float],
        kiosk: bool,
    ) -> None:
        """Communicates to the client that the kernel is ready.

        Sends cell code and other metadata to client.
        """
        mgr = self.manager
        file_manager = session.app_file_manager
        app = file_manager.app

        codes: tuple[str, ...]
        names: tuple[str, ...]
        configs: tuple[CellConfig, ...]

        if mgr.should_send_code_to_frontend():
            codes, names, configs, cell_ids = tuple(
                zip(
                    *tuple(
                        (
                            cell_data.code,
                            cell_data.name,
                            cell_data.config,
                            cell_data.cell_id,
                        )
                        for cell_data in app.cell_manager.cell_data()
                    )
                )
            )
        else:
            codes, names, configs, cell_ids = tuple(
                zip(
                    *tuple(
                        # Don't send code to frontend in run mode
                        ("", "", cell_data.config, cell_data.cell_id)
                        for cell_data in app.cell_manager.cell_data()
                    )
                )
            )

            last_executed_code = {}
            last_execution_time = {}

        self.message_queue.put_nowait(
            (
                KernelReady.name,
                serialize(
                    KernelReady(
                        codes=codes,
                        names=names,
                        configs=configs,
                        layout=file_manager.read_layout_config(),
                        cell_ids=cell_ids,
                        resumed=resumed,
                        ui_values=ui_values,
                        last_executed_code=last_executed_code,
                        last_execution_time=last_execution_time,
                        app_config=app.config,
                        kiosk=kiosk,
                        capabilities=KernelCapabilities(),
                    )
                ),
            )
        )

    def _reconnect_session(self, session: "Session", replay: bool) -> None:
        """Reconnect to an existing session (kernel).

        A websocket can be closed when a user's computer goes to sleep,
        spurious network issues, etc.
        """
        # Cancel previous close handle
        if self.cancel_close_handle is not None:
            self.cancel_close_handle.cancel()

        self.status = ConnectionState.OPEN
        session.connect_consumer(self, main=True)

        # Write reconnected message
        self.write_operation(Reconnected())

        # If not replaying, just send a toast
        if not replay:
            self.write_operation(
                Alert(
                    title="Reconnected",
                    description="You have reconnected to an existing session.",
                )
            )
            return

        operations = session.get_current_state().operations
        # Replay the current session view
        LOGGER.debug(
            f"Replaying {len(operations)} operations to the consumer",
        )

        self._write_kernel_ready(
            session=session,
            resumed=True,
            ui_values=session.get_current_state().ui_values,
            last_executed_code=session.get_current_state().last_executed_code,
            last_execution_time=session.get_current_state().last_execution_time,
            kiosk=self.kiosk,
        )
        self.write_operation(
            Banner(
                title="Reconnected",
                description="You have reconnected to an existing session.",
                action="restart",
            )
        )

        for op in operations:
            LOGGER.debug("Replaying operation %s", serialize(op))
            self.write_operation(op)

    def _connect_kiosk(self, session: Session) -> None:
        """Connect to a kiosk session.

        A kiosk session is a write-ish session that is connected to a
        frontend. It can set UI elements and interact with the sidebar,
        but cannot change or execute code. This is not a permission limitation,
        but rather we don't have full multi-player support yet.

        Kiosk mode is useful when the user is using an editor (VSCode or VIM)
        that does not easily support our reactive frontend or our panels.
        The user uses VSCode or VIM to write code, and the
        marimo kiosk/frontend to visualize the output.
        """

        self.status = ConnectionState.OPEN
        session.connect_consumer(self, main=False)

        operations = session.get_current_state().operations
        # Replay the current session view
        LOGGER.debug(
            f"Replaying {len(operations)} operations to the kiosk consumer",
        )

        self._write_kernel_ready(
            session=session,
            resumed=True,
            ui_values=session.get_current_state().ui_values,
            last_executed_code=session.get_current_state().last_executed_code,
            last_execution_time=session.get_current_state().last_execution_time,
            kiosk=True,
        )

        for op in operations:
            LOGGER.debug("Replaying operation %s", serialize(op))
            self.write_operation(op)

    def _on_disconnect(
        self,
        e: Exception,
        cleanup_fn: Callable[[], Any],
    ) -> None:
        LOGGER.debug(
            "Websocket disconnected for session %s with exception %s, type %s",
            self.session_id,
            str(e),
            type(e),
        )

        # Change the status
        self.status = ConnectionState.CLOSED
        # Disconnect the consumer
        session = self.manager.get_session(self.session_id)
        if session:
            session.disconnect_consumer(self)

        if self.manager.mode == SessionMode.RUN:
            # When the websocket is closed, we wait TTL_SECONDS before
            # closing the session. This is to prevent the session from
            # being closed if the during an intermittent network issue.
            def _close() -> None:
                if self.status != ConnectionState.OPEN:
                    LOGGER.debug(
                        "Closing session %s (TTL EXPIRED)",
                        self.session_id,
                    )
                    # wait until TTL is expired before calling the cleanup
                    # function
                    cleanup_fn()
                    self.manager.close_session(self.session_id)

            session = self.manager.get_session(self.session_id)
            cancellation_handle = asyncio.get_event_loop().call_later(
                Session.TTL_SECONDS, _close
            )
            if session is not None:
                self.cancel_close_handle = cancellation_handle
        else:
            cleanup_fn()

    async def start(self) -> None:
        # Accept the websocket connection
        await self.websocket.accept()
        # Create a new queue for this session
        self.message_queue = asyncio.Queue()

        session_id = self.session_id
        mgr = self.manager
        LOGGER.debug(
            "Websocket open request for session with id %s", session_id
        )
        LOGGER.debug("Existing sessions: %s", mgr.sessions)

        # Only one frontend can be connected at a time in edit mode.
        if (
            mgr.mode == SessionMode.EDIT
            and mgr.any_clients_connected(self.file_key)
            and not self.kiosk
        ):
            LOGGER.debug(
                "Refusing connection; a frontend is already connected."
            )
            if self.websocket.application_state is WebSocketState.CONNECTED:
                await self.websocket.close(
                    WebSocketCodes.ALREADY_CONNECTED,
                    "MARIMO_ALREADY_CONNECTED",
                )
            return

        def get_session() -> Session:
            # 1. If we are in kiosk mode, connect to the existing session
            if self.kiosk:
                if self.mode is not SessionMode.EDIT:
                    LOGGER.debug("Kiosk mode is only supported in edit mode")
                    raise WebSocketDisconnect(
                        WebSocketCodes.FORBIDDEN, "MARIMO_KIOSK_NOT_ALLOWED"
                    )
                kiosk_session = mgr.get_session(session_id)
                if kiosk_session is None:
                    LOGGER.debug(
                        "Kiosk session not found for session id %s",
                        session_id,
                    )
                    kiosk_session = mgr.get_session_by_file_key(self.file_key)
                if kiosk_session is None:
                    LOGGER.debug(
                        "Kiosk session not found for file key %s",
                        self.file_key,
                    )
                    raise WebSocketDisconnect(
                        WebSocketCodes.NORMAL_CLOSE, "MARIMO_NO_SESSION"
                    )
                self.status = ConnectionState.OPEN
                LOGGER.debug("Connecting to kiosk session")
                self._connect_kiosk(kiosk_session)
                return kiosk_session

            # 2. Handle reconnection

            # The session already exists, but it was disconnected.
            # This can happen in local development when the client
            # goes to sleep and wakes later. Just replace the session's
            # socket, but keep its kernel
            existing_session = mgr.get_session(session_id)
            if existing_session is not None:
                LOGGER.debug("Reconnecting session %s", session_id)
                # In case there is a lingering connection, close it
                existing_session.maybe_disconnect_consumer()
                self._reconnect_session(existing_session, replay=False)
                return existing_session

            # 3. Handle resume

            # Get resumable possible resumable session
            resumable_session = mgr.maybe_resume_session(
                session_id, self.file_key
            )
            if resumable_session is not None:
                LOGGER.debug("Resuming session %s", session_id)
                self._reconnect_session(resumable_session, replay=True)
                return resumable_session

            # 4. Create a new session

            # If the client refreshed their page, there will be one
            # existing session with a closed socket for a different session
            # id; that's why we call `close_all_sessions`.
            # if mgr.mode == SessionMode.EDIT:
            #     mgr.close_all_sessions()

            # Grab the query params from the websocket
            # Note: if we resume a session, we don't pick up the new query
            # params, and instead use the query params from when the
            # session was created.
            query_params = QueryParams({}, NoopStream())
            for key, value in self.websocket.query_params.multi_items():
                if key in QueryParams.IGNORED_KEYS:
                    continue
                query_params.append(key, value)

            new_session = mgr.create_session(
                query_params=query_params.to_dict(),
                session_id=session_id,
                session_consumer=self,
                file_key=self.file_key,
            )
            self.status = ConnectionState.OPEN
            # Let the frontend know it can instantiate the app.
            self._write_kernel_ready(
                new_session,
                resumed=False,
                ui_values={},
                last_executed_code={},
                last_execution_time={},
                kiosk=False,
            )
            return new_session

        get_session()

        async def listen_for_messages() -> None:
            while True:
                (op, data) = await self.message_queue.get()

                if op in KIOSK_ONLY_OPERATIONS and not self.kiosk:
                    LOGGER.debug(
                        "Ignoring operation %s, not in kiosk mode",
                        op,
                    )
                    continue
                if op in KIOSK_EXCLUDED_OPERATIONS and self.kiosk:
                    LOGGER.debug(
                        "Ignoring operation %s, in kiosk mode",
                        op,
                    )
                    continue

                try:
                    text = json.dumps(
                        {
                            "op": op,
                            "data": data,
                        },
                        cls=WebComponentEncoder,
                    )
                except TypeError as e:
                    # This is a deserialization error
                    LOGGER.error(
                        "Failed to send message to frontend: %s", str(e)
                    )
                    LOGGER.error("Message: %s", data)
                    continue

                try:
                    await self.websocket.send_text(text)
                except WebSocketDisconnect as e:
                    self._on_disconnect(
                        e,
                        cleanup_fn=lambda: listen_for_disconnect_task.cancel(),
                    )
                except RuntimeError as e:
                    # Starlette can raise a runtime error if a message is sent
                    # when the socket is closed. In case the disconnection
                    # error hasn't made its way to listen_for_disconnect, do
                    # the cleanup here.
                    if (
                        self.websocket.application_state
                        == WebSocketState.DISCONNECTED
                    ):
                        self._on_disconnect(
                            e,
                            cleanup_fn=lambda: listen_for_disconnect_task.cancel(),  # noqa: E501
                        )

        async def listen_for_disconnect() -> None:
            try:
                self._check_status_update()
                await self.websocket.receive_text()
            except WebSocketDisconnect as e:
                self._on_disconnect(
                    e, cleanup_fn=lambda: listen_for_messages_task.cancel()
                )

        listen_for_messages_task = asyncio.create_task(listen_for_messages())
        listen_for_disconnect_task = asyncio.create_task(
            listen_for_disconnect()
        )

        try:
            self.future = asyncio.gather(
                listen_for_messages_task,
                listen_for_disconnect_task,
            )
            await self.future
        except asyncio.CancelledError:
            LOGGER.debug("Websocket terminated with CancelledError")
            pass

    def on_start(
        self,
    ) -> Callable[[KernelMessage], None]:
        def listener(response: KernelMessage) -> None:
            self.message_queue.put_nowait(response)

        return listener

    def write_operation(self, op: MessageOperation) -> None:
        self.message_queue.put_nowait((op.name, serialize(op)))

    def on_stop(self) -> None:
        # Cancel the heartbeat task, reader
        if self.heartbeat_task and not self.heartbeat_task.cancelled():
            self.heartbeat_task.cancel()

        # If the websocket is open, send a close message
        if (
            self.status == ConnectionState.OPEN
            and self.websocket.application_state is WebSocketState.CONNECTED
        ):
            asyncio.create_task(
                self.websocket.close(
                    WebSocketCodes.NORMAL_CLOSE, "MARIMO_SHUTDOWN"
                )
            )

        self.future.cancel()

    def connection_state(self) -> ConnectionState:
        return self.status

    def _check_status_update(self) -> None:
        # Only check for updates if we're in edit mode
        if (
            not GLOBAL_SETTINGS.CHECK_STATUS_UPDATE
            or self.mode != SessionMode.EDIT
        ):
            return

        def on_update(current_version: str, latest_version: str) -> None:
            # Let's only toast once per marimo server
            # so we can just store this in memory.
            # We still want to check for updates (which are debounced 24 hours)
            # but don't keep toasting.
            global HAS_TOASTED
            if HAS_TOASTED:
                return

            HAS_TOASTED = True

            title = f"Update available {current_version} → {latest_version}"
            release_url = "https://github.com/marimo-team/marimo/releases"
            description = f"Check out the <a class='underline' target='_blank' href='{release_url}'>latest release on GitHub.</a>"  # noqa: E501
            self.write_operation(Alert(title=title, description=description))

        check_for_updates(on_update)

#+END_SRC
**** Assignment HAS_TOASTED = False
#+BEGIN_SRC python
HAS_TOASTED = False

#+END_SRC
* export
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.export
:END:
** __init__
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.export.__init__
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/export/__init__.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import asyncio
from typing import Callable, Literal

from marimo._config.manager import UserConfigManager
from marimo._messaging.ops import MessageOperation
from marimo._messaging.types import KernelMessage
from marimo._runtime.requests import AppMetadata, SerializedCLIArgs
from marimo._server.export.exporter import Exporter
from marimo._server.file_manager import AppFileManager
from marimo._server.file_router import AppFileRouter
from marimo._server.model import ConnectionState, SessionConsumer, SessionMode
from marimo._server.models.export import ExportAsHTMLRequest
from marimo._server.models.models import InstantiateRequest
from marimo._server.session.session_view import SessionView
from marimo._utils.marimo_path import MarimoPath

#+END_SRC
*** Function export_as_script
#+BEGIN_SRC python
def export_as_script(
    path: MarimoPath,
) -> tuple[str, str]:
    file_router = AppFileRouter.from_filename(path)
    file_key = file_router.get_unique_file_key()
    assert file_key is not None
    file_manager = file_router.get_file_manager(file_key)

    return Exporter().export_as_script(file_manager)

#+END_SRC
*** Function export_as_md
#+BEGIN_SRC python
def export_as_md(
    path: MarimoPath,
) -> tuple[str, str]:
    file_router = AppFileRouter.from_filename(path)
    file_key = file_router.get_unique_file_key()
    assert file_key is not None
    file_manager = file_router.get_file_manager(file_key)

    return Exporter().export_as_md(file_manager)

#+END_SRC
*** Function export_as_ipynb
#+BEGIN_SRC python
def export_as_ipynb(
    path: MarimoPath,
    sort_mode: Literal["top-down", "topological"],
) -> tuple[str, str]:
    file_router = AppFileRouter.from_filename(path)
    file_key = file_router.get_unique_file_key()
    assert file_key is not None
    file_manager = file_router.get_file_manager(file_key)

    return Exporter().export_as_ipynb(file_manager, sort_mode=sort_mode)

#+END_SRC
*** Function run_app_then_export_as_html
#+BEGIN_SRC python
async def run_app_then_export_as_html(
    path: MarimoPath,
    include_code: bool,
    cli_args: SerializedCLIArgs,
) -> tuple[str, str]:
    # Create a file router and file manager
    file_router = AppFileRouter.from_filename(path)
    file_key = file_router.get_unique_file_key()
    assert file_key is not None
    file_manager = file_router.get_file_manager(file_key)

    config = UserConfigManager()
    session_view = await run_app_until_completion(file_manager, cli_args)
    # Export the session as HTML
    html, filename = Exporter().export_as_html(
        file_manager=file_manager,
        session_view=session_view,
        display_config=config.get_config()["display"],
        request=ExportAsHTMLRequest(
            include_code=include_code,
            download=False,
            files=[],
        ),
    )
    return html, filename

#+END_SRC
*** Function run_app_then_export_as_reactive_html
#+BEGIN_SRC python
async def run_app_then_export_as_reactive_html(
    path: MarimoPath,
    include_code: bool,
) -> tuple[str, str]:
    import os

    from marimo._islands.island_generator import MarimoIslandGenerator

    generator = MarimoIslandGenerator.from_file(
        path.absolute_name, display_code=include_code
    )
    await generator.build()
    html = generator.render_html()
    basename = os.path.basename(path.absolute_name)
    filename = f"{os.path.splitext(basename)[0]}.html"
    return html, filename

#+END_SRC
*** Function run_app_until_completion
#+BEGIN_SRC python
async def run_app_until_completion(
    file_manager: AppFileManager,
    cli_args: SerializedCLIArgs,
) -> SessionView:
    from marimo._server.sessions import Session

    instantiated_event = asyncio.Event()

    # Create a no-op session consumer
    class NoopSessionConsumer(SessionConsumer):
        def on_start(
            self,
        ) -> Callable[[KernelMessage], None]:
            def listener(message: KernelMessage) -> None:
                if message[0] == "completed-run":
                    instantiated_event.set()

            return listener

        def on_stop(self) -> None:
            pass

        def write_operation(self, op: MessageOperation) -> None:
            pass

        def connection_state(self) -> ConnectionState:
            return ConnectionState.OPEN

    config = UserConfigManager()

    # Create a session
    session = Session.create(
        # Any initialization ID will do
        initialization_id="_any_",
        session_consumer=NoopSessionConsumer(consumer_id="noop"),
        # Run in EDIT mode so that console outputs are captured
        mode=SessionMode.EDIT,
        app_metadata=AppMetadata(
            query_params={},
            filename=file_manager.path,
            cli_args=cli_args,
        ),
        app_file_manager=file_manager,
        user_config_manager=config,
        virtual_files_supported=False,
        redirect_console_to_browser=False,
    )

    # Run the notebook to completion once
    session.instantiate(InstantiateRequest(object_ids=[], values=[]))
    await instantiated_event.wait()
    # Process console messages
    #
    # TODO(akshayka): A timing issue with the console output worker
    # might still exist; the better thing to do would be to flush
    # the worker, then ask it to quit and join on it. If we have an
    # issue with some outputs being missed, that's what we should do.
    session.message_distributor.flush()
    # Hack: yield to give the session view a chance to process the incoming
    # console operations.
    await asyncio.sleep(0.1)
    # Stop distributor, terminate kernel process, etc -- all information is
    # captured by the session view.
    session.close()
    return session.session_view

#+END_SRC
** exporter
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.export.exporter
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/export/exporter.py
:END:
*** Import
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import base64
import io
import mimetypes
import os
from typing import Literal, Optional, cast

from marimo import __version__
from marimo._ast.cell import Cell, CellConfig, CellImpl
from marimo._config.config import (
    DEFAULT_CONFIG,
    DisplayConfig,
    _deep_copy,
)
from marimo._dependencies.dependencies import DependencyManager
from marimo._messaging.mimetypes import KnownMimeType
from marimo._output.utils import build_data_url
from marimo._runtime import dataflow
from marimo._runtime.virtual_file import read_virtual_file
from marimo._server.export.utils import (
    get_app_title,
    get_download_filename,
    get_filename,
    get_markdown_from_cell,
)
from marimo._server.file_manager import AppFileManager
from marimo._server.models.export import ExportAsHTMLRequest
from marimo._server.session.session_view import SessionView
from marimo._server.templates.templates import static_notebook_template
from marimo._server.tokens import SkewProtectionToken
from marimo._utils.paths import import_files

#+END_SRC
*** Assignment root = os.path.realpath(str(import_files("marimo").joinpath("_static")))
#+BEGIN_SRC python
# Root directory for static assets
root = os.path.realpath(str(import_files("marimo").joinpath("_static")))

#+END_SRC
*** Class Exporter
#+BEGIN_SRC python
class Exporter:
    def export_as_html(
        self,
        *,
        file_manager: AppFileManager,
        session_view: SessionView,
        display_config: DisplayConfig,
        request: ExportAsHTMLRequest,
    ) -> tuple[str, str]:
        index_html_file = os.path.join(root, "index.html")

        cell_ids = list(file_manager.app.cell_manager.cell_ids())
        filename = get_filename(file_manager)

        with open(index_html_file, "r") as f:  # noqa: ASYNC101 ASYNC230
            index_html = f.read()

        files: dict[str, str] = {}
        for filename_and_length in request.files:
            if filename_and_length.startswith("/@file/"):
                filename = filename_and_length[7:]
            byte_length, basename = filename.split("-", 1)
            buffer_contents = read_virtual_file(basename, int(byte_length))
            mime_type, _ = mimetypes.guess_type(basename) or (
                "text/plain",
                None,
            )
            files[filename_and_length] = build_data_url(
                cast(KnownMimeType, mime_type),
                base64.b64encode(buffer_contents),
            )

        # We only want pass the display config in the static notebook,
        # since we use:
        # - display.theme
        # - display.cell_output
        config = _deep_copy(DEFAULT_CONFIG)
        config["display"] = display_config

        # code and console outputs are grouped together, but
        # we can split them up in the future if desired.
        if request.include_code:
            code = file_manager.to_code()
            codes = file_manager.app.cell_manager.codes()
            configs = file_manager.app.cell_manager.configs()
            console_outputs = session_view.get_cell_console_outputs(cell_ids)
        else:
            code = ""
            codes = ["" for _ in cell_ids]
            configs = [CellConfig() for _ in cell_ids]
            console_outputs = {}

        # We include the code hash regardless of whether we include the code
        code_hash = hash_code(file_manager.to_code())

        html = static_notebook_template(
            html=index_html,
            user_config=config,
            server_token=SkewProtectionToken("static"),
            app_config=file_manager.app.config,
            filepath=file_manager.filename,
            code=code,
            code_hash=code_hash,
            cell_ids=cell_ids,
            cell_names=list(file_manager.app.cell_manager.names()),
            cell_codes=list(codes),
            cell_configs=list(configs),
            cell_outputs=session_view.get_cell_outputs(cell_ids),
            cell_console_outputs=console_outputs,
            files=files,
            asset_url=request.asset_url,
        )

        download_filename = get_download_filename(file_manager, "html")
        return html, download_filename

    def export_as_script(
        self,
        file_manager: AppFileManager,
    ) -> tuple[str, str]:
        # Check if any code is async, if so, raise an error
        for cell in file_manager.app.cell_manager.cells():
            if not cell:
                continue
            if cell._is_coroutine():
                from click import UsageError

                raise UsageError(
                    "Cannot export a notebook with async code to a flat script"
                )

        graph = file_manager.app.graph
        codes: list[str] = [
            "# %%\n" + graph.cells[cid].code
            for cid in dataflow.topological_sort(graph, graph.cells.keys())
        ]
        code = f'\n__generated_with = "{__version__}"\n\n' + "\n\n".join(codes)

        download_filename = get_download_filename(file_manager, "script.py")
        return code, download_filename

    def export_as_ipynb(
        self,
        file_manager: AppFileManager,
        sort_mode: Literal["top-down", "topological"],
    ) -> tuple[str, str]:
        DependencyManager.nbformat.require(
            "to convert marimo notebooks to ipynb"
        )
        import nbformat  # type: ignore

        def create_notebook_cell(cell: CellImpl) -> nbformat.NotebookNode:
            markdown_string = get_markdown_from_cell(
                Cell(_name="__", _cell=cell), cell.code
            )
            if markdown_string is not None:
                return nbformat.v4.new_markdown_cell(  # type: ignore
                    markdown_string, id=cell.cell_id
                )
            else:
                return nbformat.v4.new_code_cell(cell.code, id=cell.cell_id)  # type: ignore

        notebook = nbformat.v4.new_notebook()  # type: ignore
        graph = file_manager.app.graph

        if sort_mode == "top-down":
            # Get cells in document order
            cell_ids = list(file_manager.app.cell_manager.cell_ids())
        else:
            # Get cells in topological order
            cell_ids = dataflow.topological_sort(graph, graph.cells.keys())

        notebook["cells"] = [
            create_notebook_cell(graph.cells[cid])  # type: ignore
            for cid in cell_ids
        ]

        stream = io.StringIO()
        nbformat.write(notebook, stream)  # type: ignore
        stream.seek(0)
        download_filename = get_download_filename(file_manager, "ipynb")
        return stream.read(), download_filename

    def export_as_md(self, file_manager: AppFileManager) -> tuple[str, str]:
        import yaml

        from marimo._ast.app import _AppConfig
        from marimo._ast.cell import Cell
        from marimo._ast.compiler import compile_cell
        from marimo._cli.convert.markdown import (
            formatted_code_block,
            is_sanitized_markdown,
        )

        # TODO: Provide filter or kernel in yaml header such that markdown
        # documents are executable.

        #  Put data from AppFileManager into the yaml header.
        ignored_keys = {"app_title"}
        metadata: dict[str, str | list[str]] = {
            "title": get_app_title(file_manager),
            "marimo-version": __version__,
        }

        def _format_value(v: Optional[str | list[str]]) -> str | list[str]:
            if isinstance(v, list):
                return v
            return str(v)

        default_config = _AppConfig().asdict()

        # Get values defined in _AppConfig without explicitly extracting keys,
        # as long as it isn't the default.
        metadata.update(
            {
                k: _format_value(v)
                for k, v in file_manager.app.config.asdict().items()
                if k not in ignored_keys and v != default_config.get(k)
            }
        )

        header = yaml.dump(
            {
                k: v
                for k, v in metadata.items()
                if v is not None and v != "" and v != []
            },
            sort_keys=False,
        )
        document = ["---", header.strip(), "---", ""]
        previous_was_markdown = False
        for cell_data in file_manager.app.cell_manager.cell_data():
            cell = cell_data.cell
            code = cell_data.code
            # Config values are opt in, so only include if they are set.
            attributes = cell_data.config.asdict()
            attributes = {k: "true" for k, v in attributes.items() if v}
            if cell_data.name != "__":
                attributes["name"] = cell_data.name
            # No "cell" typically means not parseable. However newly added
            # cells require compilation before cell is set.
            # TODO: Refactor so it doesn't occur in export (codegen
            # does this too)
            if not cell:
                try:
                    cell_impl = compile_cell(
                        code, cell_id=str(cell_data.cell_id)
                    ).configure(cell_data.config)
                    cell = Cell(
                        _cell=cell_impl,
                        _name=cell_data.name,
                        _app=file_manager.app,
                    )
                    cell_data.cell = cell
                except SyntaxError:
                    pass

            # Definitely no "cell"; as such, treat as code, as everything in
            # marimo is code.
            if cell:
                markdown = get_markdown_from_cell(cell, code)
                # Unsanitized markdown is forced to code.
                if markdown and is_sanitized_markdown(markdown):
                    # Use blank HTML comment to separate markdown codeblocks
                    if previous_was_markdown:
                        document.append("<!---->")
                    previous_was_markdown = True
                    document.append(markdown)
                    continue
            else:
                attributes["unparsable"] = "true"
            # Add a blank line between markdown and code
            if previous_was_markdown:
                document.append("")
            previous_was_markdown = False
            document.append(formatted_code_block(code, attributes))

        download_filename = get_download_filename(file_manager, "md")
        return "\n".join(document).strip(), download_filename

#+END_SRC
*** Class AutoExporter
#+BEGIN_SRC python
class AutoExporter:
    EXPORT_DIR = "__marimo__"

    def save_html(self, file_manager: AppFileManager, html: str) -> None:
        # get filename
        directory = os.path.dirname(get_filename(file_manager))
        filename = get_download_filename(file_manager, "html")

        # make directory if it doesn't exist
        self._make_export_dir(directory)
        filepath = os.path.join(directory, self.EXPORT_DIR, filename)

        # save html to .marimo directory
        with open(filepath, "w") as f:
            f.write(html)

    def save_md(self, file_manager: AppFileManager, markdown: str) -> None:
        # get filename
        directory = os.path.dirname(get_filename(file_manager))
        filename = get_download_filename(file_manager, "md")

        # make directory if it doesn't exist
        self._make_export_dir(directory)
        filepath = os.path.join(directory, self.EXPORT_DIR, filename)

        # save md to .marimo directory
        with open(filepath, "w") as f:
            f.write(markdown)

    def _make_export_dir(self, directory: str) -> None:
        # make .marimo dir if it doesn't exist
        # don't make the other directories
        if not os.path.exists(directory):
            raise FileNotFoundError(f"Directory {directory} does not exist")

        export_dir = os.path.join(directory, self.EXPORT_DIR)
        if not os.path.exists(export_dir):
            os.mkdir(export_dir)

#+END_SRC
*** Function hash_code
#+BEGIN_SRC python
def hash_code(code: str) -> str:
    import hashlib

    return hashlib.sha256(code.encode("utf-8")).hexdigest()

#+END_SRC
** utils
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.export.utils
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/export/utils.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import ast
import os
import re
from textwrap import dedent
from typing import Optional

from marimo._ast.cell import Cell
from marimo._server.file_manager import AppFileManager

#+END_SRC
*** Function format_filename_title
#+BEGIN_SRC python
def format_filename_title(filename: str) -> str:
    basename = os.path.basename(filename)
    name, ext = os.path.splitext(basename)
    title = re.sub("[-_]", " ", name)
    return title.title()

#+END_SRC
*** Function get_filename
#+BEGIN_SRC python
def get_filename(
    file_manager: AppFileManager, default: str = "notebook.py"
) -> str:
    filename = file_manager.filename
    if not filename:
        filename = default
    return filename

#+END_SRC
*** Function get_app_title
#+BEGIN_SRC python
def get_app_title(file_manager: AppFileManager) -> str:
    if file_manager.app.config.app_title:
        return f"{file_manager.app.config.app_title}"
    filename = get_filename(file_manager)
    return format_filename_title(filename)

#+END_SRC
*** Function get_download_filename
#+BEGIN_SRC python
def get_download_filename(file_manager: AppFileManager, extension: str) -> str:
    filename = get_filename(file_manager, f"notebook.{extension}")
    basename = os.path.basename(filename)
    return f"{os.path.splitext(basename)[0]}.{extension}"

#+END_SRC
*** Function _const_string
#+BEGIN_SRC python
def _const_string(args: list[ast.stmt]) -> str:
    (inner,) = args
    if hasattr(inner, "values"):
        (inner,) = inner.values
    return f"{inner.value}"  # type: ignore[attr-defined]

#+END_SRC
*** Function get_markdown_from_cell
#+BEGIN_SRC python
def get_markdown_from_cell(
    cell: Cell, code: str, native_callout: bool = False
) -> Optional[str]:
    """Attempt to extract markdown from a cell, or return None"""

    if not (cell.refs == {"mo"} and not cell.defs):
        return None
    markdown_lines = [
        line for line in code.strip().split("\n") if line.startswith("mo.md(")
    ]
    if len(markdown_lines) > 1:
        return None

    code = code.strip()
    # Attribute Error handled by the outer try/except block.
    # Wish there was a more compact to ignore ignore[attr-defined] for all.
    try:
        (body,) = ast.parse(code).body
        callout = None
        if body.value.func.attr == "md":  # type: ignore[attr-defined]
            value = body.value  # type: ignore[attr-defined]
        elif body.value.func.attr == "callout":  # type: ignore[attr-defined]
            if not native_callout:
                return None
            if body.value.args:  # type: ignore[attr-defined]
                callout = _const_string(body.value.args)  # type: ignore[attr-defined]
            else:
                (keyword,) = body.value.keywords  # type: ignore[attr-defined]
                assert keyword.arg == "kind"
                callout = _const_string([keyword.value])  # type: ignore
            value = body.value.func.value  # type: ignore[attr-defined]
        else:
            return None
        assert value.func.value.id == "mo"
        md_lines = _const_string(value.args).split("\n")
    except (AssertionError, AttributeError, ValueError):
        # No reason to explicitly catch exceptions if we can't parse out
        # markdown. Just handle it as a code block.
        return None

    # Dedent behavior is a little different that in marimo js, so handle
    # accordingly.
    md_lines = [line.rstrip() for line in md_lines]
    md = dedent(md_lines[0]) + "\n" + dedent("\n".join(md_lines[1:]))
    md = md.strip()

    if callout:
        md = dedent(
            f"""
          ::: {{.callout-{callout}}}
          {md}
          :::"""
        )
    return md

#+END_SRC
* files
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.files
:END:
** file_system
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.files.file_system
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/files/file_system.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import List, Literal, Optional

from marimo._server.models.files import FileDetailsResponse, FileInfo

#+END_SRC
*** Class FileSystem
#+BEGIN_SRC python
class FileSystem(ABC):
    @abstractmethod
    def get_root(self) -> str:
        """Get the root path."""
        pass

    @abstractmethod
    def list_files(self, path: str) -> List[FileInfo]:
        """List files and directories in a given path."""
        pass

    @abstractmethod
    def get_details(self, path: str) -> FileDetailsResponse:
        """Get details of a specific file or directory."""
        pass

    @abstractmethod
    def open_file(self, path: str) -> str:
        """Open and read the content of a file."""
        pass

    @abstractmethod
    def create_file_or_directory(
        self,
        path: str,
        file_type: Literal["file", "directory"],
        name: str,
        contents: Optional[bytes],
    ) -> FileInfo:
        """
        Create a new file or directory

        If the name already exists, a new name will be generated.
        """
        pass

    @abstractmethod
    def delete_file_or_directory(self, path: str) -> bool:
        """Delete a file or directory."""
        pass

    @abstractmethod
    def move_file_or_directory(self, path: str, new_path: str) -> FileInfo:
        """Rename or move a file or directory."""
        pass

    @abstractmethod
    def update_file(self, path: str, contents: str) -> FileInfo:
        """Update the contents of a file."""
        pass

#+END_SRC
** os_file_system
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.files.os_file_system
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/files/os_file_system.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import base64
import mimetypes
import os
import re
import shutil
from typing import List, Literal, Optional, Union

from marimo._server.files.file_system import FileSystem
from marimo._server.models.files import FileDetailsResponse, FileInfo

#+END_SRC
*** Assignment IGNORE_LIST
#+BEGIN_SRC python
IGNORE_LIST = [
    ".",
    "..",
    ".DS_Store",
    "__pycache__",
    "node_modules",
]

#+END_SRC
*** Assignment DISALLOWED_NAMES = [     ".",     "..", ]
#+BEGIN_SRC python
DISALLOWED_NAMES = [
    ".",
    "..",
]

#+END_SRC
*** Class OSFileSystem
#+BEGIN_SRC python
class OSFileSystem(FileSystem):
    def get_root(self) -> str:
        return os.getcwd()

    def list_files(self, path: str) -> List[FileInfo]:
        files: List[FileInfo] = []
        folders: List[FileInfo] = []
        try:
            with os.scandir(path) as it:
                for entry in it:
                    if entry.name in IGNORE_LIST:
                        continue
                    try:
                        is_directory = entry.is_dir()
                        entry_stat = entry.stat()
                    except OSError:
                        # do not include files that fail to read
                        # (e.g. recursive/broken symlinks)
                        continue

                    info = FileInfo(
                        id=entry.path,
                        path=entry.path,
                        name=entry.name,
                        is_directory=is_directory,
                        is_marimo_file=not is_directory
                        and self._is_marimo_file(entry.path),
                        last_modified=entry_stat.st_mtime,
                    )
                    if is_directory:
                        folders.append(info)
                    else:
                        files.append(info)
        except OSError:
            pass

        return sorted(folders, key=natural_sort_file) + sorted(
            files, key=natural_sort_file
        )

    def _get_file_info(self, path: str) -> FileInfo:
        stat = os.stat(path)
        is_directory = os.path.isdir(path)
        return FileInfo(
            id=path,
            path=path,
            name=os.path.basename(path),
            is_directory=is_directory,
            is_marimo_file=not is_directory and self._is_marimo_file(path),
            last_modified=stat.st_mtime,
        )

    def get_details(
        self, path: str, encoding: str | None = None
    ) -> FileDetailsResponse:
        file_info = self._get_file_info(path)
        contents = (
            self.open_file(path, encoding=encoding)
            if not file_info.is_directory
            else None
        )
        mime_type = mimetypes.guess_type(path)[0]
        return FileDetailsResponse(
            file=file_info, contents=contents, mime_type=mime_type
        )

    def _is_marimo_file(self, path: str) -> bool:
        if not path.endswith(".py"):
            return False

        with open(path, "rb") as file:
            return b"app = marimo.App(" in file.read()

    def open_file(self, path: str, encoding: str | None = None) -> str:
        try:
            with open(path, mode="r", encoding=encoding) as file:
                return file.read()
        except UnicodeDecodeError:
            # If its a UnicodeDecodeError, try as bytes and convert to base64
            with open(path, mode="rb") as file:
                return base64.b64encode(file.read()).decode("utf-8")

    def create_file_or_directory(
        self,
        path: str,
        file_type: Literal["file", "directory"],
        name: str,
        contents: Optional[bytes],
    ) -> FileInfo:
        if name in DISALLOWED_NAMES:
            raise ValueError(
                f"Cannot create file or directory with name {name}"
            )
        if name.strip() == "":
            raise ValueError("Cannot create file or directory with empty name")

        full_path = os.path.join(path, name)
        # If the file already exists, generate a new name
        if os.path.exists(full_path):
            i = 1
            name_without_extension, extension = os.path.splitext(name)
            while True:
                new_name = f"{name_without_extension}_{i}{extension}"
                new_full_path = os.path.join(path, new_name)
                if not os.path.exists(new_full_path):
                    full_path = new_full_path
                    break
                i += 1

        if file_type == "directory":
            os.makedirs(full_path)
        else:
            with open(full_path, "wb") as file:
                if contents:
                    file.write(contents)
        # encoding latin-1 to get an invertible representation of the
        # bytes as a string ...
        return self.get_details(full_path, encoding="latin-1").file

    def delete_file_or_directory(self, path: str) -> bool:
        if os.path.isdir(path):
            shutil.rmtree(path)
        else:
            os.remove(path)
        return True

    def move_file_or_directory(self, path: str, new_path: str) -> FileInfo:
        file_name = os.path.basename(new_path)
        # Disallow renaming to . or ..
        if file_name in DISALLOWED_NAMES:
            raise ValueError(f"Cannot rename to {new_path}")

        shutil.move(path, new_path)
        return self.get_details(new_path).file

    def update_file(self, path: str, contents: str) -> FileInfo:
        with open(path, "w") as file:
            file.write(contents)
        return self.get_details(path).file

#+END_SRC
*** Function natural_sort_file
#+BEGIN_SRC python
def natural_sort_file(file: FileInfo) -> List[Union[int, str]]:
    return natural_sort(file.name)

#+END_SRC
*** Function natural_sort
#+BEGIN_SRC python
def natural_sort(filename: str) -> List[Union[int, str]]:
    def convert(text: str) -> Union[int, str]:
        return int(text) if text.isdigit() else text.lower()

    def alphanum_key(key: str) -> List[Union[int, str]]:
        return [convert(c) for c in re.split("([0-9]+)", key)]

    return alphanum_key(filename)

#+END_SRC
* models
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.models
:END:
** base
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.models.base
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/models/base.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.

from __future__ import annotations

from typing import Any

#+END_SRC
*** Function to_camel_case
#+BEGIN_SRC python
def to_camel_case(snake_str: str) -> str:
    if snake_str == "":
        return ""

    if "_" not in snake_str:
        return snake_str

    pascal_case = "".join(x.capitalize() for x in snake_str.lower().split("_"))
    return snake_str[0].lower() + pascal_case[1:]

#+END_SRC
*** Function deep_to_camel_case
#+BEGIN_SRC python
def deep_to_camel_case(snake_dict: Any) -> dict[str, Any]:
    if isinstance(snake_dict, list):
        return [deep_to_camel_case(item) for item in snake_dict]  # type: ignore  # noqa: E501
    if isinstance(snake_dict, str):
        return to_camel_case(snake_dict)  # type: ignore

    camel_dict: dict[str, Any] = {}
    for key, value in snake_dict.items():
        if isinstance(value, dict):
            camel_dict[to_camel_case(key)] = deep_to_camel_case(value)
        elif isinstance(value, list):
            camel_dict[to_camel_case(key)] = [
                deep_to_camel_case(item) for item in value
            ]
        else:
            camel_dict[to_camel_case(key)] = value
    return camel_dict

#+END_SRC
** completion
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.models.completion
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/models/completion.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from dataclasses import dataclass, field
from typing import List, Literal, Optional

from marimo._ai.types import ChatMessage

#+END_SRC
*** @dataclass: Class SchemaColumn
#+BEGIN_SRC python
@dataclass
class SchemaColumn:
    name: str
    type: str

#+END_SRC
*** @dataclass: Class SchemaTable
#+BEGIN_SRC python
@dataclass
class SchemaTable:
    name: str
    columns: List[SchemaColumn]

#+END_SRC
*** @dataclass: Class AiCompletionContext
#+BEGIN_SRC python
@dataclass
class AiCompletionContext:
    schema: List[SchemaTable] = field(default_factory=list)

#+END_SRC
*** Assignment Language = Literal["python", "markdown", "sql"]
#+BEGIN_SRC python
Language = Literal["python", "markdown", "sql"]

#+END_SRC
*** @dataclass: Class AiCompletionRequest
#+BEGIN_SRC python
@dataclass
class AiCompletionRequest:
    prompt: str
    include_other_code: str
    code: str
    context: Optional[AiCompletionContext] = None
    language: Language = "python"

#+END_SRC
*** @dataclass: Class ChatRequest
#+BEGIN_SRC python
@dataclass
class ChatRequest:
    messages: List[ChatMessage]
    model: Optional[str] = None
    variables: Optional[List[str]] = None
    context: Optional[AiCompletionContext] = None
    include_other_code: str = ""

#+END_SRC
** export
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.models.export
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/models/export.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional

#+END_SRC
*** @dataclass: Class ExportAsHTMLRequest
#+BEGIN_SRC python
@dataclass
class ExportAsHTMLRequest:
    download: bool
    files: List[str]
    include_code: bool
    asset_url: Optional[str] = None

#+END_SRC
*** @dataclass: Class ExportAsScriptRequest
#+BEGIN_SRC python
@dataclass
class ExportAsScriptRequest:
    download: bool

#+END_SRC
*** @dataclass: Class ExportAsMarkdownRequest
#+BEGIN_SRC python
@dataclass
class ExportAsMarkdownRequest:
    download: bool

#+END_SRC
** files
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.models.files
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/models/files.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from dataclasses import dataclass, field
from typing import List, Literal, Optional

from marimo._server.models.models import BaseResponse

#+END_SRC
*** @dataclass: Class FileInfo
#+BEGIN_SRC python
@dataclass
class FileInfo:
    id: str
    path: str
    name: str
    is_directory: bool
    is_marimo_file: bool
    last_modified: Optional[float] = None
    children: List["FileInfo"] = field(default_factory=list)

#+END_SRC
*** @dataclass: Class FileListRequest
#+BEGIN_SRC python
@dataclass
class FileListRequest:
    # The directory path to list files from
    # If None, the root directory will be used
    path: Optional[str] = None

#+END_SRC
*** @dataclass: Class FileDetailsRequest
#+BEGIN_SRC python
@dataclass
class FileDetailsRequest:
    # The path of the file or directory
    path: str

#+END_SRC
*** @dataclass: Class FileOpenRequest
#+BEGIN_SRC python
@dataclass
class FileOpenRequest:
    # The path of the file to open
    path: str

#+END_SRC
*** @dataclass: Class FileTreeRequest
#+BEGIN_SRC python
@dataclass
class FileTreeRequest:
    # The root directory path for the tree
    path: str

#+END_SRC
*** @dataclass: Class FileCreateRequest
#+BEGIN_SRC python
@dataclass
class FileCreateRequest:
    # The path where to create the file or directory
    path: str
    # 'file' or 'directory'
    type: Literal["file", "directory"]
    # The name of the file or directory
    name: str
    # The contents of the file, base64-encoded
    contents: Optional[str] = None

#+END_SRC
*** @dataclass: Class FileDeleteRequest
#+BEGIN_SRC python
@dataclass
class FileDeleteRequest:
    # The path of the file or directory to delete
    path: str

#+END_SRC
*** @dataclass: Class FileMoveRequest
#+BEGIN_SRC python
@dataclass
class FileMoveRequest:
    # The current path of the file or directory
    path: str
    # The new path or name for the file or directory
    new_path: str

#+END_SRC
*** @dataclass: Class FileUpdateRequest
#+BEGIN_SRC python
@dataclass
class FileUpdateRequest:
    # The current path of the file or directory
    path: str
    # The new contents of the file
    contents: str

#+END_SRC
*** @dataclass: Class FileListResponse
#+BEGIN_SRC python
@dataclass
class FileListResponse:
    files: List[FileInfo]
    root: str

#+END_SRC
*** @dataclass: Class FileDetailsResponse
#+BEGIN_SRC python
@dataclass
class FileDetailsResponse:
    file: FileInfo
    contents: Optional[str] = None
    mime_type: Optional[str] = None

#+END_SRC
*** @dataclass: Class FileCreateResponse
#+BEGIN_SRC python
@dataclass
class FileCreateResponse(BaseResponse):
    # Additional information, e.g., error message
    message: Optional[str] = None
    info: Optional[FileInfo] = None

#+END_SRC
*** @dataclass: Class FileDeleteResponse
#+BEGIN_SRC python
@dataclass
class FileDeleteResponse(BaseResponse):
    # Additional information, e.g., error message
    message: Optional[str] = None

#+END_SRC
*** @dataclass: Class FileUpdateResponse
#+BEGIN_SRC python
@dataclass
class FileUpdateResponse(BaseResponse):
    # Additional information, e.g., error message
    message: Optional[str] = None
    info: Optional[FileInfo] = None

#+END_SRC
*** @dataclass: Class FileMoveResponse
#+BEGIN_SRC python
@dataclass
class FileMoveResponse(BaseResponse):
    # Additional information, e.g., error message
    message: Optional[str] = None
    info: Optional[FileInfo] = None

#+END_SRC
** home
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.models.home
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/models/home.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional

from marimo._server.ids import SessionId
from marimo._server.models.files import FileInfo
from marimo._tutorials import Tutorial

#+END_SRC
*** @dataclass: Class MarimoFile
#+BEGIN_SRC python
@dataclass
class MarimoFile:
    # Name of the file
    name: str
    # Absolute path to the file
    path: str
    # Last modified time of the file
    last_modified: Optional[float] = None
    # Session id
    session_id: Optional[SessionId] = None
    # Session initialization id
    # This is the ID for when the session was initialized
    initialization_id: Optional[str] = None

#+END_SRC
*** @dataclass: Class RecentFilesResponse
#+BEGIN_SRC python
@dataclass
class RecentFilesResponse:
    files: List[MarimoFile]

#+END_SRC
*** @dataclass: Class RunningNotebooksResponse
#+BEGIN_SRC python
@dataclass
class RunningNotebooksResponse:
    files: List[MarimoFile]

#+END_SRC
*** @dataclass: Class OpenTutorialRequest
#+BEGIN_SRC python
@dataclass
class OpenTutorialRequest:
    tutorial_id: Tutorial

#+END_SRC
*** @dataclass: Class WorkspaceFilesRequest
#+BEGIN_SRC python
@dataclass
class WorkspaceFilesRequest:
    include_markdown: bool = False

#+END_SRC
*** @dataclass: Class WorkspaceFilesResponse
#+BEGIN_SRC python
@dataclass
class WorkspaceFilesResponse:
    root: str
    files: List[FileInfo]

#+END_SRC
*** @dataclass: Class ShutdownSessionRequest
#+BEGIN_SRC python
@dataclass
class ShutdownSessionRequest:
    session_id: SessionId

#+END_SRC
** models
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.models.models
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/models/models.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import os
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from marimo._ast.cell import CellConfig, CellId_t
from marimo._config.config import MarimoConfig
from marimo._runtime.requests import (
    ExecuteMultipleRequest,
    ExecuteScratchpadRequest,
    RenameRequest,
)

#+END_SRC
*** Assignment UIElementId = str
#+BEGIN_SRC python
UIElementId = str

#+END_SRC
*** @dataclass: Class UpdateComponentValuesRequest
#+BEGIN_SRC python
@dataclass
class UpdateComponentValuesRequest:
    object_ids: List[UIElementId]
    values: List[Any]

    def zip(
        self,
    ) -> List[tuple[UIElementId, Any]]:
        return list(zip(self.object_ids, self.values))

    # Validate same length
    def __post_init__(self) -> None:
        assert len(self.object_ids) == len(
            self.values
        ), "Mismatched object_ids and values"

#+END_SRC
*** @dataclass: Class InstantiateRequest
#+BEGIN_SRC python
@dataclass
class InstantiateRequest(UpdateComponentValuesRequest):
    pass

#+END_SRC
*** @dataclass: Class BaseResponse
#+BEGIN_SRC python
@dataclass
class BaseResponse:
    success: bool

#+END_SRC
*** @dataclass: Class SuccessResponse
#+BEGIN_SRC python
@dataclass
class SuccessResponse(BaseResponse):
    success: bool = True

#+END_SRC
*** @dataclass: Class FormatRequest
#+BEGIN_SRC python
@dataclass
class FormatRequest:
    codes: Dict[CellId_t, str]
    line_length: int

#+END_SRC
*** @dataclass: Class FormatResponse
#+BEGIN_SRC python
@dataclass
class FormatResponse:
    codes: Dict[CellId_t, str]

#+END_SRC
*** @dataclass: Class ReadCodeResponse
#+BEGIN_SRC python
@dataclass
class ReadCodeResponse:
    contents: str

#+END_SRC
*** @dataclass: Class RenameFileRequest
#+BEGIN_SRC python
@dataclass
class RenameFileRequest:
    filename: str

    def as_execution_request(self) -> RenameRequest:
        return RenameRequest(filename=os.path.abspath(self.filename))

#+END_SRC
*** @dataclass: Class OpenFileRequest
#+BEGIN_SRC python
@dataclass
class OpenFileRequest:
    path: str

#+END_SRC
*** @dataclass: Class RunRequest
#+BEGIN_SRC python
@dataclass
class RunRequest:
    # ids of cells to run
    cell_ids: List[CellId_t]
    # code to register/run for each cell
    codes: List[str]

    def as_execution_request(self) -> ExecuteMultipleRequest:
        return ExecuteMultipleRequest(cell_ids=self.cell_ids, codes=self.codes)

    # Validate same length
    def __post_init__(self) -> None:
        assert len(self.cell_ids) == len(
            self.codes
        ), "Mismatched cell_ids and codes"

#+END_SRC
*** @dataclass: Class RunScratchpadRequest
#+BEGIN_SRC python
@dataclass
class RunScratchpadRequest:
    code: str

    def as_execution_request(self) -> ExecuteScratchpadRequest:
        return ExecuteScratchpadRequest(code=self.code)

#+END_SRC
*** @dataclass: Class SaveNotebookRequest
#+BEGIN_SRC python
@dataclass
class SaveNotebookRequest:
    # id of each cell
    cell_ids: List[CellId_t]
    # code for each cell
    codes: List[str]
    # name of each cell
    names: List[str]
    # config for each cell
    configs: List[CellConfig]
    # path to app
    filename: str
    # layout of app
    layout: Optional[Dict[str, Any]] = None
    # persist the file to disk
    persist: bool = True

    # Validate same length
    def __post_init__(self) -> None:
        assert len(self.cell_ids) == len(
            self.codes
        ), "Mismatched cell_ids and codes"
        assert len(self.cell_ids) == len(
            self.names
        ), "Mismatched cell_ids and names"
        assert len(self.cell_ids) == len(
            self.configs
        ), "Mismatched cell_ids and configs"

#+END_SRC
*** @dataclass: Class CopyNotebookRequest
#+BEGIN_SRC python
@dataclass
class CopyNotebookRequest:
    # path to app
    source: str
    destination: str

    # Validate filenames are valid, and destination path does not already exist
    def __post_init__(self) -> None:
        destination = os.path.basename(self.destination)
        assert self.source is not None
        assert self.destination is not None
        assert os.path.exists(self.source), (
            f'File "{self.source}" does not exist.'
            + "Please save the notebook and try again."
        )
        assert not os.path.exists(
            self.destination
        ), f'File "{destination}" already exists in this directory.'

#+END_SRC
*** @dataclass: Class SaveAppConfigurationRequest
#+BEGIN_SRC python
@dataclass
class SaveAppConfigurationRequest:
    # partial app config
    config: Dict[str, Any]

#+END_SRC
*** @dataclass: Class SaveUserConfigurationRequest
#+BEGIN_SRC python
@dataclass
class SaveUserConfigurationRequest:
    # user configuration
    config: MarimoConfig

#+END_SRC
*** @dataclass: Class StdinRequest
#+BEGIN_SRC python
@dataclass
class StdinRequest:
    text: str

#+END_SRC
** packages
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.models.packages
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/models/packages.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional

from marimo._runtime.packages.package_manager import PackageDescription

#+END_SRC
*** @dataclass: Class AddPackageRequest
#+BEGIN_SRC python
@dataclass
class AddPackageRequest:
    """
    This can be a remove package or a local package.

    Supported formats:

    httpx
    httpx==0.27.0
    httpx>=0.27.0
    git+https://github.com/encode/httpx
    https://files.pythonhosted.org/packages/5c/2d/3da5bdf4408b8b2800061c339f240c1802f2e82d55e50bd39c5a881f47f0/httpx-0.27.0.tar.gz
    /example/foo-0.1.0-py3-none-any.whl
    """

    package: str

#+END_SRC
*** @dataclass: Class RemovePackageRequest
#+BEGIN_SRC python
@dataclass
class RemovePackageRequest:
    package: str

#+END_SRC
*** @dataclass: Class ListPackagesResponse
#+BEGIN_SRC python
@dataclass
class ListPackagesResponse:
    packages: List[PackageDescription]

#+END_SRC
*** @dataclass: Class PackageOperationResponse
#+BEGIN_SRC python
@dataclass
class PackageOperationResponse:
    success: bool
    error: Optional[str] = None

    @staticmethod
    def of_success() -> PackageOperationResponse:
        return PackageOperationResponse(success=True, error=None)

    @staticmethod
    def of_failure(error: str) -> PackageOperationResponse:
        return PackageOperationResponse(success=False, error=error)

#+END_SRC
* session
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.session
:END:
** __init__
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.session.__init__
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/session/__init__.py
:END:
*** Comment
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.

#+END_SRC
** session_view
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.session.session_view
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/session/session_view.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import time
from dataclasses import dataclass
from typing import Any, Literal, Optional, Union

from marimo._ast.cell import CellId_t
from marimo._data.models import DataTable
from marimo._messaging.cell_output import CellChannel, CellOutput
from marimo._messaging.ops import (
    CellOp,
    Datasets,
    Interrupted,
    MessageOperation,
    Variables,
    VariableValue,
    VariableValues,
)
from marimo._runtime.requests import (
    ControlRequest,
    CreationRequest,
    ExecuteMultipleRequest,
    ExecutionRequest,
    SetUIElementValueRequest,
)
from marimo._utils.parse_dataclass import parse_raw

#+END_SRC
*** Class SessionView
#+BEGIN_SRC python
class SessionView:
    """
    This stores the current view of the session.

    Which are the cell's outputs, status, and console.
    """

    def __init__(self) -> None:
        # List of operations we care about keeping track of.
        self.cell_operations: dict[CellId_t, CellOp] = {}
        # The most recent datasets operation.
        self.datasets: Datasets = Datasets(tables=[])
        # The most recent Variables operation.
        self.variable_operations: Variables = Variables(variables=[])
        # Map of variable name to value.
        self.variable_values: dict[str, VariableValue] = {}
        # Map of object id to value.
        self.ui_values: dict[str, Any] = {}
        # Map of cell id to the last code that was executed in that cell.
        self.last_executed_code: dict[CellId_t, str] = {}
        # Map of cell id to the last cell execution time
        self.last_execution_time: dict[CellId_t, float] = {}

        # Auto-saving
        self.has_auto_exported_html = False
        self.has_auto_exported_md = False

    def _add_ui_value(self, name: str, value: Any) -> None:
        self.ui_values[name] = value

    def _add_last_run_code(self, req: ExecutionRequest) -> None:
        self.last_executed_code[req.cell_id] = req.code

    def add_raw_operation(self, raw_operation: Any) -> None:
        self._touch()

        # parse_raw only accepts a dataclass, so we wrap MessageOperation in a
        # dataclass.
        @dataclass
        class _Container:
            operation: MessageOperation

        operation = parse_raw({"operation": raw_operation}, _Container)
        self.add_operation(operation.operation)

    def add_control_request(self, request: ControlRequest) -> None:
        self._touch()

        if isinstance(request, SetUIElementValueRequest):
            for object_id, value in request.ids_and_values:
                self._add_ui_value(object_id, value)
        elif isinstance(request, ExecuteMultipleRequest):
            for execution_request in request.execution_requests:
                self._add_last_run_code(execution_request)
        elif isinstance(request, CreationRequest):
            for (
                object_id,
                value,
            ) in request.set_ui_element_value_request.ids_and_values:
                self._add_ui_value(object_id, value)
            for execution_request in request.execution_requests:
                self._add_last_run_code(execution_request)

    def add_stdin(self, stdin: str) -> None:
        self._touch()

        """Add a stdin request to the session view."""
        # Find the first cell that is waiting for stdin.
        for cell_op in self.cell_operations.values():
            console_ops: list[CellOutput] = as_list(cell_op.console)
            for cell_output in console_ops:
                if cell_output.channel == CellChannel.STDIN:
                    cell_output.channel = CellChannel.STDOUT
                    cell_output.data = f"{cell_output.data} {stdin}\n"
                    return

    def add_operation(self, operation: MessageOperation) -> None:
        self._touch()

        """Add an operation to the session view."""

        if isinstance(operation, CellOp):
            previous = self.cell_operations.get(operation.cell_id)
            self.cell_operations[operation.cell_id] = merge_cell_operation(
                previous, operation
            )
            if not previous:
                return
            if previous.status == "queued" and operation.status == "running":
                self.save_execution_time(operation, "start")
            if previous.status == "running" and operation.status == "idle":
                self.save_execution_time(operation, "end")

        elif isinstance(operation, Variables):
            self.variable_operations = operation

            # Set of variable names that are in scope.
            variable_names: set[str] = set(
                [v.name for v in self.variable_operations.variables]
            )

            # Remove any variable values that are no longer in scope.
            next_values: dict[str, VariableValue] = {}
            for name, value in self.variable_values.items():
                if name in variable_names:
                    next_values[name] = value
            self.variable_values = next_values

            # Remove any table values that are no longer in scope.
            next_tables: dict[str, DataTable] = {}
            for table in self.datasets.tables:
                if table.variable_name in variable_names:
                    next_tables[table.name] = table
            self.datasets = Datasets(tables=list(next_tables.values()))

        elif isinstance(operation, VariableValues):
            for value in operation.variables:
                self.variable_values[value.name] = value

        elif isinstance(operation, Interrupted):
            # Resolve stdin
            self.add_stdin("")
        elif isinstance(operation, Datasets):
            # Merge datasets, dedupe by table name and keep the latest.
            # If clear_channel is set, clear those tables
            prev_tables = self.datasets.tables
            if operation.clear_channel is not None:
                prev_tables = [
                    t
                    for t in prev_tables
                    if t.source_type != operation.clear_channel
                ]

            tables = {t.name: t for t in prev_tables}
            for table in operation.tables:
                tables[table.name] = table
            self.datasets = Datasets(tables=list(tables.values()))

    def get_cell_outputs(
        self, ids: list[CellId_t]
    ) -> dict[CellId_t, CellOutput]:
        """Get the outputs for the given cell ids."""
        outputs: dict[CellId_t, CellOutput] = {}
        for cell_id in ids:
            cell_op = self.cell_operations.get(cell_id)
            if cell_op is not None and cell_op.output is not None:
                outputs[cell_id] = cell_op.output
        return outputs

    def get_cell_console_outputs(
        self, ids: list[CellId_t]
    ) -> dict[CellId_t, list[CellOutput]]:
        """Get the console outputs for the given cell ids."""
        outputs: dict[CellId_t, list[CellOutput]] = {}
        for cell_id in ids:
            cell_op = self.cell_operations.get(cell_id)
            if cell_op is not None and cell_op.console:
                outputs[cell_id] = as_list(cell_op.console)
        return outputs

    def save_execution_time(
        self, operation: MessageOperation, event: Literal["start", "end"]
    ) -> None:
        """Updates execution time for given cell."""
        if not isinstance(operation, CellOp):
            return
        cell_id = operation.cell_id

        if event == "start":
            time_elapsed = operation.timestamp
        elif event == "end":
            start = self.last_execution_time.get(cell_id)
            start = start if start else 0
            time_elapsed = time.time() - start
            time_elapsed = round(time_elapsed * 1000)

        self.last_execution_time[cell_id] = time_elapsed

    @property
    def operations(self) -> list[MessageOperation]:
        all_ops: list[MessageOperation] = []
        if self.variable_operations.variables:
            all_ops.append(self.variable_operations)
        if self.variable_values:
            all_ops.append(
                VariableValues(variables=list(self.variable_values.values()))
            )
        if self.datasets.tables:
            all_ops.append(self.datasets)
        all_ops.extend(self.cell_operations.values())
        return all_ops

    def mark_auto_export_html(self) -> None:
        self.has_auto_exported_html = True

    def mark_auto_export_md(self) -> None:
        self.has_auto_exported_md = True

    def _touch(self) -> None:
        self.has_auto_exported_html = False
        self.has_auto_exported_md = False

#+END_SRC
*** Function merge_cell_operation
#+BEGIN_SRC python
def merge_cell_operation(
    previous: Optional[CellOp],
    next_: CellOp,
) -> CellOp:
    """Merge two cell operations."""
    if previous is None:
        return next_

    assert previous.cell_id == next_.cell_id

    if next_.status is None:
        next_.status = previous.status

    # If we went from queued to running, clear the console.
    if next_.status == "running" and previous.status == "queued":
        next_.console = []
    else:
        combined_console: list[CellOutput] = as_list(previous.console)
        combined_console.extend(as_list(next_.console))
        next_.console = combined_console

    # If we went from running to running, use the previous timestamp.
    if next_.status == "running" and previous.status == "running":
        next_.timestamp = previous.timestamp

    if next_.output is None:
        next_.output = previous.output

    return next_

#+END_SRC
*** Function as_list
#+BEGIN_SRC python
def as_list(value: Union[Any, Optional[Any], list[Any]]) -> list[Any]:
    if value is None:
        return []
    return value if isinstance(value, list) else [value]

#+END_SRC
* templates
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.templates
:END:
** templates
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._server.templates.templates
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_server/templates/templates.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import base64
import json
import os
from textwrap import dedent
from typing import Any, List, Optional, cast

from marimo import __version__
from marimo._ast.app import _AppConfig
from marimo._ast.cell import CellConfig, CellId_t
from marimo._config.config import MarimoConfig
from marimo._messaging.cell_output import CellOutput
from marimo._output.utils import uri_encode_component
from marimo._server.api.utils import parse_title
from marimo._server.file_manager import read_css_file, read_html_head_file
from marimo._server.model import SessionMode
from marimo._server.tokens import SkewProtectionToken

#+END_SRC
*** Function home_page_template
#+BEGIN_SRC python
def home_page_template(
    html: str,
    base_url: str,
    user_config: MarimoConfig,
    server_token: SkewProtectionToken,
) -> str:
    html = html.replace("{{ base_url }}", base_url)
    html = html.replace("{{ user_config }}", json.dumps(user_config))
    html = html.replace("{{ server_token }}", str(server_token))
    html = html.replace("{{ version }}", __version__)

    html = html.replace("{{ title }}", "marimo")
    html = html.replace("{{ app_config }}", json.dumps({}))
    html = html.replace("{{ filename }}", "")
    html = html.replace("{{ mode }}", "home")

    return html

#+END_SRC
*** Function notebook_page_template
#+BEGIN_SRC python
def notebook_page_template(
    html: str,
    base_url: str,
    user_config: MarimoConfig,
    server_token: SkewProtectionToken,
    app_config: _AppConfig,
    filename: Optional[str],
    mode: SessionMode,
) -> str:
    html = html.replace("{{ base_url }}", base_url)
    html = html.replace("{{ user_config }}", json.dumps(user_config))
    html = html.replace("{{ server_token }}", str(server_token))
    html = html.replace("{{ version }}", __version__)

    html = html.replace(
        "{{ title }}",
        parse_title(filename)
        if app_config.app_title is None
        else app_config.app_title,
    )
    html = html.replace(
        "{{ app_config }}", json.dumps(_del_none_or_empty(app_config.asdict()))
    )
    html = html.replace("{{ filename }}", filename or "")
    html = html.replace(
        "{{ mode }}",
        "read" if mode == SessionMode.RUN else "edit",
    )
    # If has custom css, inline the css and add to the head
    if app_config.css_file:
        css_contents = read_css_file(app_config.css_file, filename=filename)
        if css_contents:
            css_contents = f"<style>{css_contents}</style>"
            # Append to head
            html = html.replace("</head>", f"{css_contents}</head>")

    # Add HTML head file contents if specified
    if app_config.html_head_file:
        head_contents = read_html_head_file(
            app_config.html_head_file, filename=filename
        )
        if head_contents:
            # Append to head
            html = html.replace("</head>", f"{head_contents}</head>")

    return html

#+END_SRC
*** Function static_notebook_template
#+BEGIN_SRC python
def static_notebook_template(
    html: str,
    user_config: MarimoConfig,
    server_token: SkewProtectionToken,
    app_config: _AppConfig,
    filepath: Optional[str],
    code: str,
    code_hash: str,
    cell_ids: list[str],
    cell_names: list[str],
    cell_codes: list[str],
    cell_configs: list[CellConfig],
    cell_outputs: dict[CellId_t, CellOutput],
    cell_console_outputs: dict[CellId_t, List[CellOutput]],
    files: dict[str, str],
    asset_url: Optional[str] = None,
) -> str:
    if asset_url is None:
        asset_url = f"https://cdn.jsdelivr.net/npm/@marimo-team/frontend@{__version__}/dist"

    html = html.replace("{{ base_url }}", "")
    # We don't need all this user config when we export the notebook,
    # but we do need some:
    # - display.theme
    # - display.cell_output
    html = html.replace(
        "{{ user_config }}", json.dumps(user_config, sort_keys=True)
    )
    html = html.replace("{{ server_token }}", str(server_token))
    html = html.replace("{{ version }}", __version__)

    html = html.replace(
        "{{ title }}",
        parse_title(filepath)
        if app_config.app_title is None
        else app_config.app_title,
    )
    html = html.replace(
        "{{ app_config }}",
        json.dumps(_del_none_or_empty(app_config.asdict()), sort_keys=True),
    )
    html = html.replace("{{ filename }}", os.path.basename(filepath or ""))
    html = html.replace("{{ mode }}", "read")

    serialized_cell_outputs = {
        cell_id: _serialize_to_base64(json.dumps(output.asdict()))
        for cell_id, output in cell_outputs.items()
    }
    serialized_cell_console_outputs = {
        cell_id: [_serialize_to_base64(json.dumps(o.asdict())) for o in output]
        for cell_id, output in cell_console_outputs.items()
        if output
    }

    static_block = dedent(f"""
    <script data-marimo="true">
        window.__MARIMO_STATIC__ = {{}};
        window.__MARIMO_STATIC__.version = "{__version__}";
        window.__MARIMO_STATIC__.notebookState = {json.dumps({
          "cellIds": cell_ids,
          "cellNames": _serialize_list_to_base64(cell_names),
          "cellCodes": _serialize_list_to_base64(cell_codes),
          "cellConfigs": _serialize_list_to_base64([
            json.dumps(config.asdict())
            for config in cell_configs
          ]),
          "cellOutputs": serialized_cell_outputs,
          "cellConsoleOutputs": serialized_cell_console_outputs,
        })};
        window.__MARIMO_STATIC__.assetUrl = "{asset_url}";
        window.__MARIMO_STATIC__.files = {json.dumps(files)};
    </script>
    """)

    # Add HTML head file contents if specified
    if app_config.html_head_file:
        head_contents = read_html_head_file(
            app_config.html_head_file, filename=filepath
        )
        if head_contents:
            static_block += dedent(f"""
            {head_contents}
            """)

    # If has custom css, inline the css and add to the head
    if app_config.css_file:
        css_contents = read_css_file(app_config.css_file, filename=filepath)
        if css_contents:
            static_block += dedent(f"""
            <style>
                {css_contents}
            </style>
            """)

    code_block = dedent(f"""
    <marimo-code hidden="">
        {uri_encode_component(code)}
    </marimo-code>
    """)
    if not code:
        code_block = '<marimo-code hidden=""></marimo-code>'

    # Add a 256-bit hash of the code, for cache busting or CI checks
    code_block += (
        f'\n<marimo-code-hash hidden="">{code_hash}</marimo-code-hash>\n'
    )

    # Replace all relative href and src with absolute URL
    html = (
        html.replace("href='./", f"crossorigin='anonymous' href='{asset_url}/")
        .replace("src='./", f"crossorigin='anonymous' src='{asset_url}/")
        .replace('href="./', f'crossorigin="anonymous" href="{asset_url}/')
        .replace('src="./', f'crossorigin="anonymous" src="{asset_url}/')
    )

    # Append to head
    html = html.replace("</head>", f"{static_block}</head>")
    # Append to body
    html = html.replace("</body>", f"{code_block}</body>")

    return html

#+END_SRC
*** Function _serialize_to_base64
#+BEGIN_SRC python
def _serialize_to_base64(value: str) -> str:
    # Encode the JSON string to URL-encoded format
    url_encoded = uri_encode_component(value)
    # Encode the URL-encoded string to Base64
    base64_encoded = base64.b64encode(url_encoded.encode()).decode()
    return base64_encoded

#+END_SRC
*** Function _serialize_list_to_base64
#+BEGIN_SRC python
def _serialize_list_to_base64(value: list[str]) -> list[str]:
    return [_serialize_to_base64(v) for v in value]

#+END_SRC
*** Function _del_none_or_empty
#+BEGIN_SRC python
def _del_none_or_empty(d: Any) -> Any:
    return {
        key: _del_none_or_empty(cast(Any, value))
        if isinstance(value, dict)
        else value
        for key, value in d.items()
        if value is not None and value != []
    }

#+END_SRC
