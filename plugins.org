 -*- Mode: POLY-ORG ;  indent-tabs-mode: nil; lsp-diagnostics-provider: :none -*- ---
#+Title: ast
#+OPTIONS: tex:verbatim toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+STARTUP: noindent
#+STARTUP: inlineimages
#+PROPERTY: literate-lang python
#+PROPERTY: literate-load yes
#+PROPERTY: literate-insert-header no
#+PROPERTY: header-args :results silent :session
#+PROPERTY: LITERATE_ORG_LANGUAGE python
#+PROPERTY: LITERATE_ORG_ROOT_MODULE marimo._plugins
#+PROPERTY: LITERATE_ORG_ROOT_MODULE_PATH ~/projects/marimo
#+PROPERTY: LITERATE_ORG_MODULE_CREATE_METHOD import
* utils
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.utils
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/utils.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TypeVar

#+END_SRC
** Assignment S = TypeVar("S")
#+BEGIN_SRC python
S = TypeVar("S")

#+END_SRC
** Assignment T = TypeVar("T")
#+BEGIN_SRC python
T = TypeVar("T")

#+END_SRC
** Function remove_none_values
#+BEGIN_SRC python
def remove_none_values(d: dict[S, T]) -> dict[S, T]:
    return {k: v for k, v in d.items() if v is not None}

#+END_SRC
* validators
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.validators
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/validators.py
:END:
** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import warnings
from typing import Any

from marimo._dependencies.dependencies import DependencyManager

#+END_SRC
** Function validate_range
#+BEGIN_SRC python
def validate_range(
    min_value: int | float | None,
    max_value: int | float | None,
) -> None:
    if min_value is not None:
        validate_number(min_value)
    if max_value is not None:
        validate_number(max_value)
    if (
        min_value is not None
        and max_value is not None
        and min_value > max_value
    ):
        raise ValueError("min/start must be less than or equal to max/end")

#+END_SRC
** Function validate_between_range
#+BEGIN_SRC python
def validate_between_range(
    value: int | float | None,
    min_value: int | float | None,
    max_value: int | float | None,
) -> None:
    if value is None:
        return

    validate_number(value)
    if min_value is not None and value < min_value:
        raise ValueError(f"Value must be greater than or equal to {min_value}")
    if max_value is not None and value > max_value:
        raise ValueError(f"Value must be less than or equal to {max_value}")

#+END_SRC
** Function validate_number
#+BEGIN_SRC python
def validate_number(
    value: Any,
) -> None:
    if not isinstance(value, (int, float)):
        raise TypeError("Value must be a number")

#+END_SRC
** Function warn_js_safe_number
#+BEGIN_SRC python
def warn_js_safe_number(*values: int | float | None) -> None:
    # Number.MAX_SAFE_INTEGER in JavaScript
    MAX_SAFE_INTEGER = 9007199254740991

    for value in values:
        # Skip None values
        if not isinstance(value, (int, float)):
            continue
        if abs(value) > MAX_SAFE_INTEGER:
            warnings.warn(
                f"Warning: Value {value} is outside the range of safe "
                "integers in JavaScript. This may cause precision issues.",
                stacklevel=3,
            )

#+END_SRC
** Function validate_no_integer_columns
#+BEGIN_SRC python
def validate_no_integer_columns(df: Any) -> None:
    if not DependencyManager.pandas.imported():
        return

    import pandas as pd

    if not isinstance(df, pd.DataFrame):
        return

    has_int_column_names = any(isinstance(name, int) for name in df.columns)
    if has_int_column_names:
        warnings.warn(
            "DataFrame has integer column names. This is not supported and can lead to bugs. "
            "Please use strings for column names.",
            stacklevel=3,
        )

#+END_SRC
* core
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.core
:END:
** json_encoder
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.core.json_encoder
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/core/json_encoder.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import dataclasses
import datetime
import json
from enum import Enum
from json import JSONEncoder
from typing import Any
from uuid import UUID

from marimo._dependencies.dependencies import DependencyManager

#+END_SRC
*** Class WebComponentEncoder
#+BEGIN_SRC python
class WebComponentEncoder(JSONEncoder):
    @staticmethod
    def json_dumps(o: Any) -> Any:
        """Serialize an object to JSON."""
        return json.dumps(o, cls=WebComponentEncoder)

    def default(self, o: Any) -> Any:
        """Override default method to handle additional types."""
        return self._convert_to_json(o)

    def _convert_to_json(self, o: Any) -> Any:
        """Convert various types to JSON serializable format."""
        # Primitives (most common case first for performance)
        if isinstance(o, (str, int, float, bool, type(None))):
            return o

        # Handle bytes objects
        if isinstance(o, bytes):
            try:
                return o.decode("utf-8")
            except UnicodeDecodeError:
                # Fallback to latin1
                return o.decode("latin1")

        # Handle datetime objects
        if isinstance(o, (datetime.datetime, datetime.date, datetime.time)):
            return o.isoformat()

        # Handle timedelta
        if isinstance(o, datetime.timedelta):
            return str(o)

        # Handle UUID
        if isinstance(o, UUID):
            return str(o)

        # Handle enum
        if isinstance(o, Enum):
            return o.name

        # Handle complex numbers
        if isinstance(o, complex):
            return str(o)

        # Handle iterable objects
        if isinstance(o, (set, frozenset)):
            return list(o)

        # If handled by default encoder
        if isinstance(o, (dict, list)):
            return o

        # Handle range
        if isinstance(o, range):
            return list(o)

        # Handle MIME objects
        if hasattr(o, "_mime_"):
            mimetype, data = o._mime_()
            return {"mimetype": mimetype, "data": data}

        # Handle dataclasses
        # Must come after MIME objects
        if dataclasses.is_dataclass(o):
            # We cannot use asdict since we need to recursively encode
            # the values
            return {
                field.name: self._convert_to_json(getattr(o, field.name))
                for field in dataclasses.fields(o)
            }

        # Handle numpy objects
        if DependencyManager.numpy.imported():
            import numpy as np

            if isinstance(o, (np.datetime64, np.complexfloating)):
                return str(o)
            if isinstance(o, np.integer):
                return int(o)
            if isinstance(o, np.floating):
                return float(o)
            if isinstance(o, np.ndarray):
                if any(
                    np.issubdtype(o.dtype, dtype)
                    for dtype in (np.datetime64, np.complexfloating)
                ):
                    return o.astype(str).tolist()
                return o.tolist()
            if isinstance(o, np.dtype):
                return str(o)

        # Handle pandas objects
        if DependencyManager.pandas.imported():
            import pandas as pd

            if isinstance(o, pd.DataFrame):
                return o.to_dict("records")
            if isinstance(o, pd.Series):
                return o.to_list()
            if isinstance(o, pd.Categorical):
                return o.tolist()
            if isinstance(
                o,
                (pd.CategoricalDtype, pd.Timestamp, pd.Timedelta, pd.Interval),
            ):
                return str(o)
            if isinstance(o, pd.TimedeltaIndex):
                return o.astype(str).tolist()

            # Catch-all for other pandas objects
            try:
                if isinstance(o, pd.core.base.PandasObject):  # type: ignore
                    return json.loads(o.to_json(date_format="iso"))
            except AttributeError:
                pass

        # Handle polars objects
        if DependencyManager.polars.imported():
            import polars as pl

            if isinstance(o, pl.DataFrame):
                return o.to_dict()

            if isinstance(o, pl.Series):
                return o.to_list()

        # Handle named tuples
        if isinstance(o, tuple) and hasattr(o, "_fields"):
            return {
                field: self._convert_to_json(getattr(o, field))
                for field in o._fields  # type: ignore
            }

        # Handle objects with __slots__
        if hasattr(o, "__slots__"):
            return {
                slot: self._convert_to_json(getattr(o, slot))
                for slot in o.__slots__  # type: ignore
                if hasattr(o, slot)
            }

        # Handle custom objects with __dict__
        if hasattr(o, "__dict__"):
            return {
                key: self._convert_to_json(value)
                for key, value in o.__dict__.items()
            }
        # Fallthrough to default encoder
        return JSONEncoder.default(self, o)

#+END_SRC
** media
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.core.media
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/core/media.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
import base64
import io
import mimetypes
from typing import Optional, Union

#+END_SRC
*** Function guess_mime_type
#+BEGIN_SRC python
def guess_mime_type(
    src: Union[str, bytes, io.BytesIO, io.BufferedReader, None],
) -> Optional[str]:
    """Guess the MIME type of a file."""
    if src is None:
        return None

    if isinstance(src, str) and src.startswith("data:"):
        return src.split(";")[0].split(":")[1]

    if isinstance(src, str):
        return mimetypes.guess_type(src)[0]

    if isinstance(src, io.FileIO):
        return mimetypes.guess_type(src.name)[0]

    if isinstance(src, io.BufferedReader):
        return mimetypes.guess_type(src.name)[0]

    return None

#+END_SRC
*** Function mime_type_to_ext
#+BEGIN_SRC python
def mime_type_to_ext(mime_type: str) -> Optional[str]:
    return mimetypes.guess_extension(mime_type, strict=False)

#+END_SRC
*** Function io_to_data_url
#+BEGIN_SRC python
def io_to_data_url(
    src: Union[str, bytes, io.BytesIO, None],
    fallback_mime_type: str,
) -> Optional[str]:
    """Convert a file-like object to a data URL."""
    if src is None:
        return None

    if isinstance(src, (io.BufferedIOBase, io.RawIOBase)):
        pos = src.tell()
        base64_string = base64.b64encode(src.read()).decode("utf-8")
        src.seek(pos)
        file_type = guess_mime_type(src) or fallback_mime_type
        return f"data:{file_type};base64,{base64_string}"

    if isinstance(src, bytes):
        base64_string = base64.b64encode(src).decode("utf-8")
        return f"data:{fallback_mime_type};base64,{base64_string}"

    return src

#+END_SRC
*** Function is_data_empty
#+BEGIN_SRC python
def is_data_empty(data: Union[str, bytes, io.BytesIO]) -> bool:
    """Check if a data object is empty."""
    if isinstance(data, str):
        return data == ""

    if isinstance(data, bytes):
        return data == b""

    if isinstance(data, io.BytesIO):
        return data.getbuffer().nbytes == 0

    return False

#+END_SRC
** web_component
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.core.web_component
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/core/web_component.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import json
import re
from html import escape, unescape
from typing import (
    TYPE_CHECKING,
    Mapping,
    Sequence,
    TypeVar,
    Union,
    cast,
)

#+END_SRC
*** Import statements
#+BEGIN_SRC python
if TYPE_CHECKING:
    import sys

    if sys.version_info < (3, 10):
        from typing_extensions import TypeAlias
    else:
        from typing import TypeAlias

    from typing import Optional

from marimo._output.md import _md
from marimo._output.mime import MIME
from marimo._plugins.core.json_encoder import WebComponentEncoder

#+END_SRC
*** Assignment JSONType
#+BEGIN_SRC python
JSONType: TypeAlias = Union[
    Mapping[str, "JSONType"],
    Sequence["JSONType"],
    str,
    int,
    float,
    bool,
    object,
    MIME,  # MIME is a JSONType since we have a custom JSONEncoder for it
    None,
]

#+END_SRC
*** Assignment S = TypeVar("S", bound=JSONType)
#+BEGIN_SRC python
S = TypeVar("S", bound=JSONType)

#+END_SRC
*** Function _build_attr
#+BEGIN_SRC python
def _build_attr(name: str, value: JSONType) -> str:
    processed = escape(json.dumps(value, cls=WebComponentEncoder))
    # manual escapes for things html.escape doesn't escape
    #
    # - backslashes, when unescaped can lead to problems
    # when embedding in markdown
    # - dollar sign, when unescaped can incorrectly be recognized as
    # latex delimiter when embedding into markdown
    processed = processed.replace("\\", "&#92;").replace("$", "&#36;")
    return f"data-{name}='{processed}'"

#+END_SRC
*** Function build_ui_plugin
#+BEGIN_SRC python
def build_ui_plugin(
    component_name: str,
    initial_value: Optional[JSONType],
    label: Optional[str],
    args: dict[str, JSONType],
    slotted_html: str = "",
) -> str:
    """
    Build HTML for a UI (stateful) plugin.

    Args:
    ----
    component_name: tag name of the component
    initial_value: JSON-serializable initial value of the component
    label: markdown string that component may use a text label
    args: mapping from arg names to JSON-serializable value
    slotted_html: HTML to slot in the component

    Returns:
    -------
    HTML text for the component
    """
    if "initial-value" in args:
        raise ValueError("initial-value is a reserved argument.")
    if "label" in args:
        raise ValueError("label is a reserved argument.")

    attrs: list[str] = [_build_attr("initial-value", initial_value)]
    if label is not None and label:
        attrs.append(_build_attr("label", _md(label).text))
    else:
        attrs.append(_build_attr("label", None))

    for name, value in args.items():
        if value is not None:
            attrs.append(_build_attr(name, value))

    return (
        f"<{component_name} {' '.join(attrs)}>"
        f"{slotted_html}"
        f"</{component_name}>"
    )

#+END_SRC
*** Function build_stateless_plugin
#+BEGIN_SRC python
def build_stateless_plugin(
    component_name: str,
    args: dict[str, JSONType],
    slotted_html: str = "",
) -> str:
    """
    Build HTML for a stateless plugin.

    Args:
    ----
    component_name: tag name of the component
    args: mapping from arg names to JSON-serializable value
    slotted_html: HTML to slot in the component

    Returns:
    -------
    HTML text for the component
    """
    attrs = [_build_attr(name, value) for name, value in args.items()]
    return (
        f"<{component_name} {' '.join(attrs)}>"
        f"{slotted_html}"
        f"</{component_name}>"
    )

#+END_SRC
*** Function parse_initial_value
#+BEGIN_SRC python
def parse_initial_value(text: str) -> JSONType:
    """Get initial value from HTML for a UI element."""
    match = re.search("data-initial-value='(.*?)'", text)
    if match is None:
        raise ValueError("Invalid component HTML: ", text)
    return cast(JSONType, json.loads(unescape(match.groups()[0])))

#+END_SRC
* stateless
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless
:END:
** __init__
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.__init__
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/__init__.py
:END:
*** Comment
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.

#+END_SRC
** accordion
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.accordion
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/accordion.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from marimo._output.formatting import as_html
from marimo._output.hypertext import Html
from marimo._output.md import md
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import build_stateless_plugin
from marimo._plugins.stateless.lazy import lazy as lazy_ui

#+END_SRC
*** @mddoc: Function accordion
#+BEGIN_SRC python
@mddoc
def accordion(
    items: dict[str, object], multiple: bool = False, lazy: bool = False
) -> Html:
    """
    Accordion of one or more items.

    **Example.**

    ```python3
    mo.accordion(
        {"Tip": "Use accordions to let users reveal and hide content."}
    )
    ```

    Accordion content can be lazily loaded:

    ```python3
    mo.accordion({"View total": expensive_item}, lazy=True)
    ```

    where `expensive_item` is the item to render, or a callable that
    returns the item to render.

    **Args.**

    - `items`: a dictionary of item names to item content; strings are
      interpreted as markdown
    - `multiple`: whether to allow multiple items to be open simultaneously
    - `lazy`: a boolean, whether to lazily load the accordion content.
              This is a convenience that wraps each accordion in a `mo.lazy`
              component.

    **Returns.**

    - An `Html` object.
    """

    def render_content(tab: object) -> str:
        if lazy:
            return lazy_ui(tab).text
        if isinstance(tab, str):
            return md(tab).text
        return as_html(tab).text

    item_labels = list(md(label).text for label in items.keys())
    item_content = "".join(
        ["<div>" + render_content(item) + "</div>" for item in items.values()]
    )
    return Html(
        build_stateless_plugin(
            component_name="marimo-accordion",
            args={"labels": item_labels, "multiple": multiple},
            slotted_html=item_content,
        )
    )

#+END_SRC
** audio
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.audio
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/audio.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import io
import os
from typing import Optional, Union

import marimo._output.data.data as mo_data
from marimo._output.builder import h
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.media import io_to_data_url

#+END_SRC
*** @mddoc: Function audio
#+BEGIN_SRC python
@mddoc
def audio(
    src: Union[str, io.BytesIO],
) -> Html:
    """Render an audio file as HTML.

    **Example.**

    ```python3
    mo.audio(
        src="https://upload.wikimedia.org/wikipedia/commons/8/8c/Ivan_Ili%C4%87-Chopin_-_Prelude_no._1_in_C_major.ogg"
    )

    mo.audio(src="path/to/local/file.wav")
    ```

    **Args.**

    - `src`: a path or URL to an audio file, bytes,
        or a file-like object opened in binary mode

    **Returns.**

    An audio player as an `Html` object.
    """
    resolved_src: Optional[str]

    if isinstance(src, (io.BufferedReader, io.BytesIO)):
        pos = src.tell()
        src.seek(0)
        resolved_src = mo_data.audio(src.read()).url
        src.seek(pos)
    elif isinstance(src, bytes):
        resolved_src = mo_data.audio(src).url
    elif isinstance(src, str) and os.path.isfile(os.path.expanduser(src)):
        src = os.path.expanduser(src)
        with open(src, "rb") as f:
            resolved_src = mo_data.audio(
                f.read(), ext=os.path.splitext(src)[1]
            ).url
    else:
        resolved_src = io_to_data_url(src, fallback_mime_type="audio/wav")

    return Html(h.audio(src=resolved_src, controls=True))

#+END_SRC
** callout
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.callout
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/callout.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Literal

from marimo._output.formatting import as_html
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import build_stateless_plugin

#+END_SRC
*** @mddoc: Function callout
#+BEGIN_SRC python
@mddoc
def callout(
    value: object,
    kind: Literal["neutral", "warn", "success", "info", "danger"] = "neutral",
) -> Html:
    """Build a callout output.

    **Args.**

    - `value`: A value to render in the callout
    - `kind`: The kind of callout (affects styling).

    **Returns.**

    - An HTML object.
    """
    return Html(
        build_stateless_plugin(
            component_name="marimo-callout-output",
            args={"html": as_html(value).text, "kind": kind},
        )
    )

#+END_SRC
** carousel
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.carousel
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/carousel.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Sequence

from marimo._output.formatting import as_html
from marimo._output.hypertext import Html
from marimo._output.md import md
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import build_stateless_plugin

#+END_SRC
*** @mddoc: Function carousel
#+BEGIN_SRC python
@mddoc
def carousel(
    items: Sequence[object],
) -> Html:
    """Create a carousel of items.

    **Example.**

    ```python3
    mo.carousel([mo.md("..."), mo.ui.text_area()])
    ```

    **Args.**

    - `items`: A list of items.

    **Returns.**

    - An `Html` object.
    """
    item_content = "".join(
        [
            (md(item).text if isinstance(item, str) else as_html(item).text)
            for item in items
        ]
    )

    return Html(
        build_stateless_plugin(
            component_name="marimo-carousel",
            args={},
            slotted_html=item_content,
        )
    )

#+END_SRC
** download
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.download
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/download.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import io
from typing import Optional, Union

import marimo._output.data.data as mo_data
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.media import (
    guess_mime_type,
    is_data_empty,
    mime_type_to_ext,
)
from marimo._plugins.core.web_component import build_stateless_plugin

#+END_SRC
*** @mddoc: Function download
#+BEGIN_SRC python
@mddoc
def download(
    data: Union[str, bytes, io.BytesIO, io.BufferedReader],
    filename: Optional[str] = None,
    mimetype: Optional[str] = None,
    disabled: bool = False,
    *,
    label: str = "Download",
) -> Html:
    """
    Show a download button for a url, bytes, or file-like object.

    **Examples.**

    ```python
    download_txt = mo.download(
        data="Hello, world!".encode("utf-8"),
        filename="hello.txt",
        mimetype="text/plain",
    )

    download_image = mo.download(
        data=open("hello.png", "rb"),
    )
    ```

    **Args.**

    - `data`: The data to download. Can be a string (interpreted as
        a URL), bytes, or a file opened in binary mode.
    - `filename`: The name of the file to download.
        If not provided, the name will be guessed from the data.
    - `mimetype`: The mimetype of the file to download, for example,
        (e.g. "text/csv", "image/png"). If not provided,
        the mimetype will be guessed from the filename.

    **Returns.**

    An `Html` object for a download button.
    """

    # Convert to bytes right away since can only be read once
    if isinstance(data, io.BufferedReader):
        filename = filename or data.name
        data.seek(0)
        data = data.read()

    # name used to guess mimetype
    name_for_mime = data if isinstance(data, str) else filename
    resolved_mimetype = (
        mimetype or guess_mime_type(name_for_mime) or "text/plain"
    )
    ext = mime_type_to_ext(resolved_mimetype) or "txt"
    disabled = disabled or is_data_empty(data)

    # create a virtual file to avoid loading the data in the browser
    file = mo_data.any_data(data, ext=ext)

    return Html(
        build_stateless_plugin(
            component_name="marimo-download",
            args={
                "data": file.url,
                "filename": filename,
                "disabled": disabled,
                "label": label,
            },
        )
    )

#+END_SRC
** flex
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.flex
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/flex.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING, Literal, Optional

from marimo._output.builder import h
from marimo._output.formatting import as_html
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._output.utils import create_style

#+END_SRC
*** Function _flex
#+BEGIN_SRC python
if TYPE_CHECKING:
    from collections.abc import Sequence


def _flex(
    items: Sequence[object],
    direction: Literal["row", "column"],
    justify: Literal[
        "start", "center", "end", "space-between", "space-around"
    ],
    align: Optional[Literal["start", "end", "center", "stretch"]],
    wrap: bool,
    gap: float,
    child_flexes: Optional[Sequence[Optional[float]]],
) -> Html:
    justify_content_map = {
        "start": "flex-start",
        "center": "center",
        "end": "flex-end",
        "space-between": "space-between",
        "space-around": "space-around",
        None: "space-between",
    }
    align_items_map = {
        "start": "flex-start",
        "center": "center",
        "end": "flex-end",
        "stretch": "stretch",
        None: "normal",
    }
    style = create_style(
        {
            "display": "flex",
            "flex": "1",
            "flex-direction": direction,
            "justify-content": justify_content_map[justify],
            "align-items": align_items_map[align],
            "flex-wrap": "wrap" if wrap else "nowrap",
            "gap": f"{gap}rem",
        }
    )

    def create_style_for_item(idx: int) -> Optional[str]:
        if child_flexes is None:
            return ""
        child_flex = child_flexes[idx]
        if child_flex is None:
            return ""
        return create_style({"flex": f"{child_flex}"})

    grid_items = [
        h.div(as_html(item).text, style=create_style_for_item(i))
        for i, item in enumerate(items)
    ]
    return Html(h.div(grid_items, style=style))

#+END_SRC
*** @mddoc: Function vstack
#+BEGIN_SRC python
@mddoc
def vstack(
    items: Sequence[object],
    *,
    align: Optional[Literal["start", "end", "center", "stretch"]] = None,
    justify: Literal[
        "start", "center", "end", "space-between", "space-around"
    ] = "start",
    gap: float = 0.5,
    heights: Optional[Literal["equal"] | Sequence[float]] = None,
) -> Html:
    """Stack items vertically, in a column.

    Combine with `hstack` to build a grid of items.

    **Example.**

    ```python3
    # Build a column of items
    mo.vstack([mo.md("..."), mo.ui.text_area()])
    ```

    ```python3
    # Build a grid.
    mo.vstack(
        [
            mo.hstack([mo.md("..."), mo.ui.text_area()]),
            mo.hstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),
        ]
    )
    ```

    **Args.**

    - `items`: A list of items.
    - `align`: Align items horizontally: start, end, center, or stretch.
    - `justify`: Justify items vertically: start, center, end,
    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.
    - `heights`: "equal" to give items equal height;
        or a list of relative heights with same length as `items`,
        eg, [1, 2] means the second item is twice as tall
        as the first; or `None` for a sensible default

    **Returns.**

    - An `Html` object.
    """
    return _flex(
        items,
        direction="column",
        justify=justify,
        align=align,
        wrap=False,
        gap=gap,
        child_flexes=[1 for _ in range(len(items))]
        if heights == "equal"
        else heights,
    )

#+END_SRC
*** @mddoc: Function hstack
#+BEGIN_SRC python
@mddoc
def hstack(
    items: Sequence[object],
    *,
    justify: Literal[
        "start", "center", "end", "space-between", "space-around"
    ] = "space-between",
    align: Optional[Literal["start", "end", "center", "stretch"]] = None,
    wrap: bool = False,
    gap: float = 0.5,
    widths: Optional[Literal["equal"] | Sequence[float]] = None,
) -> Html:
    """Stack items horizontally, in a row.

    Combine with `vstack` to build a grid.

    **Example.**

    ```python3
    # Build a row of items
    mo.hstack([mo.md("..."), mo.ui.text_area()])
    ```

    ```python3
    # Build a grid.
    mo.hstack(
        [
            mo.vstack([mo.md("..."), mo.ui.text_area()]),
            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),
        ]
    )
    ```

    **Args.**

    - `items`: A list of items.
    - `justify`: Justify items horizontally: start, center, end,
        space-between, or space-around.
    - `align`: Align items vertically: start, end, center, or stretch.
    - `wrap`: Wrap items or not.
    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.
    - `widths`: "equal" to give items equal width; or a list of relative widths
      with same length as `items`, eg, [1, 2] means the second item is twice as
      wide as the first; or `None` for a sensible default

    **Returns.**

    - An `Html` object.
    """
    return _flex(
        items,
        direction="row",
        justify=justify,
        align=align,
        wrap=wrap,
        gap=gap,
        child_flexes=[1 for _ in range(len(items))]
        if widths == "equal"
        else widths,
    )

#+END_SRC
*** Function _spaced
#+BEGIN_SRC python
# TODO(akshayka): Implement as a stateless plugin in frontend.
# Unused, but may be nice to keep around in case we want to add `mo.grid`
def _spaced(
    items: Sequence[object],
    justify: Literal["left", "right", "center", "normal"] = "center",
    items_per_row: Optional[int] = None,
    column_gap: float = 1,
    row_gap: float = 1,
) -> Html:
    """Space items evenly in row-major order.

    A grid built with this function has a fixed number of items per row.
    For more flexibility, use `hstack` and `vstack`.

    **Args.**

    - `items`: Items to arrange
    - `justify`: Justify items normally, left, right, or center.
    - `items_per_row`: Number of items to place in each row
    - `column_gap`: Minimum gap in rem between columns
    - `row_gap`: Minimum gap in rem between rows

    **Returns.**

    - An `Html` object.
    """
    items_per_row = len(items) if items_per_row is None else items_per_row
    style = create_style(
        {
            "display": "grid",
            "grid-template-columns": f"repeat({items_per_row}, 1fr)",
            "column-gap": f"{column_gap}rem",
            "row-gap": f"{row_gap}rem",
            "justify-items": justify,
            "overflow": "auto",
        }
    )
    grid_items = [h.div(as_html(item).text) for item in items]
    return Html(h.div(grid_items, style=style))

#+END_SRC
** icon
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.icon
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/icon.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Literal, Optional, Union

from marimo._output.builder import h
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._output.utils import create_style

#+END_SRC
*** @mddoc: Function icon
#+BEGIN_SRC python
@mddoc
def icon(
    icon_name: str,
    *,
    size: Optional[int] = None,
    color: Optional[str] = None,
    inline: bool = True,
    flip: Optional[
        Literal["horizontal", "vertical", "horizontal,vertical"]
    ] = None,
    rotate: Optional[Literal["90deg", "180deg", "270deg"]] = None,
    style: Optional[dict[str, Union[str, int, float, None]]] = None,
) -> Html:
    """
    Displays an icon. These icons are referenced by name from the
    [Iconify](https://iconify.design/) library.

    They are named in the format `icon-set:icon-name`, e.g.
    `lucide:leaf`.

    Icons are lazily loaded from a CDN, so they will not be loaded when
    not connected to the internet.

    These can be used in buttons, tabs, and other UI elements.

    **Examples.**

    ```python
    mo.md(f"# {mo.icon('lucide:leaf')} Leaf")

    mo.ui.button(
        label=f"{mo.icon('lucide:rocket')} Submit",
    )
    ```

    **Args.**

    - `icon_name`: the name of the icon to display
    - `size`: the size of the icon in pixels
    - `color`: the color of the icon
    - `inline`: whether to display the icon inline or as a block element
    - `flip`: whether to flip the icon horizontally, vertically, or both
    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees
    - `style`: a dictionary of CSS styles to apply to the icon

    **Returns.**

    - An `Html` object.
    """

    if style is None:
        style = {}

    if color is not None:
        style["color"] = color

    return Html(
        h.component(
            "iconify-icon",
            [
                ("icon", icon_name),
                ("width", _space_to_string(size)),
                ("height", _space_to_string(size)),
                ("inline", "" if inline else None),
                ("flip", flip),
                ("rotate", rotate),
                ("style", create_style(style)),
            ],
        )
    )

#+END_SRC
*** Function _space_to_string
#+BEGIN_SRC python
def _space_to_string(value: Union[str, int, float, None]) -> Optional[str]:
    if value is None:
        return None
    if isinstance(value, str):
        return value
    else:
        return f"{value}px"

#+END_SRC
** image
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.image
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/image.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import io
import os
from typing import Any, Optional, Union

import marimo._output.data.data as mo_data
from marimo._dependencies.dependencies import DependencyManager
from marimo._output.builder import h
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._output.utils import create_style, normalize_dimension
from marimo._plugins.core.media import io_to_data_url

#+END_SRC
*** Assignment Image = Union[str, bytes, io.BytesIO, io.BufferedReader]
#+BEGIN_SRC python
Image = Union[str, bytes, io.BytesIO, io.BufferedReader]

#+END_SRC
*** Assignment Tensor = Any
#+BEGIN_SRC python
# Union[list, torch.Tensor, jax.numpy.ndarray,
#             np.ndarray, scipy.sparse.spmatrix]
Tensor = Any

#+END_SRC
*** Assignment ImageLike = Union[Image, Tensor]
#+BEGIN_SRC python
ImageLike = Union[Image, Tensor]

#+END_SRC
*** Function _normalize_image
#+BEGIN_SRC python
def _normalize_image(src: ImageLike) -> Image:
    """
    Normalize an image-like object to a standard format.

    This function handles a variety of input types, including lists, arrays,
    and tensors, and converts them to a BytesIO object representing a PNG
    image.

    Typical convention for handling images is to use `PIL`, which is exactly
    what `matplotlib` does behind the scenes. `PIL` requires a `ndarray`
    (validated with the numpy specific `__array_interface__` attribute). In
    turn, numpy can cast lists, and objects with the `__array__` method (like
    jax, torch tensors). `scipy.sparse` breaks this convention but does have a
    `toarray` method, which is general enough that a specific check is
    performed here.

    **Args.**

    - `src`: An image-like object. This can be a list, array, tensor, or a
        file-like object.

    **Returns.**

    A BytesIO object or other Image type.

    **Raises.**

    - `ModuleNotFoundError`: If the required `PIL` or `numpy` packages are not
        available.
    - `ValueError`: If the input is not a valid image-like object.
    """
    if (
        isinstance(src, list)
        or hasattr(src, "__array__")
        or hasattr(src, "toarray")
    ):
        DependencyManager.pillow.require(
            "to render images from arrays in `mo.image`"
        )
        from PIL import Image as _Image

        if not hasattr(src, "__array_interface__"):
            DependencyManager.numpy.require(
                "to render images from generic arrays in `mo.image`"
            )
            import numpy

            # Capture those sparse cases
            if hasattr(src, "toarray"):
                src = src.toarray()
            src = numpy.array(src)
        src = (src - src.min()) / (src.max() - src.min()) * 255.0
        img = _Image.fromarray(src.astype("uint8"))
        # io.BytesIO is one of the Image types.
        normalized_src: Image = io.BytesIO()
        img.save(normalized_src, format="PNG")
        return normalized_src
    # Verify that this is a image object
    if not isinstance(src, (str, bytes, io.BytesIO, io.BufferedReader)):
        raise ValueError(
            f"Expected an image object, but got {type(src)} instead."
        )
    return src

#+END_SRC
*** @mddoc: Function image
#+BEGIN_SRC python
@mddoc
def image(
    src: ImageLike,
    alt: Optional[str] = None,
    width: Optional[Union[int, str]] = None,
    height: Optional[Union[int, str]] = None,
    rounded: bool = False,
    style: Optional[dict[str, Any]] = None,
    caption: Optional[str] = None,
) -> Html:
    """Render an image as HTML.

    **Examples.**

    ```python3
    # Render an image from a local file
    mo.image(src="path/to/image.png")
    ```

    ```python3
    # Render an image from a URL
    mo.image(
        src="https://marimo.io/logo.png",
        alt="Marimo logo",
        width=100,
        height=100,
        rounded=True,
        caption="Marimo logo",
    )
    ```

    **Args.**

    - `src`: a path or URL to an image, a file-like object
        (opened in binary mode), or array-like object.
    - `alt`: the alt text of the image
    - `width`: the width of the image in pixels or a string with units
    - `height`: the height of the image in pixels or a string with units
    - `rounded`: whether to round the corners of the image
    - `style`: a dictionary of CSS styles to apply to the image
    - `caption`: the caption of the image

    **Returns.**

    `Html` object
    """
    # Convert to virtual file
    resolved_src: Optional[str]
    src = _normalize_image(src)
    # TODO: Consider downsampling here. This is something matplotlib does
    # implicitly, and can potentially remove the bottle-neck of very large
    # images.
    if isinstance(src, io.BufferedReader) or isinstance(src, io.BytesIO):
        src.seek(0)
        resolved_src = mo_data.image(src.read()).url
    elif isinstance(src, bytes):
        resolved_src = mo_data.image(src).url
    elif isinstance(src, str) and os.path.isfile(
        expanded_path := os.path.expanduser(src)
    ):
        with open(expanded_path, "rb") as f:
            resolved_src = mo_data.image(
                f.read(), ext=os.path.splitext(expanded_path)[1]
            ).url
    else:
        resolved_src = io_to_data_url(src, fallback_mime_type="image/png")

    styles = create_style(
        {
            "width": normalize_dimension(width),
            "height": normalize_dimension(height),
            "border-radius": "4px" if rounded else None,
            **(style or {}),
        }
    )
    img = h.img(src=resolved_src, alt=alt, style=styles)
    if caption is not None:
        return Html(
            h.figure(
                [
                    img,
                    h.figcaption(
                        [caption],
                        style="color: var(--muted-foreground); "
                        "text-align: center; margin-top: 0.5rem;",
                    ),
                ],
                style="display: flex; flex-direction: column;",
            )
        )
    return Html(img)

#+END_SRC
** json_output
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.json_output
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/json_output.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Optional

from marimo._output.hypertext import Html
from marimo._plugins.core.web_component import JSONType, build_stateless_plugin

#+END_SRC
*** Function json_output
#+BEGIN_SRC python
def json_output(json_data: JSONType, name: Optional[str] = None) -> Html:
    """Build a json output element.

    Args:
    -----
    json_data: JSON-serializable data to display
    name: optional text label

    Returns:
    --------
    A string of HTML for a JSON output element.
    """
    return Html(
        build_stateless_plugin(
            component_name="marimo-json-output",
            args=(
                {"json-data": json_data, "name": name}
                if name is not None
                else {"json-data": json_data}
            ),
        )
    )

#+END_SRC
** lazy
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.lazy
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/lazy.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import asyncio
from dataclasses import dataclass
from typing import Callable, Coroutine, Final, Union

from marimo._output.formatting import as_html
from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import UIElement
from marimo._runtime.functions import EmptyArgs, Function

#+END_SRC
*** @dataclass: Class LoadResponse
#+BEGIN_SRC python
@dataclass
class LoadResponse:
    html: str

#+END_SRC
*** @mddoc: Class lazy
#+BEGIN_SRC python
@mddoc
class lazy(UIElement[bool, bool]):
    """Lazy load a component until it is visible.

    Use `mo.lazy` to defer rendering of an item until it's visible. This is
    useful for loading expensive components only when they are needed, e.g.,
    only when an accordion or tab is opened.

    The argument to `mo.lazy` can be an object to render lazily, or a function
    that returns the object to render (that is, functions are lazily
    evaluated). The function can be synchronous or asynchronous.
    Using a function is useful when the item to render is
    the result of a database query or some other expensive operation.

    **Examples.**

    Create a lazy-loaded tab:

    ```python
    tabs = mo.ui.tabs(
        {"Overview": tab1, "Charts": mo.lazy(expensive_component)}
    )
    ```

    Create a lazy-loaded accordion:

    ```python
    accordion = mo.ui.accordion({"Charts": mo.lazy(expensive_component)})
    ```

    Usage with async functions:

    ```python
    async def expensive_component(): ...


    mo.lazy(expensive_component)
    ```


    **Initialization Args.**

    - `element`: object or callable that returns content to be lazily loaded
    - `show_loading_indicator`: a boolean, whether to show a loading
        indicator while the content is being loaded.
        Default is `False`.
    """

    _name: Final[str] = "marimo-lazy"

    def __init__(
        self,
        element: Union[
            Callable[[], object],
            object,
            Callable[[], Coroutine[None, None, object]],
        ],
        show_loading_indicator: bool = False,
    ) -> None:
        self._element = element

        super().__init__(
            component_name=self._name,
            initial_value=False,
            label="",
            args={
                "show-loading-indicator": show_loading_indicator,
            },
            on_change=None,
            functions=(
                Function(
                    name=self.load.__name__,
                    arg_cls=EmptyArgs,
                    function=self.load,
                ),
            ),
        )

    def _convert_value(self, value: bool) -> bool:
        return value

    async def load(self, _args: EmptyArgs) -> LoadResponse:
        if callable(self._element) and not isinstance(
            self._element, UIElement
        ):
            el = self._element()
            if asyncio.iscoroutine(el):
                el = await el
            return LoadResponse(html=as_html(el).text)
        else:
            return LoadResponse(html=as_html(self._element).text)

#+END_SRC
** mermaid
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.mermaid
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/mermaid.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import build_stateless_plugin

#+END_SRC
*** @mddoc: Function mermaid
#+BEGIN_SRC python
@mddoc
def mermaid(diagram: str) -> Html:
    """
    Render a diagram with Mermaid.

    **Examples.**

    ```python
    diagram = '''
    graph LR
        A[Square Rect] -- Link text --> B((Circle))
        A --> C(Round Rect)
        B --> D{Rhombus}
        C --> D
    '''
    mo.mermaid(diagram)
    ```

    Mermaid is a tool for making diagrams such as flow charts and graphs. See
    the [Mermaid documentation](https://github.com/mermaid-js/mermaid#readme)
    for details.

    **Args.**

    - `diagram`: a string containing a Mermaid diagram

    **Returns.**

    - An `Html` object.
    """
    return Html(
        build_stateless_plugin(
            component_name="marimo-mermaid",
            args={"diagram": diagram},
        )
    )

#+END_SRC
** mime
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.mime
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/mime.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from marimo._output.hypertext import Html
from marimo._plugins.core.web_component import JSONType, build_stateless_plugin

#+END_SRC
*** Function mime_renderer
#+BEGIN_SRC python
def mime_renderer(mime: str, data: JSONType) -> Html:
    """Build a mime renderer element.

    Args:
    -----
    mime: MIME type of the data
    data: data to display

    Returns:
    --------
    A string of HTML for a mime renderer element.
    """
    return Html(
        build_stateless_plugin(
            component_name="marimo-mime-renderer",
            args=({"mime": mime, "data": data}),
        )
    )

#+END_SRC
** nav_menu
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.nav_menu
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/nav_menu.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from dataclasses import asdict, dataclass
from typing import List, Literal, Optional, Union, cast

from marimo._output.hypertext import Html
from marimo._output.md import md
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType, build_stateless_plugin

#+END_SRC
*** @mddoc: Function nav_menu
#+BEGIN_SRC python
@mddoc
def nav_menu(
    menu: dict[str, JSONType],
    *,
    orientation: Literal["horizontal", "vertical"] = "horizontal",
) -> Html:
    """
    Navigation menu component.

    This is useful for creating a navigation menu with hyperlinks,
    most used when creating multi-page applications, with
    `marimo.create_asgi_app` ([docs](https://docs.marimo.io/guides/deploying/programmatically.html)).

    **Examples.**

    ```python
    nav_menu = mo.nav_menu(
        {
            "/overview": "Overview",
            "/sales": f"{mo.icon('lucide:shopping-cart')} Sales",
            "/products": f"{mo.icon('lucide:package')} Products",
        }
    )
    ```

    # You can also nest dictionaries to create submenus
    ```python
    nav_menu = mo.nav_menu(
        {
            "/overview": "Overview",
            "Sales": {
                "/sales": "Overview",
                "/sales/invoices": {
                    "label": "Invoices",
                    "description": "View invoices",
                },
                "/sales/customers": {
                    "label": "Customers",
                    "description": "View customers",
                },
            },
        }
    )
    ```

    **Args.**

    - `menu`: a dictionary of tab names to tab content;
        the content can also be nested dictionaries (one level deep)
        strings are interpreted as markdown

    **Returns.**

    - An `Html` object.
    """

    menu_items = _build_and_validate_menu(menu)

    return Html(
        build_stateless_plugin(
            component_name="marimo-nav-menu",
            args={
                "items": asdict(menu_items)["items"],
                "orientation": orientation,
            },
        )
    )

#+END_SRC
*** @dataclass: Class NavMenu
#+BEGIN_SRC python
@dataclass
class NavMenu:
    items: List[Union[NavMenuItemLink, NavMenuItemGroup]]

#+END_SRC
*** @dataclass: Class NavMenuItemLink
#+BEGIN_SRC python
@dataclass
class NavMenuItemLink:
    label: str
    href: str
    description: Optional[str] = None

#+END_SRC
*** @dataclass: Class NavMenuItemGroup
#+BEGIN_SRC python
@dataclass
class NavMenuItemGroup:
    label: str
    items: List[NavMenuItemLink]

#+END_SRC
*** Function _build_and_validate_menu
#+BEGIN_SRC python
def _build_and_validate_menu(menu: dict[str, JSONType]) -> NavMenu:
    def validate_href(href: str) -> str:
        if not isinstance(href, str):
            raise ValueError(f"Invalid href: {href}, expected string")
        if (
            href.startswith("/")
            or href.startswith("#")
            or href.startswith("http")
        ):
            return href
        raise ValueError(f"Invalid href: {href}, must start with / or #")

    items: List[Union[NavMenuItemLink, NavMenuItemGroup]] = []
    for k, v in menu.items():
        if isinstance(v, str):
            items.append(
                NavMenuItemLink(label=md(v).text, href=validate_href(k))
            )
        elif isinstance(v, dict):
            subitems: List[NavMenuItemLink] = []
            for kk, vv in v.items():
                if isinstance(vv, str):
                    subitems.append(
                        NavMenuItemLink(
                            label=md(vv).text, href=validate_href(kk)
                        )
                    )
                elif isinstance(vv, dict):
                    label = vv.get("label")
                    description = vv.get("description", None)
                    if not label or not isinstance(label, str):
                        raise ValueError(
                            f"Invalid submenu item: {vv}, missing label"
                        )
                    if description and not isinstance(description, str):
                        raise ValueError(
                            f"Invalid submenu item: {vv}, expected"
                            " string for description"
                        )
                    subitems.append(
                        NavMenuItemLink(
                            label=md(label).text,
                            href=validate_href(kk),
                            description=(
                                md(cast(str, description)).text
                                if description
                                else None
                            ),
                        )
                    )
                else:
                    raise ValueError(
                        f"Invalid submenu item: {vv}, expected string, or dict"
                    )
            items.append(NavMenuItemGroup(label=md(k).text, items=subitems))
        else:
            raise ValueError(
                f"Invalid menu item: {v}, expected string or dict"
            )
    return NavMenu(items=items)

#+END_SRC
** pdf
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.pdf
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/pdf.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING, Any, Optional, Union

import marimo._output.data.data as mo_data
from marimo._output.builder import h
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._output.utils import create_style

#+END_SRC
*** @mddoc: Function pdf
#+BEGIN_SRC python
if TYPE_CHECKING:
    import io


@mddoc
def pdf(
    src: Union[str, io.IOBase],
    initial_page: Optional[int] = None,
    width: Optional[Union[int, str]] = "100%",
    height: Optional[Union[int, str]] = "70vh",  # arbitrary, but good default
    style: Optional[dict[str, Any]] = None,
) -> Html:
    """Render a PDF.

    This currently uses the native browser PDF viewer,
    but may be replaced with a custom viewer.

    **Example.**

    ```python3
    mo.pdf(
        src="https://arxiv.org/pdf/2104.00282.pdf",
        width="100%",
        height="50vh",
    )

    with open("paper.pdf", "rb") as file:
        mo.pdf(src=file)
    ```

    **Args.**

    - `src`: the URL of the pdf or a file-like object
    - `initial_page`: the page to open the pdf to.
        only works if `src` is a URL
    - `width`: the width of the pdf
    - `height`: the height of the pdf. for a percentage
        of the user's viewport, use a string like `"50vh"`
    - `style`: a dictionary of CSS styles to apply to the pdf

    **Returns.**

    `Html` object
    """
    resolved_src = src if isinstance(src, str) else mo_data.pdf(src.read()).url
    if initial_page is not None and isinstance(src, str):
        # FitV is "fit to vertical"
        resolved_src += f"#page={initial_page}&view=FitV"
    styles = create_style(
        {
            "border-radius": "4px",
            "width": width,
            "height": height,
            **(style or {}),
        }
    )
    return Html(
        h.iframe(
            src=resolved_src,
            style=styles,
        )
    )

#+END_SRC
** plain_text
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.plain_text
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/plain_text.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from marimo._output.builder import h
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._output.utils import create_style

#+END_SRC
*** @mddoc: Function plain_text
#+BEGIN_SRC python
@mddoc
def plain_text(text: str) -> Html:
    """Text that's fixed-width, with spaces and newlines preserved.

    **Args.**

    - `text`: text to output

    **Returns.**

    An `Html` object representing the text.
    """
    styles = create_style({"font-size": "12px"})
    img = h.pre(child=text, style=styles)
    return Html(img)

#+END_SRC
** routes
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.routes
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/routes.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Callable, Coroutine, Final, Union

from marimo._output.formatting import as_html
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.stateless import lazy
from marimo._plugins.ui._core.ui_element import UIElement

#+END_SRC
*** @mddoc: Class routes
#+BEGIN_SRC python
@mddoc
class routes(UIElement[str, str]):
    """
    Renders a list of routes that are switched based on the
    URL path.

    Routes currently don't support nested routes, or
    dynamic routes (e.g. `#/user/:id`). If you'd like to
    see these features, please let us know on GitHub:
    https://github.com/marimo-team/marimo/issues

    For a simple-page-application (SPA) experience, you
    should use hash-based routing. For example, prefix
    your routes with `#/`.

    If you are using a multi-page-application (MPA) with
    `marimo.create_asgi_app`, you should use path-based routing.
    For example, prefix your routes with `/`.

    **Examples.**

    ```python
    mo.routes(
        {
            "#/": render_home,
            "#/about": render_about,
            "#/contact": render_contact,
            mo.routes.CATCH_ALL: render_home,
        }
    )
    ```

    **Args.**

    - `routes`: a dictionary of routes, where the key is the URL path
      and the value is a function that returns the content to display.

    **Returns.**

    - An `Html` object.
    """

    _name: Final[str] = "marimo-routes"

    CATCH_ALL = "{/*path}"
    DEFAULT = "/"

    def __init__(
        self,
        routes: dict[
            str,
            Union[
                Callable[[], object],
                Callable[[], Coroutine[None, None, object]],
                object,
            ],
        ],
    ) -> None:
        # For functions, wrap in lazy
        children: list[Html] = []
        for _, content in routes.items():
            if callable(content):
                children.append(lazy.lazy(content))
            else:
                children.append(as_html(content))

        self._children = children
        text = "".join([child.text for child in children])

        super().__init__(
            component_name=self._name,
            initial_value="",
            label=None,
            args={
                "routes": list(routes.keys()),
            },
            on_change=None,
            slotted_html=text,
        )

    def _convert_value(self, value: str) -> str:
        return value

    # Not supported
    def batch(self, *args: Any, **kwargs: Any) -> Any:
        del args, kwargs
        raise TypeError(".batch() is not supported on mo.sidebar")

    def center(self, *args: Any, **kwargs: Any) -> Html:
        del args, kwargs
        raise TypeError(".center() is not supported on mo.sidebar")

    def right(self, *args: Any, **kwargs: Any) -> Html:
        del args, kwargs
        raise TypeError(".right() is not supported on mo.sidebar")

    def left(self, *args: Any, **kwargs: Any) -> Html:
        del args, kwargs
        raise TypeError(".left() is not supported on mo.sidebar")

    def callout(self, *args: Any, **kwargs: Any) -> Html:
        del args, kwargs
        raise TypeError(".callout() is not supported on mo.sidebar")

    def style(self, *args: Any, **kwargs: Any) -> Html:
        del args, kwargs
        raise TypeError(".style() is not supported on mo.sidebar")

#+END_SRC
** sidebar
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.sidebar
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/sidebar.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Optional

from marimo._output import md
from marimo._output.formatting import as_html
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import build_stateless_plugin
from marimo._plugins.stateless.flex import vstack

#+END_SRC
*** @mddoc: Class sidebar
#+BEGIN_SRC python
@mddoc
class sidebar(Html):
    """
    Displays content in a sidebar. This is a special layout component that
    will display the content in a sidebar layout, rather than below/above
    the cell.

    This component still needs to be the last expression in the cell,
    in order to display correctly.

    You may use more than one `mo.sidebar` - they will be displayed in the
    order they are called.

    **Examples.**

    ```python
    mo.sidebar(
        [
            mo.md("# marimo"),
            mo.nav_menu(
                {
                    "#home": f"{mo.icon('lucide:home')} Home",
                    "#about": f"{mo.icon('lucide:user')} About",
                    "#contact": f"{mo.icon('lucide:phone')} Contact",
                    "Links": {
                        "https://twitter.com/marimo_io": "Twitter",
                        "https://github.com/marimo-team/marimo": "GitHub",
                    },
                },
                orientation="vertical",
            ),
        ]
    )
    ```

    **Args.**

    - `item`: the content to display in the sidebar
    - `footer`: the content to display at the bottom of the sidebar

    **Returns.**

    - An `Html` object.
    """

    def __init__(self, item: object, footer: Optional[object] = None) -> None:
        # If its a string, wrap in md
        if isinstance(item, str):
            item = md.md(item)
        # If its an array, wrap in vstack
        if isinstance(item, list):
            item = vstack(item)

        # Maybe add footer
        if footer:
            if isinstance(footer, str):
                footer = md.md(footer)
            if isinstance(footer, list):
                footer = vstack(footer)
            item = vstack([item, footer], justify="space-between")

        super().__init__(
            build_stateless_plugin(
                "marimo-sidebar",
                {},
                as_html(item).text,
            )
        )

    # Not supported
    def batch(self, *args: Any, **kwargs: Any) -> Any:
        del args, kwargs
        raise TypeError(".batch() is not supported on mo.sidebar")

    def center(self, *args: Any, **kwargs: Any) -> Html:
        del args, kwargs
        raise TypeError(".center() is not supported on mo.sidebar")

    def right(self, *args: Any, **kwargs: Any) -> Html:
        del args, kwargs
        raise TypeError(".right() is not supported on mo.sidebar")

    def left(self, *args: Any, **kwargs: Any) -> Html:
        del args, kwargs
        raise TypeError(".left() is not supported on mo.sidebar")

    def callout(self, *args: Any, **kwargs: Any) -> Html:
        del args, kwargs
        raise TypeError(".callout() is not supported on mo.sidebar")

    def style(self, *args: Any, **kwargs: Any) -> Html:
        del args, kwargs
        raise TypeError(".style() is not supported on mo.sidebar")

#+END_SRC
** stat
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.stat
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/stat.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Literal, Optional, Union

from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import build_stateless_plugin
from marimo._plugins.utils import remove_none_values

#+END_SRC
*** @mddoc: Function stat
#+BEGIN_SRC python
@mddoc
def stat(
    value: Union[str, int, float],
    label: Optional[str] = None,
    caption: Optional[str] = None,
    direction: Optional[Literal["increase", "decrease"]] = None,
    bordered: bool = False,
) -> Html:
    """Display a statistic.

    Optionally include a label, caption, and direction.

    **Args.**

    - `value`: the value to display
    - `label`: the label to display
    - `caption`: the caption to display
    - `direction`: the direction of the statistic,
        either `increase` or `decrease`
    - `bordered`: whether to display a border around the statistic

    **Returns.**

    An `Html` object representing the statistic.
    """
    return Html(
        build_stateless_plugin(
            component_name="marimo-stat",
            args=remove_none_values(
                {
                    "value": value,
                    "label": label,
                    "caption": caption,
                    "direction": direction,
                    "bordered": bordered,
                }
            ),
        )
    )

#+END_SRC
** style
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.style
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/style.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Optional

from marimo._output.builder import h
from marimo._output.formatting import as_dom_node
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc

#+END_SRC
*** @mddoc: Function style
#+BEGIN_SRC python
@mddoc
def style(
    item: object, style: Optional[dict[str, Any]] = None, **kwargs: Any
) -> Html:
    """Wrap an object in a styled container.

    **Example.**

    ```python
    mo.style(item, styles={"max-height": "300px", "overflow": "auto"})
    mo.style(item, max_height="300px", overflow="auto")
    ```

    **Args.**

    - `item`: an object to render as HTML
    - `styles`: a optional dict of CSS styles, keyed by property name
    - `**kwargs`: additional CSS styles
    """
    # Initialize combined_style with style dict if provided,
    # otherwise empty dict
    combined_style = style or {}

    # Add kwargs to combined_style, converting snake_case to kebab-case
    for key, value in kwargs.items():
        kebab_key = key.replace("_", "-")
        combined_style[kebab_key] = value

    style_str = ";".join(
        [f"{key}:{value}" for key, value in combined_style.items()]
    )
    return Html(h.div(children=as_dom_node(item).text, style=style_str))

#+END_SRC
** tabs
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.tabs
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/tabs.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.ui._impl.tabs import tabs as tabs_impl
from marimo._utils.deprecated import deprecated

#+END_SRC
*** @mddoc deprecated("mo.tabs is deprecated. Use mo.ui.tabs instead"): Function tabs
#+BEGIN_SRC python
@mddoc
@deprecated("mo.tabs is deprecated. Use mo.ui.tabs instead")
def tabs(tabs: dict[str, object]) -> Html:
    """
    **Deprecated.**: Use `mo.ui.tabs` instead.

    Tabs of UI elements.

    **Examples.**

    ```python
    tab1 = mo.vstack([
        mo.ui.slider(1, 10),
        mo.ui.text(),
        mo.ui.date()
    ]);
    tab2 = mo.vstack([{
        "slider": mo.ui.slider(1, 10),
        "text": mo.ui.text(),
        "date": mo.ui.date()
    ]);
    tabs = mo.tabs({
        "Tab 1": tab1,
        "Tab 2": tab2
    })
    ```

    **Args.**

    - `tabs`: a dictionary of tab names to tab content; strings are interpreted
    as markdown

    **Returns.**

    - An `Html` object.
    """
    return tabs_impl(tabs)

#+END_SRC
** tree
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.tree
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/tree.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Optional

from marimo._output.formatters.structures import format_structure
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType
from marimo._plugins.stateless import json_output
from marimo._utils.flatten import CyclicStructureError

#+END_SRC
*** @mddoc: Function tree
#+BEGIN_SRC python
@mddoc
def tree(
    items: list[Any] | tuple[Any] | dict[Any, Any],
    label: Optional[str] = None,
) -> Html:
    """Render a nested structure of lists, tuples, or dicts as a tree.

    **Example.**
    ```python3
    mo.tree(["entry", "another entry", {"key": [0, 1, 2]}], label="A tree.")
    ```
    **Args.**

    - `items`: nested structure of lists, tuples, or dicts
    - `label`: optional text label for the tree

    **Returns.**

    `Html` object
    """
    if not isinstance(items, (list, tuple, dict)):
        raise ValueError(
            "Argument `items` must be a list, tuple, or dict, "
            + f"but got: {type(items)}"
        )

    json_data: JSONType
    try:
        json_data = format_structure(items)
    except CyclicStructureError:
        json_data = str(items)
    return json_output.json_output(json_data=json_data, name=label)

#+END_SRC
** video
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.video
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/video.py
:END:
*** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import io
from typing import Optional, Union

from marimo._output.builder import h
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._output.utils import create_style, normalize_dimension
from marimo._plugins.core.media import io_to_data_url

#+END_SRC
*** @mddoc: Function video
#+BEGIN_SRC python
@mddoc
def video(
    src: Union[str, bytes, io.BytesIO, io.BufferedReader],
    controls: bool = True,
    muted: bool = False,
    autoplay: bool = False,
    loop: bool = False,
    width: Optional[Union[int, str]] = None,
    height: Optional[Union[int, str]] = None,
    rounded: bool = False,
) -> Html:
    """Render an video as HTML.

    **Example.**

    ```python3
    mo.video(
        src="https://v3.cdnpk.net/videvo_files/video/free/2013-08/large_watermarked/hd0992_preview.mp4",
        controls=False,
    )
    ```

    **Args.**

    - `src`: the URL of the video or a file-like object
    - `controls`: whether to show the controls
    - `muted`: whether to mute the video
    - `autoplay`: whether to autoplay the video.
        the video will only autoplay if `muted` is `True`
    - `loop`: whether to loop the video
    - `width`: the width of the video in pixels or a string with units
    - `height`: the height of the video in pixels or a string with units
    - `rounded`: whether to round the corners of the video

    **Returns.**

    `Html` object
    """
    # Convert to bytes right away since can only be read once
    if isinstance(src, io.BufferedReader):
        src.seek(0)
        src = src.read()

    resolved_src = io_to_data_url(src, fallback_mime_type="video/mp4")
    styles = create_style(
        {
            "width": normalize_dimension(width),
            "height": normalize_dimension(height),
            "border-radius": "4px" if rounded else None,
        }
    )
    return Html(
        h.video(
            src=resolved_src,
            controls=controls,
            style=styles,
            muted=muted,
            autoplay=autoplay,
            loop=loop,
        )
    )

#+END_SRC
** mpl
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.mpl
:END:
*** Utilities for working with matplotlib.
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.mpl.__init__
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/mpl/__init__.py
:END:
**** Docstring
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
"""Utilities for working with matplotlib."""

#+END_SRC
**** Assignment __all__ = [     "interactive", ]
#+BEGIN_SRC python
__all__ = [
    "interactive",
]

#+END_SRC
**** Import
#+BEGIN_SRC python
from marimo._plugins.stateless.mpl._mpl import interactive

#+END_SRC
*** Interactive matplotlib plots, based on WebAgg.
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.mpl._mpl
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/mpl/_mpl.py
:END:
**** Docstring
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
"""
Interactive matplotlib plots, based on WebAgg.

Adapted from https://matplotlib.org/stable/gallery/user_interfaces/embedding_webagg_sgskip.html
"""

#+END_SRC
**** Import statements
#+BEGIN_SRC python
from __future__ import annotations

import asyncio
import html
import io
import mimetypes
import os
import signal
import threading
import time
from pathlib import Path
from typing import TYPE_CHECKING, Any, Optional, Tuple, Union

from starlette.websockets import (
    WebSocketDisconnect,
    WebSocketState,
)

from marimo._output.builder import h
from marimo._output.formatting import as_html
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._runtime.cell_lifecycle_item import CellLifecycleItem
from marimo._runtime.context import (
    RuntimeContext,
    get_context,
)
from marimo._runtime.context.kernel_context import KernelRuntimeContext
from marimo._server.utils import find_free_port
from marimo._utils.signals import get_signals

#+END_SRC
**** Class FigureManagers
#+BEGIN_SRC python
if TYPE_CHECKING:
    from matplotlib.axes import Axes
    from matplotlib.backends.backend_webagg_core import FigureManagerWebAgg
    from matplotlib.figure import Figure
    from starlette.applications import Starlette
    from starlette.requests import Request
    from starlette.websockets import WebSocket


class FigureManagers:
    def __init__(self) -> None:
        self.figure_managers: dict[str, FigureManagerWebAgg] = {}

    def add(self, manager: FigureManagerWebAgg) -> None:
        self.figure_managers[str(manager.num)] = manager

    def get(self, figure_id: str) -> FigureManagerWebAgg:
        if figure_id not in self.figure_managers:
            raise RuntimeError(f"Figure {figure_id} not found.")  # noqa: E501
        return self.figure_managers[str(figure_id)]

    def remove(self, manager: FigureManagerWebAgg) -> None:
        del self.figure_managers[str(manager.num)]

#+END_SRC
**** Assignment figure_managers = FigureManagers()
#+BEGIN_SRC python
figure_managers = FigureManagers()

#+END_SRC
**** Function _get_host
#+BEGIN_SRC python
def _get_host() -> str:
    """
    Get the host from environment variable or fall back to localhost.
    """
    host = os.environ.get("MARIMO_MPL_HOST", "localhost")
    if not host or not isinstance(host, str):
        return "localhost"
    if "://" in host:
        raise ValueError(
            f"Invalid host '{host}': should not include protocol (http:// or https://)"
        )
    if "/" in host:
        raise ValueError(f"Invalid host '{host}': should not include paths")
    if ":" in host:
        raise ValueError(
            f"Invalid host '{host}': should not include port numbers"
        )
    return host

#+END_SRC
**** Function _get_secure
#+BEGIN_SRC python
def _get_secure() -> bool:
    """
    Get the secure status from environment variable or fall back to False.
    """
    secure = os.environ.get("MARIMO_MPL_SECURE", "false")
    if not secure or not isinstance(secure, str):
        return False
    secure = secure.lower().strip()
    if secure in ("true", "1", "yes", "on"):
        return True
    if secure in ("false", "0", "no", "off"):
        return False

    raise ValueError(
        f"Invalid secure value '{secure}': should be 'true' or 'false'"
    )

#+END_SRC
**** Function _template
#+BEGIN_SRC python
def _template(fig_id: str, port: int) -> str:
    return html_content % {
        "ws_uri": f"/mpl/{port}/ws?figure={fig_id}",
        "fig_id": fig_id,
        "port": port,
    }

#+END_SRC
**** Function create_application
#+BEGIN_SRC python
def create_application() -> Starlette:
    import matplotlib as mpl
    from matplotlib.backends.backend_webagg_core import (
        FigureManagerWebAgg,
    )
    from starlette.applications import Starlette
    from starlette.responses import HTMLResponse, Response
    from starlette.routing import Mount, Route, WebSocketRoute
    from starlette.staticfiles import StaticFiles

    async def main_page(request: Request) -> HTMLResponse:
        figure_id = request.query_params.get("figure")
        assert figure_id is not None
        port = request.app.state.port
        content = _template(figure_id, port)
        return HTMLResponse(content=content)

    async def mpl_js(request: Request) -> Response:
        del request
        return Response(
            content=FigureManagerWebAgg.get_javascript(),  # type: ignore[no-untyped-call]
            media_type="application/javascript",
        )

    async def mpl_custom_css(request: Request) -> Response:
        del request
        return Response(
            content=css_content,
            media_type="text/css",
        )

    async def download(request: Request) -> Response:
        figure_id = request.query_params.get("figure")
        assert figure_id is not None
        fmt = request.path_params["fmt"]
        mime_type = mimetypes.types_map.get(fmt, "binary")
        buff = io.BytesIO()
        figure_manager = figure_managers.get(figure_id)
        figure_manager.canvas.figure.savefig(
            buff, format=fmt, bbox_inches="tight"
        )
        return Response(content=buff.getvalue(), media_type=mime_type)

    async def websocket_endpoint(websocket: WebSocket) -> None:
        await websocket.accept()
        queue: asyncio.Queue[Tuple[Any, str]] = asyncio.Queue()

        class SyncWebSocket:
            def send_json(self, content: str) -> None:
                queue.put_nowait((content, "json"))

            def send_binary(self, blob: Any) -> None:
                queue.put_nowait((blob, "binary"))

        figure_id = websocket.query_params.get("figure")
        if not figure_id:
            await websocket.send_json(
                {"type": "error", "message": "No figure ID provided"}
            )
            await websocket.close()
            return

        try:
            figure_manager = figure_managers.get(figure_id)
        except RuntimeError:
            await websocket.send_json(
                {
                    "type": "error",
                    "message": f"Figure with id '{figure_id}' not found",
                }
            )
            await websocket.close()
            return

        figure_manager.add_web_socket(SyncWebSocket())  # type: ignore[no-untyped-call]

        async def receive() -> None:
            try:
                while True:
                    data = await websocket.receive_json()
                    if data["type"] == "supports_binary":
                        # We always support binary
                        # and we don't need to pass this message
                        # to the figure manager
                        pass
                    else:
                        figure_manager.handle_json(data)  # type: ignore[no-untyped-call]
            except WebSocketDisconnect:
                pass
            except Exception as e:
                if websocket.application_state != WebSocketState.DISCONNECTED:
                    await websocket.send_json(
                        {"type": "error", "message": str(e)}
                    )
            finally:
                if websocket.application_state != WebSocketState.DISCONNECTED:
                    await websocket.close()

        async def send() -> None:
            try:
                while True:
                    (data, mode) = await queue.get()
                    if mode == "json":
                        await websocket.send_json(data)
                    else:
                        await websocket.send_bytes(data)
            except WebSocketDisconnect:
                # Client disconnected normally
                pass
            except Exception as e:
                if websocket.application_state != WebSocketState.DISCONNECTED:
                    await websocket.send_json(
                        {"type": "error", "message": str(e)}
                    )
            finally:
                if websocket.application_state != WebSocketState.DISCONNECTED:
                    await websocket.close()

        try:
            await asyncio.gather(receive(), send())
        except Exception as e:
            if websocket.application_state != WebSocketState.DISCONNECTED:
                await websocket.send_json({"type": "error", "message": str(e)})
                await websocket.close()

    return Starlette(
        routes=[
            Route("/", main_page, methods=["GET"]),
            Route("/mpl.js", mpl_js, methods=["GET"]),
            Route("/custom.css", mpl_custom_css, methods=["GET"]),
            Route("/download.{fmt}", download, methods=["GET"]),
            WebSocketRoute("/ws", websocket_endpoint),
            Mount(
                "/_static",
                StaticFiles(
                    directory=FigureManagerWebAgg.get_static_file_path()  # type: ignore[no-untyped-call]
                ),
                name="mpl_static",
            ),
            Mount(
                "/_images",
                StaticFiles(directory=Path(mpl.get_data_path(), "images")),
                name="mpl_images",
            ),
        ],
    )

#+END_SRC
**** Assignment _app: Optional[Starlette] = None
#+BEGIN_SRC python
_app: Optional[Starlette] = None

#+END_SRC
**** Function get_or_create_application
#+BEGIN_SRC python
def get_or_create_application(
    app_host: Optional[str] = None,
    free_port: Optional[int] = None,
    secure_host: Optional[bool] = None,
) -> Starlette:
    global _app

    import uvicorn

    if _app is None:
        host = app_host if app_host is not None else _get_host()
        port = free_port if free_port is not None else find_free_port(10_000)
        secure = secure_host if secure_host is not None else _get_secure()
        app = create_application()
        app.state.host = host
        app.state.port = port
        app.state.secure = secure
        _app = app

        def start_server() -> None:
            signal_handlers = get_signals()
            uvicorn.Server(
                uvicorn.Config(
                    app=app,
                    port=port,
                    host=host,
                    log_level="critical",
                )
            ).run()
            for signo, handler in signal_handlers.items():
                signal.signal(signo, handler)

        threading.Thread(target=start_server).start()

        # arbitrary wait 200ms for the server to start
        # this only happens once per session
        time.sleep(0.02)

    return _app

#+END_SRC
**** Function new_figure_manager_given_figure
#+BEGIN_SRC python
def new_figure_manager_given_figure(
    num: int, figure: Union[Figure, Axes]
) -> Any:
    from matplotlib.backends.backend_webagg_core import (
        FigureCanvasWebAggCore,
        FigureManagerWebAgg as CoreFigureManagerWebAgg,
        NavigationToolbar2WebAgg as CoreNavigationToolbar2WebAgg,
    )

    class FigureManagerWebAgg(CoreFigureManagerWebAgg):
        _toolbar2_class = CoreNavigationToolbar2WebAgg  # type: ignore[assignment]

    class FigureCanvasWebAgg(FigureCanvasWebAggCore):
        manager_class = FigureManagerWebAgg  # type: ignore[assignment]

    canvas = FigureCanvasWebAgg(figure)  # type: ignore[no-untyped-call]
    manager = FigureManagerWebAgg(canvas, num)  # type: ignore[no-untyped-call]
    return manager

#+END_SRC
**** @mddoc: Function interactive
#+BEGIN_SRC python
@mddoc
def interactive(figure: Union[Figure, Axes]) -> Html:
    """Render a matplotlib figure using an interactive viewer.

    The interactive viewer allows you to pan, zoom, and see plot coordinates
    on mouse hover.

    **Example**:

    ```python
    plt.plot([1, 2])
    # plt.gcf() gets the current figure
    mo.mpl.interactive(plt.gcf())
    ```

    **Args**:

    - figure: a matplotlib `Figure` or `Axes` object

    **Returns**:

    - An interactive matplotlib figure as an `Html` object
    """
    # No top-level imports of matplotlib, since it isn't a required
    # dependency
    from matplotlib.axes import Axes

    if isinstance(figure, Axes):
        maybe_figure = figure.get_figure()
        assert maybe_figure is not None, "Axes object does not have a Figure"
        figure = maybe_figure

    ctx = get_context()
    if not isinstance(ctx, KernelRuntimeContext):
        return as_html(figure)

    # Figure Manager, Any type because matplotlib doesn't have typings
    figure_manager = new_figure_manager_given_figure(id(figure), figure)

    # TODO(akshayka): Proxy this server through the marimo server to help with
    # deployment.
    app = get_or_create_application()
    port = app.state.port

    class CleanupHandle(CellLifecycleItem):
        def create(self, context: RuntimeContext) -> None:
            del context

        def dispose(self, context: RuntimeContext, deletion: bool) -> bool:
            del context
            del deletion
            figure_managers.remove(figure_manager)
            return True

    figure_managers.add(figure_manager)
    assert ctx.execution_context is not None
    ctx.cell_lifecycle_registry.add(CleanupHandle())
    ctx.stream.cell_id = ctx.execution_context.cell_id

    content = _template(str(figure_manager.num), port)

    return Html(
        h.iframe(
            srcdoc=html.escape(content),
            width="100%",
            height="550px",
            onload="__resizeIframe(this)",
        )
    )

#+END_SRC
**** Assignment html_content
#+BEGIN_SRC python
html_content = """
<!DOCTYPE html>
<html lang="en">
  <head>
    <base href='/mpl/%(port)s/    ' />
    <link rel="stylesheet" href="/mpl/%(port)s/_static/css/page.css" type="text/css" />
    <link rel="stylesheet" href="/mpl/%(port)s/_static/css/boilerplate.css" type="text/css" />
    <link rel="stylesheet" href="/mpl/%(port)s/_static/css/fbm.css" type="text/css" />
    <link rel="stylesheet" href="/mpl/%(port)s/_static/css/mpl.css" type="text/css" />
    <link rel="stylesheet" href="/mpl/%(port)s/custom.css" type="text/css" />
    <script src="/mpl/%(port)s/mpl.js"></script>

    <script>
      function ondownload(figure, format) {
        window.open('download.' + format + '?figure=' + figure.id, '_blank');
      };

      function ready(fn) {
        if (document.readyState != "loading") {
          fn();
        } else {
          document.addEventListener("DOMContentLoaded", fn);
        }
      }

      ready(
        function() {
          var websocket_type = mpl.get_websocket_type();
          var websocket = new websocket_type("%(ws_uri)s");

          // mpl.figure creates a new figure on the webpage.
          var fig = new mpl.figure(
              // A unique numeric identifier for the figure
              %(fig_id)s,
              // A websocket object
              websocket,
              // A function called when a file type is selected for download
              ondownload,
              // The HTML element in which to place the figure
              document.getElementById("figure"));
        }
      );
    </script>

    <title>marimo</title>
  </head>

  <body>
    <div id="figure"></div>
  </body>
</html>
""".strip()

#+END_SRC
**** Assignment css_content
#+BEGIN_SRC python
# noqa: E501

# Custom CSS to make the mpl toolbar fit the marimo UI
# We do not support dark mode at the moment as the iframe does not know
# the theme of the parent page.
css_content = """
body {
    background-color: transparent;
    width: 100%;
}
#figure, mlp-canvas {
    width: 100%;
}
.ui-dialog-titlebar + div {
    border-radius: 4px;
}
.ui-dialog-titlebar {
    display: none;
}
.mpl-toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
}
select.mpl-widget,
.mpl-button-group {
    margin: 4px 0;
    border-radius: 6px;
    box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px,
        rgba(0, 0, 0, 0) 0px 0px 0px 0px,
        rgba(15, 23, 42, 0.1) 1px 1px 0px 0px,
        rgba(15, 23, 42, 0.1) 0px 0px 2px 0px;
}
.mpl-button-group + .mpl-button-group {
    margin-left: 0;
}
.mpl-button-group > .mpl-widget {
    padding: 4px;
}
.mpl-button-group > .mpl-widget > img {
    height: 16px;
    width: 16px;
}
.mpl-widget:disabled, .mpl-widget[disabled]
.mpl-widget:disabled, .mpl-widget[disabled]:hover {
    opacity: 0.5;
    background-color: #fff;
    border-color: #ccc !important;
}
.mpl-message {
    color: rgb(139, 141, 152);
    font-size: 11px;
}
.mpl-widget img {
    filter: invert(0.3);
}
""".strip()

#+END_SRC
** status
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.status
:END:
*** Create loading indicators.
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.status.__init__
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/status/__init__.py
:END:
**** Docstring
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
"""Create loading indicators."""

#+END_SRC
**** Assignment __all__ = ["progress_bar", "spinner", "toast"]
#+BEGIN_SRC python
__all__ = ["progress_bar", "spinner", "toast"]

#+END_SRC
**** Import
#+BEGIN_SRC python
from marimo._plugins.stateless.status._progress import (
    progress_bar,
    spinner,
    toast,
)

#+END_SRC
*** _progress
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.stateless.status._progress
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/stateless/status/_progress.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import time
from typing import (
    TYPE_CHECKING,
    Any,
    Iterable,
    Literal,
    Optional,
    TypeVar,
)

import marimo._runtime.output._output as output
from marimo._messaging.mimetypes import KnownMimeType
from marimo._messaging.ops import Alert
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import build_stateless_plugin
from marimo._utils.debounce import debounce

#+END_SRC
**** Assignment S = TypeVar("S")
#+BEGIN_SRC python
if TYPE_CHECKING:
    from collections.abc import Collection

S = TypeVar("S")

#+END_SRC
**** Assignment T = TypeVar("T")
#+BEGIN_SRC python
T = TypeVar("T")

#+END_SRC
**** Function _remove_none_values
#+BEGIN_SRC python
def _remove_none_values(d: dict[S, T]) -> dict[S, T]:
    return {k: v for k, v in d.items() if v is not None}

#+END_SRC
**** Class _Progress
#+BEGIN_SRC python
class _Progress(Html):
    """A mutable class to represent a progress indicator in the UI."""

    def __init__(
        self,
        title: Optional[str],
        subtitle: Optional[str],
        total: Optional[int],
        show_rate: bool,
        show_eta: bool,
    ) -> None:
        self.title = title
        self.subtitle = subtitle
        self.total = total
        self.current = 0
        self.closed = False
        # We show a loading spinner if total not known
        self.loading_spinner = total is None
        self.show_rate = show_rate
        self.show_eta = show_eta
        self.start_time = time.time()
        super().__init__(self._get_text())

    def update_progress(
        self,
        increment: int = 1,
        title: Optional[str] = None,
        subtitle: Optional[str] = None,
    ) -> None:
        """Update the progress indicator.

        **Example.**

        ```python
        # Increment by 1
        progress.update()

        # Increment by 10 and update title and subtitle
        progress.update(10, title="Loading", subtitle="Still going...")
        ```

        **Args.**

        - increment: amount to increment by. Defaults to 1.
        - title: new title. Defaults to None.
        - subtitle: new subtitle. Defaults to None.
        """
        if self.closed:
            raise RuntimeError(
                "Progress indicators cannot be updated after exiting "
                "the context manager that created them. "
            )
        self.current += increment
        if title is not None:
            self.title = title
        if subtitle is not None:
            self.subtitle = subtitle

        self._text = self._get_text()
        self.debounced_flush()

    @debounce(0.15)
    def debounced_flush(self) -> None:
        """Flush the output to the UI"""
        output.flush()

    def clear(self) -> None:
        if self.closed:
            raise RuntimeError(
                "Progress indicators cannot be updated after exiting "
                "the context manager that created them. "
            )
        output.remove(self)

    def close(self) -> None:
        output.flush()  # Flush one last time before closing
        self.closed = True

    def _get_text(self) -> str:
        return build_stateless_plugin(
            component_name="marimo-progress",
            args=_remove_none_values(
                {
                    "title": self.title,
                    "subtitle": self.subtitle,
                    "total": self.total,
                    # 'progress' is True is we don't know the total,
                    # which shows a loading spinner
                    "progress": True if self.loading_spinner else self.current,
                    "rate": self._get_rate(),
                    "eta": self._get_eta(),
                }
            ),
        )

    def _get_rate(self) -> Optional[float]:
        if self.show_rate:
            diff = time.time() - self.start_time
            if diff == 0:
                return None
            rate = self.current / diff
            return round(rate, 2)
        else:
            return None

    def _get_eta(self) -> Optional[float]:
        if self.show_eta and self.total is not None:
            rate = self._get_rate()
            if rate is not None and rate > 0:
                return round((self.total - self.current) / rate, 2)
            else:
                return None
        else:
            return None

#+END_SRC
**** Class ProgressBar
#+BEGIN_SRC python
class ProgressBar(_Progress):
    def __init__(
        self,
        title: str | None,
        subtitle: str | None,
        total: int,
        show_rate: bool,
        show_eta: bool,
    ) -> None:
        super().__init__(
            title=title,
            subtitle=subtitle,
            total=total,
            show_rate=show_rate,
            show_eta=show_eta,
        )

    def update(
        self,
        increment: int = 1,
        title: str | None = None,
        subtitle: str | None = None,
    ) -> None:
        super().update_progress(
            increment=increment, title=title, subtitle=subtitle
        )

#+END_SRC
**** Class Spinner
#+BEGIN_SRC python
# TODO(akshayka): Add a `done()` method that turns the spinner into a checkmark
class Spinner(_Progress):
    """A spinner output representing a loading state"""

    def __init__(
        self,
        title: str | None,
        subtitle: str | None,
    ) -> None:
        super().__init__(
            title=title,
            subtitle=subtitle,
            total=None,
            show_rate=False,
            show_eta=False,
        )

    def update(
        self, title: str | None = None, subtitle: str | None = None
    ) -> None:
        """Update the title and subtitle of the spinner

        This method updates a spinner output in-place. Must be used
        in the cell the spinner was created.

        **Example.**

        ```python
        with mo.status.spinner("Hang tight!") as _spinner:
            ...
            _spinner.update(title="Almost done!")
        # Optionally, remove the spinner from the output
        # _spinner.clear()
        ```
        """
        super().update_progress(increment=1, title=title, subtitle=subtitle)

#+END_SRC
**** @mddoc: Class spinner
#+BEGIN_SRC python
@mddoc
class spinner:
    """Show a loading spinner

    Use `mo.status.spinner()` as a context manager to show a loading spinner.
    You can optionally pass a title and subtitle.

    **Example.**

    ```python
    with mo.status.spinner(subtitle="Loading data ...") as _spinner:
        data = expensive_function()
        _spinner.update(subtitle="Crunching numbers ...")
        ...

    mo.ui.table(data)
    ```

    You can also show the spinner without a context manager:

    ```python
    mo.status.spinner(title="Loading ...") if condition else mo.md("Done!")
    ```

    **Args:**

    - `title`: optional title
    - `subtitle`: optional subtitle
    - `remove_on_exit`: if True, the spinner is removed from output on exit
    """

    def __init__(
        self,
        title: Optional[str] = None,
        subtitle: Optional[str] = None,
        remove_on_exit: bool = True,
    ):
        self.title = title
        self.subtitle = subtitle
        self.remove_on_exit = remove_on_exit
        self.spinner = Spinner(title=self.title, subtitle=self.subtitle)

    def __enter__(self) -> Spinner:
        output.append(self.spinner)
        return self.spinner

    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:
        if self.remove_on_exit:
            self.spinner.clear()
        # TODO(akshayka): else consider transitioning to a done state
        self.spinner.close()

    def _mime_(self) -> tuple[KnownMimeType, str]:
        return self.spinner._mime_()

#+END_SRC
**** Class progress_bar
#+BEGIN_SRC python
class progress_bar:
    """Iterate over a collection and show a progress bar

    **Example.**

    ```python
    for i in mo.status.progress_bar(range(10)):
        ...
    ```

    You can optionally provide a title and subtitle to show
    during iteration, and a title/subtitle to show upon completion.

    You can also use progress_bar with a context manager and manually update
    the bar:

    ```python
    with mo.status.progress_bar(total=10) as bar:
        for i in range(10):
            ...
            bar.update()
    ```

    The `update` method accepts the optional keyword
    arguments `increment` (defaults to `1`), `title`,
    and `subtitle`.

    For performance reasons, the progress bar is only updated in the UI
    every 150ms.

    **Args.**

    - `collection`: optional collection to iterate over
    - `title`: optional title
    - `subtitle`: optional subtitle
    - `completion_title`: optional title to show during completion
    - `completion_subtitle`: optional subtitle to show during completion
    - `total`: optional total number of items to iterate over
    - `show_rate`: if True, show the rate of progress (items per second)
    - `show_eta`: if True, show the estimated time of completion
    - `remove_on_exit`: if True, remove the progress bar from output on exit
    - `disabled`: if True, disable the progress bar
    """

    def __init__(
        self,
        collection: Optional[Collection[S | int]] = None,
        *,
        title: Optional[str] = None,
        subtitle: Optional[str] = None,
        completion_title: Optional[str] = None,
        completion_subtitle: Optional[str] = None,
        total: Optional[int] = None,
        show_rate: bool = True,
        show_eta: bool = True,
        remove_on_exit: bool = False,
        disabled: bool = False,
    ):
        self.completion_title = completion_title
        self.completion_subtitle = completion_subtitle
        self.remove_on_exit = remove_on_exit
        self.disabled = disabled

        if collection is not None:
            self.collection = collection

            try:
                total = total or len(collection)
                self.step = (
                    collection.step if isinstance(collection, range) else 1
                )
            except TypeError:  # if collection is a generator
                raise TypeError(
                    "fail to determine length of collection, use `total`"
                    + "to specify"
                ) from None

        elif total is None:
            raise ValueError(
                "`total` is required when using as a context manager"
            )

        self.progress = ProgressBar(
            title=title,
            subtitle=subtitle,
            total=total,
            show_rate=show_rate,
            show_eta=show_eta,
        )
        if not disabled:
            output.append(self.progress)

    def __iter__(self) -> Iterable[S | int]:
        for item in self.collection:
            yield item
            if not self.disabled:
                self.progress.update(increment=self.step)
        self._finish()

    def __enter__(self) -> ProgressBar:
        return self.progress

    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:
        self._finish()

    def _finish(self) -> None:
        self.progress.update(
            increment=0,
            title=self.completion_title,
            subtitle=self.completion_subtitle,
        )
        if self.remove_on_exit:
            self.progress.clear()
        self.progress.close()

#+END_SRC
**** @mddoc: Function toast
#+BEGIN_SRC python
@mddoc
def toast(
    title: str,
    description: str = "",
    kind: Optional[Literal["danger"]] = None,
) -> None:
    """Show a toast notification

    Use `mo.status.toast()` to display a brief notification.

    **Example.**

    ```python
    mo.status.toast(
        "Operation completed",
        "Your task has finished successfully",
    )
    ```

    **Args:**

    - `title`: The main message of the toast
    - `description`: Optional additional details (can include HTML)
    - `kind`: Optional kind, use "danger" for error toasts
    """
    Alert(title=title, description=description, variant=kind).broadcast()

#+END_SRC
* ui
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui
:END:
** Interactive UI elements.
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui.__init__
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/__init__.py
:END:
*** Docstring
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
"""Interactive UI elements.

This module contains a library of interactive UI elements.
"""

#+END_SRC
*** Assignment __all__
#+BEGIN_SRC python
from __future__ import annotations

__all__ = [
    "altair_chart",
    "anywidget",
    "array",
    "batch",
    "button",
    "chat",
    "checkbox",
    "code_editor",
    "data_explorer",
    "dataframe",
    "date_range",
    "date",
    "datetime",
    "experimental_data_editor",
    "dictionary",
    "dropdown",
    "file_browser",
    "file",
    "form",
    "microphone",
    "multiselect",
    "number",
    "panel",
    "plotly",
    "radio",
    "range_slider",
    "refresh",
    "run_button",
    "slider",
    "switch",
    "table",
    "tabs",
    "text_area",
    "text",
]

#+END_SRC
*** Import
#+BEGIN_SRC python
from marimo._plugins.ui._impl.altair_chart import altair_chart
from marimo._plugins.ui._impl.array import array
from marimo._plugins.ui._impl.batch import batch
from marimo._plugins.ui._impl.chat.chat import chat
from marimo._plugins.ui._impl.data_editor import (
    data_editor as experimental_data_editor,
)
from marimo._plugins.ui._impl.data_explorer import data_explorer
from marimo._plugins.ui._impl.dataframes.dataframe import dataframe
from marimo._plugins.ui._impl.dates import (
    date,
    date_range,
    datetime,
)
from marimo._plugins.ui._impl.dictionary import dictionary
from marimo._plugins.ui._impl.from_anywidget import anywidget
from marimo._plugins.ui._impl.from_panel import panel
from marimo._plugins.ui._impl.input import (
    button,
    checkbox,
    code_editor,
    dropdown,
    file,
    file_browser,
    form,
    multiselect,
    number,
    radio,
    range_slider,
    slider,
    text,
    text_area,
)
from marimo._plugins.ui._impl.microphone import microphone
from marimo._plugins.ui._impl.plotly import plotly
from marimo._plugins.ui._impl.refresh import refresh
from marimo._plugins.ui._impl.run_button import run_button
from marimo._plugins.ui._impl.switch import switch
from marimo._plugins.ui._impl.table import table
from marimo._plugins.ui._impl.tabs import tabs

#+END_SRC
** _core
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._core
:END:
*** __init__
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._core.__init__
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_core/__init__.py
:END:
**** Comment
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.

#+END_SRC
*** ids
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._core.ids
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_core/ids.py
:END:
**** Class NoIDProviderException
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations


class NoIDProviderException(Exception):
    pass

#+END_SRC
**** Class IDProvider
#+BEGIN_SRC python
class IDProvider:
    """Provide IDs for UIElements

    Can be used to provide IDs that are stable across sessions.
    """

    def __init__(self, prefix: str):
        """Initialize an ID provider

        `prefix` should be unique across cells
        """
        self._prefix = prefix
        self._counter = 0

    def take_id(self) -> str:
        """Get an ID"""
        this_id = f"{self._prefix}-{self._counter}"
        self._counter += 1
        return this_id

#+END_SRC
*** registry
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._core.registry
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_core/registry.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import sys
import weakref
from typing import Any, Dict, Iterable, Mapping, Optional, TypeVar, Union

from marimo._runtime.context.types import ContextNotInitializedError

#+END_SRC
**** Import statements
#+BEGIN_SRC python
if sys.version_info < (3, 10):
    from typing_extensions import TypeAlias
else:
    from typing import TypeAlias

from marimo._ast.app import _Namespace
from marimo._ast.cell import CellId_t
from marimo._plugins.ui._core.ui_element import UIElement
from marimo._runtime.context import get_context

#+END_SRC
**** Assignment UIElementId = str
#+BEGIN_SRC python
UIElementId = str

#+END_SRC
**** Assignment T = TypeVar("T")
#+BEGIN_SRC python
T = TypeVar("T")

#+END_SRC
**** Assignment LensValue: TypeAlias = Union[T, Dict[str, "LensValue[T]"]]
#+BEGIN_SRC python
# Recursive types don't support | or dict[] in py3.8/3.9
LensValue: TypeAlias = Union[T, Dict[str, "LensValue[T]"]]

#+END_SRC
**** Class UIElementRegistry
#+BEGIN_SRC python
class UIElementRegistry:
    def __init__(self) -> None:
        # mapping from object id to UIElement object that has that id
        self._objects: dict[UIElementId, weakref.ref[UIElement[Any, Any]]] = {}
        # mapping from object id to set of names that are bound to it
        self._bindings: dict[UIElementId, set[str]] = {}
        # mapping from object id to cell that created it
        self._constructing_cells: dict[UIElementId, CellId_t] = {}

    def register(
        self,
        object_id: UIElementId,
        ui_element: UIElement[Any, Any],
    ) -> None:
        execution_context = get_context().execution_context
        if object_id in self._objects:
            # on cell re-run, a UI element may be (re)-registered before
            # its destructor was called, so manually delete the old element
            # here
            self.delete(object_id, id(self._objects[object_id]))
        self._objects[object_id] = weakref.ref(ui_element)
        assert execution_context is not None
        self._constructing_cells[object_id] = execution_context.cell_id
        # bindings must be lazily registered, since there aren't any
        # bindings at UIElement object creation time
        if object_id in self._bindings:
            # If `register` is called on an object_id that is being
            # reused before `delete` is called, bindings won't have been
            # cleaned up
            del self._bindings[object_id]

    def bound_names(self, object_id: UIElementId) -> Iterable[str]:
        if object_id not in self._bindings:
            self._register_bindings(object_id)
        return self._bindings[object_id]

    def _has_parent_id(
        self, child: UIElement[Any, Any], parent_id: UIElementId
    ) -> bool:
        """Returns True if `child` has id `parent_id` or is a view of it"""
        if child._id == parent_id:
            return True
        elif child._lens is not None:
            element_ref = self._objects.get(child._lens.parent_id)
            element = element_ref() if element_ref is not None else None
            if element is not None:
                return self._has_parent_id(element, parent_id)
        return False

    def _find_bindings_in_namespace(
        self, object_id: UIElementId, glbls: Mapping[str, Any]
    ) -> set[str]:
        # Get all variable names that are either:
        #   1. bound to this UI element, or
        #   2. bound to a view (child) of this element
        #
        # Also introspects _Namespace objects, including the name of the
        # _Namespace if it contains `object_id`
        bindings: set[str] = set()
        for name, value in glbls.items():
            if isinstance(value, UIElement) and self._has_parent_id(
                value, object_id
            ):
                bindings.add(name)
            elif isinstance(
                value, _Namespace
            ) and self._find_bindings_in_namespace(object_id, value):
                bindings.add(name)
        return bindings

    def _register_bindings(
        self, object_id: UIElementId, glbls: Optional[dict[str, Any]] = None
    ) -> None:
        from marimo._runtime.context.kernel_context import KernelRuntimeContext

        ctx = get_context()
        if isinstance(ctx, KernelRuntimeContext) or glbls is not None:
            if glbls is None:
                glbls = ctx.globals
            self._bindings[object_id] = self._find_bindings_in_namespace(
                object_id, glbls
            )

    def register_scope(
        self, glbls: dict[str, Any], defs: Optional[set[str]] = None
    ) -> None:
        if defs is None:
            defs = set(glbls.keys())
        for binding in defs:
            lookup = glbls.get(binding, None)
            if isinstance(lookup, UIElement):
                self._register_bindings(lookup._id, glbls)

    def lookup(self, name: str) -> Optional[UIElement[Any, Any]]:
        for object_id, bindings in self._bindings.items():
            if name in bindings:
                return self.get_object(object_id)
        return None

    def get_object(self, object_id: UIElementId) -> UIElement[Any, Any]:
        if object_id not in self._objects:
            raise KeyError(f"UIElement with id {object_id} not found")
        obj = self._objects[object_id]()
        assert obj is not None
        return obj

    def get_cell(self, object_id: UIElementId) -> CellId_t:
        return self._constructing_cells[object_id]

    def resolve_lens(
        self, object_id: UIElementId, value: LensValue[T]
    ) -> tuple[str, LensValue[T]]:
        """Resolve a lens, if any, to an object id and value update

        Returns (resolved object id, resolved value)

        Raises KeyError if `object_id` does not exist in the registry,
        RuntimeError if the object was deleted.
        """
        if object_id not in self._objects:
            raise KeyError(f"UIElement with id {object_id} not found")
        obj = self._objects[object_id]()
        if obj is None:
            raise RuntimeError(f"UIElement with id {object_id} was deleted")

        lens = obj._lens
        if lens is None:
            # Base case: the element has no lens, so the resolved
            # update is the same as what was passed in.
            return (object_id, value)

        resolved_value = {lens.key: value}
        return self.resolve_lens(lens.parent_id, resolved_value)

    def delete(self, object_id: UIElementId, python_id: int) -> None:
        """Delete a UI element from the registry

        This function may be called by the Python garbage collector, while
        a cell is executing. For this reason we make sure not to log
        anything -- these logs would show up as console output in the
        frontend, confusing the user.
        """
        if object_id not in self._objects:
            return

        ui_element = self._objects[object_id]()
        # We guard against UIElement's destructor racing against
        # registration of another element when a cell re-runs by checking
        # the Python object id. This isn't perfect because python ids can
        # be reused ...
        registered_python_id = (
            id(ui_element) if ui_element is not None else None
        )
        if (
            registered_python_id is not None
            and registered_python_id != python_id
        ):
            return

        try:
            ctx = get_context()
        except ContextNotInitializedError:
            pass
        else:
            ctx.function_registry.delete(namespace=object_id)

        if object_id in self._bindings:
            del self._bindings[object_id]
        if object_id in self._constructing_cells:
            del self._constructing_cells[object_id]
        del self._objects[object_id]

#+END_SRC
*** ui_element
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._core.ui_element
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_core/ui_element.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import abc
import base64
import copy
import sys
import types
import uuid
import weakref
from dataclasses import dataclass, fields
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Generic,
    Optional,
    Sequence,
    TypeVar,
    cast,
)

from marimo import _loggers
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType, build_ui_plugin
from marimo._plugins.ui._core import ids
from marimo._runtime.context import (
    ContextNotInitializedError,
    RuntimeContext,
    get_context,
)
from marimo._runtime.functions import Function

#+END_SRC
**** Assignment S = TypeVar("S", bound=JSONType)
#+BEGIN_SRC python
if TYPE_CHECKING:
    from marimo._plugins.ui._impl.input import form as form_plugin

# S: Type of frontend value
#   - the initial value sent to the frontend must be of type S
#   - values received from the frontend must be of type S
S = TypeVar("S", bound=JSONType)

#+END_SRC
**** Assignment T = TypeVar("T")
#+BEGIN_SRC python
# T: Type of `UIElement.value`
#   - UIElement's `_convert_value` method is used to convert a frontend
#   value (of type S) to a value of type T
T = TypeVar("T")

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
**** @dataclass: Class Lens
#+BEGIN_SRC python
@dataclass
class Lens:
    """Track how a view of a higher-order element relates to its source

    Higher-order UI elements support lensing, ie extracting their children
    as "views". These views can be embedded in other outputs and interacted
    with.

    UI elements that are views of a higher-order element (eg, an entry of
    an array is a view of the array) have a lens object that stores the
    id of its parent UI element, and the key at which its parent stores it.
    """

    parent_id: str
    key: str

#+END_SRC
**** @dataclass: Class InitializationArgs
#+BEGIN_SRC python
@dataclass
class InitializationArgs(Generic[S, T]):
    component_name: str
    initial_value: S
    label: Optional[str]
    on_change: Optional[Callable[[T], None]]
    args: dict[str, JSONType]
    slotted_html: str
    functions: tuple[Function[Any, Any], ...]

#+END_SRC
**** Class MarimoConvertValueException
#+BEGIN_SRC python
class MarimoConvertValueException(Exception):
    pass

#+END_SRC
**** @mddoc: Class UIElement
#+BEGIN_SRC python
@mddoc
class UIElement(Html, Generic[S, T], metaclass=abc.ABCMeta):
    """An HTML element with a value

    A `UIElement` is an HTML element with a value; when the value of the
    element on the page changes, the value of the UIElement is updated as well.

    This is an abstract class. `UIElement`s are responsible for mapping values
    sent by the frontend (of type S) to values expected by the Python object
    (of type T): a subclass can be made concrete by implementing the
    `_convert_value` method.

    Type Parameters:

    - S: The type of the values sent by the frontend to the kernel; must be
         JSON-serializable
    - T: The type of the UIElement's value; can be any type

    **Attributes.**

    - value: The value of the `UIElement`.

    **Methods.**

    - form: create a submittable form this `UIElement`.
    """

    _value_frontend: S
    _value: T

    def __init__(
        self,
        component_name: str,
        initial_value: S,
        label: Optional[str],
        on_change: Optional[Callable[[T], None]],
        args: dict[str, JSONType],
        slotted_html: str = "",
        functions: tuple[Function[Any, Any], ...] = (),
    ) -> None:
        """Initialize a UIElement

        Args:
        ----
        component_name: tag name of the custom element
        initial_value: initial value of the element in the frontend
        label: markdown string, label of element
        on_change: callback, called with element's new value on change
        args: arguments that the element takes
        slotted_html: any html to slot in the custom element
        functions: any functions to register with the graph
        """
        # Validate parameters from a user
        if not isinstance(component_name, str):
            raise TypeError("component_name must be a string")
        if label is not None and not isinstance(label, str):
            raise TypeError("label must be a string or None")
        if on_change is not None and not callable(on_change):
            raise TypeError("on_change must be a callable or None")

        # arguments stored in signature order for cloning
        self._component_args = args
        self._args: InitializationArgs[S, T] = InitializationArgs(
            component_name=component_name,
            initial_value=initial_value,
            label=label,
            on_change=on_change,
            args=args,
            slotted_html=slotted_html,
            functions=functions,
        )
        self._initialized = False
        self._initialize(self._args)
        self._initialized = True

    def _initialize(
        self, initialization_args: InitializationArgs[S, T]
    ) -> None:
        """Initialize the UIElement

        Split out from __init__ so _clone() typechecks
        """
        (
            component_name,
            initial_value,
            label,
            on_change,
            args,
            slotted_html,
            functions,
        ) = (
            initialization_args.component_name,
            initialization_args.initial_value,
            initialization_args.label,
            initialization_args.on_change,
            initialization_args.args,
            initialization_args.slotted_html,
            initialization_args.functions,
        )
        # A UIElement may be a child ("lens") of another UI element.
        #
        # Set with self._register_as_view() after initialization, since parents
        # are usually created after the child is created
        self._lens: Lens | None = None

        # Random token
        #
        # Every element is annotated with a random token, which by design is
        # different every time the element is constructed (i.e., every time a
        # cell runs): this guarantees that re-running a cell that creates a UI
        # element will trigger a re-render and reset it to its initial value.
        # We need this to ensure that the element on the page is synchronized
        # with the element in the kernel.
        self._random_id = str(uuid.uuid4())

        # Stable ID
        #
        # Every element has an ID that is used for two purposes:
        #  - to synchronize multiple instances of the element on the page
        #  - to synchronize elements on the page with elements in the kernel
        #
        # IDs are stable across multiple sessions if the set of UI elements
        # created by each cell is deterministic; this fact is used to
        # optionally override the element's initial value.
        try:
            self._id = get_context().take_id()
        except (ids.NoIDProviderException, ContextNotInitializedError):
            self._id = self._random_id

        self._ctx: RuntimeContext | None
        try:
            # cache the context in case the UI element is constructed
            # in a nested context -- so that if the UI element is accessed
            # in the root context (eg with app_result.defs["elem"].value),
            # the correct constructing context is retrieved
            self._ctx = get_context()
        except ContextNotInitializedError:
            self._ctx = None
        else:
            # When the UI element is destructed, it should be removed
            # from the UIElementRegistry (which only holds a weakref to it).
            finalizer = weakref.finalize(
                self, self._ctx.ui_element_registry.delete, self._id, id(self)
            )
            # No need to clean up the registry at program teardown
            finalizer.atexit = False

        if self._ctx is not None:
            self._ctx.ui_element_registry.register(self._id, self)
            # an Instantiate request may want us to override the initial value
            try:
                # NB: If a cell produces a non-deterministic set of
                # UI elements, a UI element may be matched with an initial
                # value that was actually for some other element
                #
                # TODO(akshayka): validate the tag-name to make sure that the
                # value is at least the right type (ie, S)
                #
                # TODO(akshayka): parametrize UIElement with an optional
                # string ID, so users can provide their own IDs to make
                # sure a mismatch never happens ...
                initial_value = cast(
                    S, self._ctx.get_ui_initial_value(self._id)
                )
            except KeyError:
                # we weren't asked to override the UI element's value
                pass

            for function in functions:
                self._ctx.function_registry.register(
                    namespace=self._id, function=function
                )
        self._initial_value_frontend = initial_value
        self._value_frontend = initial_value
        self._value = self._initial_value = self._convert_value(initial_value)
        self._on_change = on_change
        self._component_args = args

        self._inner_text = build_ui_plugin(
            component_name,
            initial_value,
            label,
            args,
            slotted_html,
        )
        text = (
            f"<marimo-ui-element object-id='{self._id}' "
            + f"random-id='{self._random_id}'>"
            + self._inner_text
            + "</marimo-ui-element>"
        )
        super().__init__(text=text)

    @abc.abstractmethod
    def _convert_value(self, value: S) -> T:
        """Converts a value from the frontend to a value for the `UIElement`

        This method must convert `value`, the JSON-decoded value sent by the
        frontend, to a value of type `T` for the `UIElement`.
        """
        pass

    def _register_as_view(self, parent: UIElement[Any, Any], key: str) -> None:
        """Register this element as a view of `parent`."""
        self._lens = Lens(parent_id=parent._id, key=key)

    @property
    def value(self) -> T:
        """The element's current value."""
        if self._ctx is None:
            return self._value

        if (
            self._ctx.execution_context is not None
            and not self._ctx.execution_context.setting_element_value
            and (
                self._ctx.execution_context.cell_id
                == self._ctx.ui_element_registry.get_cell(self._id)
            )
        ):
            raise RuntimeError(
                "Accessing the value of a UIElement in the cell that created "
                "it is not allowed. Fix: move the value access to another "
                "cell."
            )
        return self._value

    @value.setter
    def value(self, value: T) -> None:
        del value
        raise RuntimeError(
            "Setting the value of a UIElement is not allowed. "
            "If you need to imperatively set the value of a UIElement, "
            "consider using mo.state()."
        )

    def __setattr__(self, name: str, value: Any) -> None:
        if name == "on_change":
            raise RuntimeError(
                "Setting the on_change handler of a UIElement is not allowed. "
                "You must set the on_change in the constructor."
            )
        super().__setattr__(name, value)

    @mddoc
    def form(
        self,
        label: str = "",
        *,
        bordered: bool = True,
        loading: bool = False,
        submit_button_label: str = "Submit",
        submit_button_tooltip: Optional[str] = None,
        submit_button_disabled: bool = False,
        clear_on_submit: bool = False,
        show_clear_button: bool = False,
        clear_button_label: str = "Clear",
        clear_button_tooltip: Optional[str] = None,
        validate: Optional[
            Callable[[Optional[JSONType]], Optional[str]]
        ] = None,
        on_change: Optional[Callable[[Optional[T]], None]] = None,
    ) -> form_plugin[S, T]:
        """Create a submittable form out of this `UIElement`.

        Use this method to create a form that gates the submission
        of a `UIElement`s value until a submit button is clicked.

        The value of the `form` is the value of the underlying
        element the last time the form was submitted.

        **Examples.**

        Convert any `UIElement` into a form:

        ```python
        prompt = mo.ui.text_area().form()
        ```

        Combine with `HTML.batch` to create a form made out of multiple
        `UIElements`:

        ```python
        form = (
            mo.ui.md(
                '''
            **Enter your prompt.**

            {prompt}

            **Choose a random seed.**

            {seed}
            '''
            )
            .batch(
                prompt=mo.ui.text_area(),
                seed=mo.ui.number(),
            )
            .form()
        )
        ```

        **Args.**

        - `label`: A text label for the form.
        - `bordered`: whether the form should have a border
        - `loading`: whether the form should be in a loading state
        - `submit_button_label`: the label of the submit button
        - `submit_button_tooltip`: the tooltip of the submit button
        - `submit_button_disabled`: whether the submit button should be
          disabled
        - `clear_on_submit`: whether the form should clear its contents after
            submitting
        - `show_clear_button`: whether the form should show a clear button
        - `clear_button_label`: the label of the clear button
        - `clear_button_tooltip`: the tooltip of the clear button
        - `validate`: a function that takes the form's value and returns an
            error message if the value is invalid,
            or `None` if the value is valid
        """
        from marimo._plugins.ui._impl.input import form as form_plugin

        return form_plugin(
            element=self,
            label=label,
            bordered=bordered,
            loading=loading,
            submit_button_label=submit_button_label,
            submit_button_tooltip=submit_button_tooltip,
            submit_button_disabled=submit_button_disabled,
            clear_on_submit=clear_on_submit,
            show_clear_button=show_clear_button,
            clear_button_label=clear_button_label,
            clear_button_tooltip=clear_button_tooltip,
            validate=validate,
            on_change=on_change,
        )

    def send_message(
        self, message: Dict[str, object], buffers: Optional[Sequence[bytes]]
    ) -> None:
        """
        Send a message to the element rendered on the frontend
        from the backend.
        """

        from marimo._messaging.ops import SendUIElementMessage

        SendUIElementMessage(
            ui_element=self._id,
            message=message,
            buffers=[
                base64.b64encode(buffer).decode() for buffer in (buffers or [])
            ],
        ).broadcast()

    def _update(self, value: S) -> None:
        """Update value, given a value from the frontend

        Calls the on_change handler with the element's new value as a
        side-effect.
        """
        self._value_frontend = value
        try:
            self._value = self._convert_value(value)
        except MarimoConvertValueException:
            raise

        if self._on_change is not None:
            self._on_change(self._value)

    def _on_update_completion(self) -> None:
        """Callback to run after the kernel has processed a value update."""
        return

    def __deepcopy__(self, memo: dict[int, Any]) -> UIElement[S, T]:
        # Custom deepcopy that excludes elements that can't be deepcopied
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            if isinstance(v, RuntimeContext):
                setattr(result, k, v)
            else:
                setattr(result, k, copy.deepcopy(v, memo))

        # Get a new object ID and function namespace
        #
        # We use the new instance's functions, since they are typically bound
        # to the UI element instance. But we only use the new on_change
        # if the old one was bound to self.
        args: InitializationArgs[S, T]
        if (
            isinstance(self._args.on_change, types.MethodType)
            and self._args.on_change.__self__ is self
        ):
            # on_change was bound to self; use the new one.
            args = InitializationArgs(
                **{
                    # dataclass asdict does a deepcopy, we want shallow.
                    **{
                        field.name: getattr(self._args, field.name)
                        for field in fields(self._args)
                    },
                    "on_change": result._args.on_change,
                    "functions": result._args.functions,
                }
            )
        else:
            # otherwise, use the original on_change, which may be a state
            # SetFunctor or something else unrelated to this instance.
            args = InitializationArgs(
                **{
                    **{
                        field.name: getattr(self._args, field.name)
                        for field in fields(self._args)
                    },
                    "functions": result._args.functions,
                }
            )
        result._initialize(args)
        return result

    def _clone(self) -> UIElement[S, T]:
        """Clone a UIElement, returning one with a different id

        The clone will not synchronize with the original element.

        Composite UIElement may need to override this method to run
        their own side-effects.
        """
        return copy.deepcopy(self)

    def __bool__(self) -> bool:
        sys.stderr.write(
            "The truth value of a UIElement is always True. You "
            "probably want to call `.value` instead."
        )
        return True

#+END_SRC
** _impl
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl
:END:
*** __init__
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.__init__
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/__init__.py
:END:
**** Comment
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.

#+END_SRC
*** altair_chart
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.altair_chart
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/altair_chart.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import sys
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Final,
    List,
    Literal,
    Optional,
    Union,
    cast,
)

import narwhals.stable.v1 as nw
from narwhals.typing import IntoDataFrame

from marimo import _loggers
from marimo._dependencies.dependencies import DependencyManager
from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import UIElement
from marimo._plugins.ui._impl.charts.altair_transformer import (
    register_transformers,
)
from marimo._utils import flatten
from marimo._utils.narwhals_utils import (
    assert_can_narwhalify,
    can_narwhalify,
    empty_df,
)

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment ChartSelectionField = Dict[str, Union[List[int], List[float], List[str]]]
#+BEGIN_SRC python
if TYPE_CHECKING:
    import altair  # type: ignore[import-not-found,import-untyped,unused-ignore] # noqa: E501

# Selection is a dictionary of the form:
# {
#   "signal_channel": {
#     "field": ["value1", "value2", ...]
#   }
# }
ChartSelectionField = Dict[str, Union[List[int], List[float], List[str]]]

#+END_SRC
**** Assignment ChartSelection = Dict[str, ChartSelectionField]
#+BEGIN_SRC python
ChartSelection = Dict[str, ChartSelectionField]

#+END_SRC
**** Assignment VegaSpec = Dict[str, Any]
#+BEGIN_SRC python
VegaSpec = Dict[str, Any]

#+END_SRC
**** Assignment RowOrientedData = List[Dict[str, Any]]
#+BEGIN_SRC python
RowOrientedData = List[Dict[str, Any]]

#+END_SRC
**** Assignment ColumnOrientedData = Dict[str, List[Any]]
#+BEGIN_SRC python
ColumnOrientedData = Dict[str, List[Any]]

#+END_SRC
**** Assignment ChartDataType = Union[IntoDataFrame, RowOrientedData, ColumnOrientedData]
#+BEGIN_SRC python
ChartDataType = Union[IntoDataFrame, RowOrientedData, ColumnOrientedData]

#+END_SRC
**** Function _has_binning
#+BEGIN_SRC python
def _has_binning(spec: VegaSpec) -> bool:
    """Return True if the spec has binning."""
    if "encoding" not in spec:
        return False
    for encoding in spec["encoding"].values():
        if "bin" in encoding:
            return True
    return False

#+END_SRC
**** Function _has_geoshape
#+BEGIN_SRC python
def _has_geoshape(spec: altair.TopLevelMixin) -> bool:
    """Return True if the spec has geoshape."""
    try:
        if not hasattr(spec, "mark"):
            return False
        mark = spec.mark  # type: ignore
        return mark == "geoshape" or mark.type == "geoshape"  # type: ignore
    except Exception:
        return False

#+END_SRC
**** Function _filter_dataframe
#+BEGIN_SRC python
def _filter_dataframe(
    native_df: IntoDataFrame, selection: ChartSelection
) -> IntoDataFrame:
    df = nw.from_native(native_df)
    if not isinstance(selection, dict):
        raise TypeError("Input 'selection' must be a dictionary")

    for channel, fields in selection.items():
        if not isinstance(channel, str) or not isinstance(fields, dict):
            raise ValueError(
                f"Invalid selection format for channel: {channel}"
            )

        # Don't filter on pan_zoom
        if channel.startswith("pan_zoom"):
            continue

        # This is a case when altair does not pass back the fields to filter on
        # and instead passes an individual selected point.
        if len(fields) == 2 and "vlPoint" in fields and "_vgsid_" in fields:
            # Vega is 1-indexed, so subtract 1
            try:
                indexes = [int(i) - 1 for i in fields["_vgsid_"]]
                df = cast(nw.DataFrame[Any], df)[indexes]
            except (ValueError, IndexError) as e:
                raise ValueError(
                    f"Invalid index in selection: {fields['_vgsid_']}"
                ) from e
            continue

        # If vlPoint is in the selection,
        # then the selection is a point selection
        # otherwise, it is an interval selection
        is_point_selection = "vlPoint" in fields
        for field, values in fields.items():
            # values may come back as strings if using the CSV transformer;
            # convert back to original datatype
            if field in ("vlPoint", "_vgsid_"):
                continue

            if field not in df.columns:
                raise ValueError(f"Field '{field}' not found in DataFrame")

            dtype = df[field].dtype
            resolved_values = _resolve_values(values, dtype)

            if is_point_selection:
                df = df.filter(nw.col(field).is_in(resolved_values))
            elif len(resolved_values) == 1:
                df = df.filter(nw.col(field) == resolved_values[0])
            # Range selection
            elif len(resolved_values) == 2 and _is_numeric(values[0]):
                left_value, right_value = resolved_values
                df = df.filter(
                    (nw.col(field) >= left_value)
                    & (nw.col(field) <= right_value)
                )
            # Multi-selection via range
            # This can happen when you use an interval selection
            # on categorical data
            elif len(resolved_values) > 1:
                df = df.filter(nw.col(field).is_in(resolved_values))
            else:
                raise ValueError(
                    f"Invalid selection: {field}={resolved_values}"
                )

    return nw.to_native(df)

#+END_SRC
**** Function _resolve_values
#+BEGIN_SRC python
def _resolve_values(values: Any, dtype: Any) -> List[Any]:
    def _coerce_value(value: Any, dtype: Any) -> Any:
        import datetime

        if nw.Date == dtype:
            # Value is milliseconds since epoch
            return datetime.date.fromtimestamp(value / 1000)
        if nw.Datetime == dtype:
            # Value is milliseconds since epoch
            return datetime.datetime.fromtimestamp(value / 1000)
        return value

    if isinstance(values, list):
        return [_coerce_value(v, dtype) for v in values]
    return [_coerce_value(values, dtype)]

#+END_SRC
**** Function _is_numeric
#+BEGIN_SRC python
def _is_numeric(value: Any) -> bool:
    if isinstance(value, (int, float)):
        return True

    if DependencyManager.numpy.has():
        import numpy as np

        if isinstance(value, np.number):
            return True

    return False

#+END_SRC
**** Function _parse_spec
#+BEGIN_SRC python
def _parse_spec(spec: altair.TopLevelMixin) -> VegaSpec:
    import altair

    # vegafusion requires creating a vega spec,
    # instead of using a vega-lite spec
    if altair.data_transformers.active.startswith("vegafusion"):
        return spec.to_dict(format="vega")  # type: ignore

    # If this is a geoshape, use default transformer
    # since ours does not support geoshapes
    if _has_geoshape(spec):
        with altair.data_transformers.enable("default"):
            return spec.to_dict()  # type: ignore

    with altair.data_transformers.enable("marimo"):
        return spec.to_dict()  # type: ignore

#+END_SRC
**** Function _has_transforms
#+BEGIN_SRC python
def _has_transforms(spec: VegaSpec) -> bool:
    """Return True if the spec has transforms."""
    return "transform" in spec and len(spec["transform"]) > 0

#+END_SRC
**** @mddoc: Class altair_chart
#+BEGIN_SRC python
@mddoc
class altair_chart(UIElement[ChartSelection, ChartDataType]):
    """Make reactive charts with Altair

    Use `mo.ui.altair_chart` to make Altair charts reactive: select chart data
    with your cursor on the frontend, get them as a dataframe in Python!

    Supports polars, pandas, and arrow DataFrames.

    **Example.**

    ```python
    import altair as alt
    import marimo as mo
    from vega_datasets import data

    chart = (
        alt.Chart(data.cars())
        .mark_point()
        .encode(
            x="Horsepower",
            y="Miles_per_Gallon",
            color="Origin",
        )
    )

    chart = mo.ui.altair_chart(chart)
    ```

    ```
    # View the chart and selected data as a dataframe
    mo.hstack([chart, chart.value])
    ```

    **Attributes.**

    - `value`: a dataframe of the plot data filtered by the selections
    - `dataframe`: a dataframe of the unfiltered chart data
    - `selections`: the selection of the chart; this may be an interval along
       the name of an axis or a selection of points

    **Initialization Args.**

    - `chart`: An `altair.Chart`
    - `chart_selection`: optional selection type,
        `"point"`, `"interval"`, or a bool; defaults to `True` which will
        automatically detect the best selection type.
        This is ignored if the chart already has a point/interval selection param.
    - `legend_selection`: optional list of legend fields (columns) for which to
        enable selection, `True` to enable selection for all fields, or
        `False` to disable selection entirely.
        This is ignored if the chart already has a legend selection param.
    - `label`: optional markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """

    name: Final[str] = "marimo-vega"

    def __init__(
        self,
        chart: altair.Chart,
        chart_selection: Literal["point"] | Literal["interval"] | bool = True,
        legend_selection: list[str] | bool = True,
        *,
        label: str = "",
        on_change: Optional[Callable[[ChartDataType], None]] = None,
    ) -> None:
        DependencyManager.altair.require(why="to use `mo.ui.altair_chart`")

        import altair as alt

        register_transformers()

        self._chart = chart

        if not isinstance(chart, (alt.TopLevelMixin)):
            raise ValueError(
                "Invalid type for chart: "
                f"{type(chart)}; expected altair.Chart"
            )

        # Make full-width if no width is specified
        chart = maybe_make_full_width(chart)

        vega_spec = _parse_spec(chart)

        if label:
            vega_spec["title"] = label

        # Fix the sizing for vconcat charts
        if "vconcat" in vega_spec:
            for subchart in vega_spec["vconcat"]:
                if "width" not in subchart:
                    subchart["width"] = "container"
            # without autosize, vconcat will overflow
            if "autosize" not in vega_spec:
                vega_spec["autosize"] = "fit-x"

        # Types say this is not possible,
        # but a user still may pass none
        if chart_selection is None:  # type: ignore
            chart_selection = False
        if legend_selection is None:  # type: ignore
            legend_selection = False

        # If the chart already has a selection param,
        # we don't add any more
        if _has_selection_param(chart):
            # Log a warning if the user has set chart_selection
            # but the chart already has a selection param
            if isinstance(chart_selection, str):
                sys.stderr.write(
                    f"Warning: chart already has a selection param. "
                    f"Ignoring chart_selection={chart_selection}"
                )
            chart_selection = False
        if _has_legend_param(chart):
            # Log a warning if the user has set legend_selection
            # but the chart already has a legend param
            if (
                isinstance(legend_selection, list)
                and len(legend_selection) > 0
            ):
                sys.stderr.write(
                    f"Warning: chart already has a legend param. "
                    f"Ignoring legend_selection={legend_selection}"
                )
            legend_selection = False

        # Selection for binned charts is not yet implemented
        has_chart_selection = chart_selection is not False
        has_legend_selection = legend_selection is not False
        if _has_binning(vega_spec) and (
            has_chart_selection or has_legend_selection
        ):
            sys.stderr.write(
                "Binning + selection is not yet supported in "
                "marimo.ui.chart.\n"
                "If you'd like this feature, please file an issue: "
                "https://github.com/marimo-team/marimo/issues\n"
            )
            chart_selection = False
            legend_selection = False
        if _has_geoshape(vega_spec) and (has_chart_selection):
            sys.stderr.write(
                "Geoshapes + chart selection is not yet supported in "
                "marimo.ui.chart.\n"
                "If you'd like this feature, please file an issue: "
                "https://github.com/marimo-team/marimo/issues\n"
            )
            chart_selection = False

        self.dataframe: Optional[ChartDataType] = (
            self._get_dataframe_from_chart(chart)
        )

        self._spec = vega_spec

        super().__init__(
            component_name="marimo-vega",
            initial_value={},
            label=label,
            args={
                "spec": vega_spec,
                "chart-selection": chart_selection,
                "field-selection": legend_selection,
            },
            on_change=on_change,
        )

    @property
    def selections(self) -> ChartSelection:
        return self._chart_selection

    @staticmethod
    def _get_dataframe_from_chart(
        chart: altair.Chart,
    ) -> Optional[ChartDataType]:
        if not isinstance(chart.data, str):
            return cast(ChartDataType, chart.data)

        url = chart.data

        if DependencyManager.polars.imported():
            import polars as pl

            if url.endswith(".csv"):
                return pl.read_csv(url)
            if url.endswith(".json"):
                import urllib.request

                # polars read_json does not support urls
                with urllib.request.urlopen(chart.data) as response:
                    return pl.read_json(response)

        if DependencyManager.pandas.imported():
            import pandas as pd

            if url.endswith(".csv"):
                return pd.read_csv(url)
            if url.endswith(".json"):
                return pd.read_json(url)

        import altair

        if chart.data is altair.Undefined:
            return None

        return cast(ChartDataType, chart.data)

    def _convert_value(self, value: ChartSelection) -> ChartDataType:
        self._chart_selection = value
        flat, _ = flatten.flatten(value)
        if not value or not flat:
            if self.dataframe is None:
                return []
            if isinstance(self.dataframe, list):
                return []
            if isinstance(self.dataframe, dict):
                return {}
            return empty_df(self.dataframe)

        # When using layered charts, you can no longer access the
        # chart data directly
        # Instead, we should push user to call .apply_selection(df)
        if not can_narwhalify(self.dataframe):
            return self.dataframe  # type: ignore

        # If we have transforms, we need to filter the dataframe
        # with those transforms, before applying the selection
        if _has_transforms(self._spec):
            try:
                df: Any = self._chart.transformed_data()
                return _filter_dataframe(df, value)
            except ImportError as e:
                sys.stderr.write(
                    "Failed to filter dataframe that includes a transform. "
                    + "This could be due to a missing dependency.\n\n"
                    + e.msg
                )
                # Fall back to the untransformed dataframe
                return _filter_dataframe(self.dataframe, value)

        return _filter_dataframe(self.dataframe, value)

    def apply_selection(self, df: ChartDataType) -> ChartDataType:
        """Apply the selection to a DataFrame.

        This method is useful when you have a layered chart and you want to
        apply the selection to a DataFrame.

        **Example.**

        ```python
        import altair as alt
        import marimo as mo
        from vega_datasets import data

        cars = data.cars()

        _chart = (
            alt.Chart(cars)
            .mark_point()
            .encode(
                x="Horsepower",
                y="Miles_per_Gallon",
                color="Origin",
            )
        )

        chart = mo.ui.altair_chart(_chart)
        chart

        # In another cell
        selected_df = chart.apply_selection(cars)
        ```

        **Args.**

        - `df`: a DataFrame to apply the selection to

        **Returns.**

        - a DataFrame of the plot data filtered by the selections
        """
        assert assert_can_narwhalify(df)
        return _filter_dataframe(df, self.selections)

    # Proxy all of altair's attributes
    def __getattr__(self, name: str) -> Any:
        return getattr(self._chart, name)

    def __add__(self, other: Any) -> Any:
        if isinstance(other, altair_chart):
            other = other._chart
        return altair_chart(self._chart + other)

    def __or__(self, value: Any) -> Any:
        if isinstance(value, altair_chart):
            value = value._chart
        return altair_chart(self._chart | value)

    def __radd__(self, other: Any) -> Any:
        if isinstance(other, altair_chart):
            other = other._chart
        return altair_chart(other + self._chart)

    def __ror__(self, value: Any) -> Any:
        if isinstance(value, altair_chart):
            value = value._chart
        return altair_chart(value | self._chart)

    def __and__(self, value: Any) -> Any:
        if isinstance(value, altair_chart):
            value = value._chart
        return altair_chart(self._chart & value)

    @property
    def value(self) -> ChartDataType:
        from altair import Undefined

        value = super().value
        if value is Undefined:
            sys.stderr.write(
                "The underlying chart data is not available in layered"
                " or stacked charts. "
                "Use `.apply_selection(df)` to filter a DataFrame"
                " based on the selection.",
            )
        return value

    @value.setter
    def value(self, value: ChartDataType) -> None:
        del value
        raise RuntimeError("Setting the value of a UIElement is not allowed.")

#+END_SRC
**** Function maybe_make_full_width
#+BEGIN_SRC python
def maybe_make_full_width(chart: altair.Chart) -> altair.Chart:
    import altair

    try:
        if (
            isinstance(chart, (altair.Chart, altair.LayerChart))
            and chart.width is altair.Undefined
        ):
            return chart.properties(width="container")
        return chart
    except Exception:
        LOGGER.exception(
            "Failed to set width to full container. "
            "This is likely due to a missing dependency or an invalid chart."
        )
        return chart

#+END_SRC
**** Function _has_selection_param
#+BEGIN_SRC python
def _has_selection_param(chart: altair.Chart) -> bool:
    import altair as alt

    try:
        for param in chart.params:
            try:
                if isinstance(
                    param,
                    (alt.SelectionParameter, alt.TopLevelSelectionParameter),
                ):
                    if param.bind is alt.Undefined:
                        return True
            except Exception:
                pass
    except Exception:
        pass
    return False

#+END_SRC
**** Function _has_legend_param
#+BEGIN_SRC python
def _has_legend_param(chart: altair.Chart) -> bool:
    import altair as alt

    try:
        for param in chart.params:
            try:
                if isinstance(
                    param,
                    (alt.SelectionParameter, alt.TopLevelSelectionParameter),
                ):
                    if param.bind == "legend":
                        return True
            except Exception:
                pass
    except Exception:
        pass
    return False

#+END_SRC
*** array
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.array
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/array.py
:END:
**** @mddoc: Class array
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Callable, Dict, Final, Iterator, Optional, Sequence

from marimo._output.formatters.structures import format_structure
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType
from marimo._plugins.stateless.flex import hstack, vstack
from marimo._plugins.stateless.json_output import json_output
from marimo._plugins.ui._core.ui_element import UIElement


# Frontend type is a tuple (index, value update)
# Python type is a sequence of values, one for each UI element
@mddoc
class array(UIElement[Dict[str, JSONType], Sequence[object]]):
    """
    An array of UI elements.

    Use an array to

    - create a dynamic number of UI elements at runtime
    - group together logically related UI elements
    - keep the number of global variables in your program small

    Access the values of the elements using the `value` attribute of the array
    (`array.value`).

    The elements in the array can be accessed using square brackets
    (`array[index]`) and embedded in other marimo outputs. You can also
    iterate over the UI elements using the `in` operator (`for element in
    array`).

    Note: The UI elements in the array are clones of the original elements:
    interacting with the array will _not_ update the original elements, and
    vice versa.

    **Examples.**

    A heterogeneous collection of UI elements:

    ```python
    array = mo.ui.array([mo.ui.slider(1, 10), mo.ui.text(), mo.ui.date()])
    ```

    Get the values of the `slider`, `text`, and `date` elements via
    `array.value`:

    ```python
    # array.value returns a list with the values of the elements
    array.value
    ```

    Access and output a UI element in the array:

    ```python
    mo.md(f"This is a slider: array[0]")
    ```

    Some number of UI elements, determined at runtime:

    ```python
    mo.ui.array([mo.ui.slider(1, 10) for _ in range random.randint(4, 8)])
    ```

    **Attributes.**

    - `value`: a list containing the values of the array's entries
    - `elements`: a list of the wrapped elements (clones of the originals)

    **Initialization Args.**

    - `elements`: the UI elements to include
    - `label`: a descriptive name for the array
    - `on_change`: optional callback to run when this element's value changes
    """

    _name: Final[str] = "marimo-dict"

    def __init__(
        self,
        elements: Sequence[UIElement[Any, Any]],
        *,
        label: str = "",
        on_change: Optional[Callable[[Sequence[object]], None]] = None,
    ) -> None:
        self._elements = [e._clone() for e in elements]
        self._label = label
        slotted_html = json_output(
            json_data=format_structure(self._elements),
            name="array" if not label else label,
        )
        super().__init__(
            component_name=array._name,
            initial_value={
                str(index): e._initial_value_frontend
                for index, e in enumerate(self._elements)
            },
            label=label,
            args={
                "element-ids": {
                    e._id: str(i) for i, e in enumerate(self._elements)
                },
            },
            slotted_html=slotted_html.text,
            on_change=on_change,
        )

        for i, element in enumerate(self._elements):
            element._register_as_view(self, key=str(i))

    @property
    def elements(self) -> Sequence[UIElement[JSONType, object]]:
        return self._elements

    def _convert_value(self, value: dict[str, JSONType]) -> Sequence[object]:
        if self._initialized:
            for k, v in value.items():
                element = self._elements[int(k)]
                # only call update if the value has changed
                if element._value_frontend != v:
                    element._update(v)
        return [e._value for e in self._elements]

    def _clone(self) -> array:
        return array(
            elements=self.elements,
            label=self._label,
            on_change=self._on_change,
        )

    def __len__(self) -> int:
        return len(self.elements)

    def __getitem__(self, key: int) -> UIElement[JSONType, object]:
        return self.elements[key]

    def __iter__(self) -> Iterator[UIElement[JSONType, object]]:
        return self.elements.__iter__()

    def __reversed__(self) -> Iterator[UIElement[JSONType, object]]:
        return self.elements.__reversed__()

    def __contains__(self, item: UIElement[JSONType, object]) -> bool:
        return item in self.elements

    def hstack(self, **kwargs: Any) -> Html:
        """
        Stack the elements horizontally.

        For kwargs, see `marimo.hstack`.
        """
        return hstack(items=self.elements, **kwargs)

    def vstack(self, **kwargs: Any) -> Html:
        """
        Stack the elements vertically.

        For kwargs, see `marimo.vstack`.
        """
        return vstack(items=self.elements, **kwargs)

#+END_SRC
*** batch
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.batch
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/batch.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Final,
    Iterator,
    Optional,
)

from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType
from marimo._plugins.ui._core.ui_element import UIElement

#+END_SRC
**** Class _batch_base
#+BEGIN_SRC python
if TYPE_CHECKING:
    from collections.abc import ItemsView, ValuesView


# - Frontend type is a dict {label => value update}
# - Python type is a dict mapping label -> value
class _batch_base(UIElement[Dict[str, JSONType], Dict[str, object]]):
    """
    A batch of named UI elements represented by HTML text.
    """

    _name: Final[str] = "marimo-dict"

    def __init__(
        self,
        html: Html,
        elements: dict[str, UIElement[JSONType, object]],
        label: str = "",
        on_change: Optional[Callable[[Dict[str, object]], None]] = None,
    ) -> None:
        self._elements = elements
        super().__init__(
            component_name=_batch_base._name,
            initial_value={
                key: e._initial_value_frontend
                for key, e in self._elements.items()
            },
            label=label,
            args={
                "element-ids": {
                    e._id: key for key, e in self._elements.items()
                },
            },
            slotted_html=html.text,
            on_change=on_change,
        )

        for key, element in self._elements.items():
            element._register_as_view(parent=self, key=key)

    @property
    def elements(self) -> dict[str, UIElement[JSONType, object]]:
        return self._elements

    def __len__(self) -> int:
        return len(self.elements)

    def __getitem__(self, key: str) -> UIElement[JSONType, object]:
        return self.elements[key]

    def __iter__(self) -> Iterator[str]:
        return self.elements.__iter__()

    def __reversed__(self) -> Iterator[str]:
        return self.elements.__reversed__()

    def __contains__(self, item: str) -> bool:
        return item in self.elements

    def get(self, key: str, default: Any | None = None) -> Any:
        return self.elements.get(key, default)

    def items(self) -> ItemsView[str, UIElement[JSONType, object]]:
        return self.elements.items()

    def values(self) -> ValuesView[UIElement[JSONType, object]]:
        return self.elements.values()

    def _convert_value(self, value: dict[str, JSONType]) -> dict[str, object]:
        if self._initialized:
            for k, v in value.items():
                element = self._elements[k]
                # only call update if the value has changed
                if element._value_frontend != v:
                    element._update(v)
        return {
            key: wrapped_element._value
            for key, wrapped_element in self._elements.items()
        }

#+END_SRC
**** @mddoc: Class batch
#+BEGIN_SRC python
@mddoc
class batch(_batch_base):
    """
    Convert an HTML object with templated text into a UI element.

    A `batch` is a UI element that wraps other UI elements, and is
    represented by custom HTML or markdown. You can create
    a `batch` by calling the `batch()` method on `Html` objects.

    Get the value of the wrapped UI elements using the `value` attribute
    of the batch.

    **Example.**

    In the below example, `user_info` is a UI Element whose output is markdown
    and whose value is a dict with keys `'name'` and `'birthday'`
    (and values equal to the values of their corresponding elements).


    ```python3
    user_info = mo.md(
        '''
        - What's your name?: {name}
        - When were you born?: {birthday}
        '''
    ).batch(name=mo.ui.text(), birthday=mo.ui.date())
    ```

    To get the value of `name` and `birthday`, use:

    ```
    user_info.value
    ```

    You can also instantiate this class directly:

    ```python3
    markdown = mo.md(
        '''
        - What's your name?: {name}
        - When were you born?: {birthday}
        '''
    )
    batch = mo.ui.batch(
        markdown, {"name": mo.ui.text(), "birthday": mo.ui.date()}
    )
    ```

    **Attributes.**

    - `value`: a `dict` of the batched elements' values
    - `elements`: a `dict` of the batched elements (clones of the originals)
    - `on_change`: optional callback to run when this element's value changes

    **Initialization Args.**

    - html: a templated `Html` object
    - elements: the UI elements to interpolate into the HTML template
    - `on_change`: optional callback to run when this element's value changes
    """

    def __init__(
        self,
        html: Html,
        elements: dict[str, UIElement[Any, Any]],
        on_change: Optional[Callable[[Dict[str, object]], None]] = None,
    ) -> None:
        self._html = html
        elements = {key: element._clone() for key, element in elements.items()}
        super().__init__(
            html=Html(self._html.text.format(**elements)),
            elements=elements,
            on_change=on_change,
        )

    def _clone(self) -> batch:
        return batch(html=self._html, elements=self.elements)

#+END_SRC
*** comm
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.comm
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/comm.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import base64
from typing import Any, Callable, Dict, List, Optional

#+END_SRC
**** Class MarimoCommManager
#+BEGIN_SRC python
class MarimoCommManager:
    comms: Dict[str, "MarimoComm"] = {}

    def register_comm(self, comm: "MarimoComm") -> str:
        comm_id = comm.comm_id
        self.comms[comm_id] = comm
        return comm_id

    def unregister_comm(self, comm: "MarimoComm") -> "MarimoComm":
        return self.comms.pop(comm.comm_id)

#+END_SRC
**** Assignment MsgCallback = Callable[[Dict[str, object]], None]
#+BEGIN_SRC python
MsgCallback = Callable[[Dict[str, object]], None]

#+END_SRC
**** Assignment DataType = Optional[Dict[str, object]]
#+BEGIN_SRC python
DataType = Optional[Dict[str, object]]

#+END_SRC
**** Assignment MetadataType = Optional[Dict[str, object]]
#+BEGIN_SRC python
MetadataType = Optional[Dict[str, object]]

#+END_SRC
**** Assignment BufferType = Optional[List[bytes]]
#+BEGIN_SRC python
BufferType = Optional[List[bytes]]

#+END_SRC
**** Assignment COMM_MESSAGE_NAME = "marimo_comm_msg"
#+BEGIN_SRC python
COMM_MESSAGE_NAME = "marimo_comm_msg"

#+END_SRC
**** Assignment COMM_OPEN_NAME = "marimo_comm_open"
#+BEGIN_SRC python
COMM_OPEN_NAME = "marimo_comm_open"

#+END_SRC
**** Assignment COMM_CLOSE_NAME = "marimo_comm_close"
#+BEGIN_SRC python
COMM_CLOSE_NAME = "marimo_comm_close"

#+END_SRC
**** Class MarimoComm
#+BEGIN_SRC python
# Compare to `ipykernel.comm.Comm`
#  (uses the marimo context instead of a Kernel to send/receive messages).
# Also note that `ipywidgets.widgets.Widget` is responsible to
#  calling these methods when need be.
class MarimoComm:
    # `ipywidgets.widgets.Widget` does some checks for
    # `if self.comm.kernel is not None`
    kernel = "marimo"

    _msg_callback: Optional[MsgCallback]
    _close_callback: Optional[MsgCallback]
    _closed: bool = False
    _closed_data: Dict[str, object] = {}

    def __init__(
        self,
        comm_id: str,
        comm_manager: MarimoCommManager,
        target_name: str,
        data: DataType = None,
        metadata: MetadataType = None,
        buffers: BufferType = None,
        **keys: object,
    ) -> None:
        self.comm_id = comm_id
        self.comm_manager = comm_manager
        self.target_name = target_name
        self.open(data=data, metadata=metadata, buffers=buffers, **keys)
        self.ui_element_id: Optional[str] = None
        self._publish_message_buffer: list[Any] = []

    def open(
        self,
        data: DataType = None,
        metadata: MetadataType = None,
        buffers: BufferType = None,
        **keys: object,
    ) -> None:
        self.comm_manager.register_comm(self)
        try:
            self._publish_msg(
                COMM_OPEN_NAME,
                data=data,
                metadata=metadata,
                buffers=buffers,
                target_name=self.target_name,
                target_module=None,
                **keys,
            )
            self._closed = False
        except Exception:
            self.comm_manager.unregister_comm(self)
            raise

    # Inform client of any mutation(s) to the model
    # (e.g., add a marker to a map, without a full redraw)
    def send(
        self,
        data: DataType = None,
        metadata: MetadataType = None,
        buffers: BufferType = None,
    ) -> None:
        self._publish_msg(
            COMM_MESSAGE_NAME,
            data=data,
            metadata=metadata,
            buffers=buffers,
        )

    def close(
        self,
        data: DataType = None,
        metadata: MetadataType = None,
        buffers: BufferType = None,
        deleting: bool = False,
    ) -> None:
        if self._closed:
            return
        self._closed = True
        data = self._closed_data if data is None else data
        self._publish_msg(
            COMM_CLOSE_NAME,
            data=data,
            metadata=metadata,
            buffers=buffers,
        )
        if not deleting:
            # If deleting, the comm can't be unregistered
            self.comm_manager.unregister_comm(self)

    # trigger close on gc
    def __del__(self) -> None:
        self.close(deleting=True)

    # Compare to `ipykernel.comm.Comm._publish_msg`, but...
    # https://github.com/jupyter/jupyter_client/blob/c5c0b80/jupyter_client/session.py#L749
    # ...the real meat of the implement
    #   is in `jupyter_client.session.Session.send`
    # https://github.com/jupyter/jupyter_client/blob/c5c0b8/jupyter_client/session.py#L749-L862
    def _publish_msg(
        self,
        msg_type: str,
        data: DataType = None,
        metadata: MetadataType = None,
        buffers: BufferType = None,
        **keys: object,
    ) -> None:
        del keys
        data = {} if data is None else data
        metadata = {} if metadata is None else metadata
        buffers = [] if buffers is None else buffers

        if msg_type == COMM_MESSAGE_NAME:
            self._publish_message_buffer.append((data, metadata, buffers))
            self.flush()

    def flush(self) -> None:
        if not self.ui_element_id:
            # If there is no ui_element_id, then it has not been rendered
            # to the frontend, and just exists in python
            # We can drop these instead of holding onto them.
            self._publish_message_buffer = []
            return

        from marimo._messaging.ops import SendUIElementMessage

        while self._publish_message_buffer:
            data, _metadata, buffers = self._publish_message_buffer.pop(0)

            SendUIElementMessage(
                ui_element=self.ui_element_id,
                message=data,
                buffers=[
                    base64.b64encode(buffer).decode() for buffer in buffers
                ],
            ).broadcast()

    # This is the method that ipywidgets.widgets.Widget uses to respond to
    # client-side changes
    def on_msg(self, callback: MsgCallback) -> None:
        self._msg_callback = callback

    def on_close(self, callback: MsgCallback) -> None:
        self._close_callback = callback

    def handle_msg(self, msg: Dict[str, object]) -> None:
        if self._msg_callback is not None:
            self._msg_callback(msg)

    def handle_close(self, msg: Dict[str, object]) -> None:
        if self._close_callback is not None:
            self._close_callback(msg)

#+END_SRC
*** data_editor
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.data_editor
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/data_editor.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import ast
import datetime
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Final,
    List,
    Optional,
    TypedDict,
    Union,
    cast,
)

import narwhals.stable.v1 as nw
from narwhals.typing import IntoDataFrame

import marimo._output.data.data as mo_data
from marimo import _loggers
from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import UIElement
from marimo._plugins.ui._impl.tables.utils import get_table_manager

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
**** @dataclass: Class DataEditorValue
#+BEGIN_SRC python
if TYPE_CHECKING:
    from narwhals.dtypes import DType


@dataclass
class DataEditorValue:
    # Row-oriented data
    data: List[Dict[str, Any]]

#+END_SRC
**** Class PositionalEdit
#+BEGIN_SRC python
class PositionalEdit(TypedDict):
    rowIdx: int
    columnId: str
    value: Any

#+END_SRC
**** Class DataEdits
#+BEGIN_SRC python
class DataEdits(TypedDict):
    edits: List[PositionalEdit]

#+END_SRC
**** Assignment RowOrientedData = List[Dict[str, Any]]
#+BEGIN_SRC python
RowOrientedData = List[Dict[str, Any]]

#+END_SRC
**** Assignment ColumnOrientedData = Dict[str, List[Any]]
#+BEGIN_SRC python
ColumnOrientedData = Dict[str, List[Any]]

#+END_SRC
**** @mddoc: Class data_editor
#+BEGIN_SRC python
@mddoc
class data_editor(
    UIElement[
        DataEdits,
        Union[RowOrientedData, ColumnOrientedData, IntoDataFrame],
    ]
):
    """
    **[EXPERIMENTAL]**

    This component is experimental and intentionally limited in features,
    if you have any feature requests, please file an issue at
    https://github.com/marimo-team/marimo/issues.

    A data editor component for editing tabular data.

    The data can be supplied as:
    1. a Pandas, Polars, or Pyarrow DataFrame
    2. a list of dicts, with one dict for each row, keyed by column names
    3. a dict of lists, with each list representing a column

    **Examples.**

    Create a data editor from a Pandas dataframe:

    ```python
    import pandas as pd

    df = pd.DataFrame({"A": [1, 2, 3], "B": ["a", "b", "c"]})
    editor = mo.ui.experimental_data_editor(data=df, label="Edit Data")
    ```

    Create a data editor from a list of dicts:

    ```python
    data = [{"A": 1, "B": "a"}, {"A": 2, "B": "b"}, {"A": 3, "B": "c"}]
    editor = mo.ui.experimental_data_editor(data=data, label="Edit Data")
    ```

    Create a data editor from a dict of lists:

    ```python
    data = {"A": [1, 2, 3], "B": ["a", "b", "c"]}
    editor = mo.ui.experimental_data_editor(data=data, label="Edit Data")
    ```

    **Attributes.**

    - `value`: the current state of the edited data
    - `data`: the original data passed to the editor

    **Initialization Args.**

    - `data`: The data to be edited. Can be a Pandas dataframe,
        a list of dicts, or a dict of lists.
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """

    _name: Final[str] = "marimo-data-editor"

    LIMIT: Final[int] = 1000

    def __init__(
        self,
        data: Union[RowOrientedData, ColumnOrientedData, IntoDataFrame],
        *,
        pagination: bool = True,
        page_size: int = 50,
        label: str = "",
        on_change: Optional[
            Callable[
                [Union[RowOrientedData, ColumnOrientedData, IntoDataFrame]],
                None,
            ]
        ] = None,
    ) -> None:
        table_manager = get_table_manager(data)

        size = table_manager.get_num_rows()
        if size is None or size > self.LIMIT:
            raise ValueError(
                f"Data editor supports a maximum of {self.LIMIT} rows."
            )

        self._data = data
        self._edits: DataEdits | None = None
        field_types = table_manager.get_field_types()

        super().__init__(
            component_name=data_editor._name,
            label=label,
            initial_value={"edits": []},
            args={
                "data": mo_data.csv(table_manager.to_csv()).url,
                "field-types": field_types or None,
                "pagination": pagination,
                "page-size": page_size,
            },
            on_change=on_change,
        )

    @property
    def data(
        self,
    ) -> Union[RowOrientedData, ColumnOrientedData, IntoDataFrame]:
        return self._data

    def _convert_value(
        self, value: DataEdits
    ) -> Union[RowOrientedData, ColumnOrientedData, IntoDataFrame]:
        self._edits = value
        return apply_edits(self._data, value)

    def __hash__(self) -> int:
        return id(self)

#+END_SRC
**** Function apply_edits
#+BEGIN_SRC python
def apply_edits(
    data: Union[RowOrientedData, ColumnOrientedData, IntoDataFrame],
    edits: DataEdits,
    schema: Optional[nw.Schema] = None,
) -> Union[RowOrientedData, ColumnOrientedData, IntoDataFrame]:
    if len(edits["edits"]) == 0:
        return data
    # If row-oriented, apply edits to the data
    if isinstance(data, list):
        return _apply_edits_row_oriented(data, edits, schema)
    # If column-oriented, apply edits to the data
    elif isinstance(data, dict):
        return _apply_edits_column_oriented(data, edits, schema)

    try:
        return _apply_edits_dataframe(data, edits, schema)
    except Exception as e:
        raise ValueError(
            f"Data editor does not support this type of data: {type(data)}"
        ) from e

#+END_SRC
**** Function _apply_edits_column_oriented
#+BEGIN_SRC python
def _apply_edits_column_oriented(
    data: ColumnOrientedData,
    edits: DataEdits,
    schema: Optional[nw.Schema] = None,
) -> ColumnOrientedData:
    for edit in edits["edits"]:
        column = data[edit["columnId"]]
        if edit["rowIdx"] >= len(column):
            # Extend the column with None values up to the new row index
            column.extend([None] * (edit["rowIdx"] - len(column) + 1))
        dtype = schema.get(edit["columnId"]) if schema else None
        column[edit["rowIdx"]] = _convert_value(
            edit["value"], column[0] if column else None, dtype
        )

    return data

#+END_SRC
**** Function _apply_edits_row_oriented
#+BEGIN_SRC python
def _apply_edits_row_oriented(
    data: RowOrientedData,
    edits: DataEdits,
    schema: Optional[nw.Schema] = None,
) -> RowOrientedData:
    for edit in edits["edits"]:
        if edit["rowIdx"] >= len(data):
            # Create a new row with None values for all columns
            new_row = {col: None for col in data[0].keys()}
            data.append(new_row)
        original_value = data[0][edit["columnId"]] if data else None
        dtype = schema.get(edit["columnId"]) if schema else None
        data[edit["rowIdx"]][edit["columnId"]] = _convert_value(
            edit["value"], original_value, dtype
        )

    return data

#+END_SRC
**** Function _apply_edits_dataframe
#+BEGIN_SRC python
def _apply_edits_dataframe(
    native_df: IntoDataFrame, edits: DataEdits, schema: Optional[nw.Schema]
) -> IntoDataFrame:
    df = nw.from_native(native_df, eager_or_interchange_only=True)
    column_oriented = df.to_dict(as_series=False)
    schema = schema or cast(nw.Schema, df.schema)
    new_data = _apply_edits_column_oriented(column_oriented, edits, schema)
    native_namespace = nw.get_native_namespace(df)
    new_native_df = nw.from_dict(
        new_data, native_namespace=native_namespace
    ).to_native()
    return new_native_df  # type: ignore[no-any-return]

#+END_SRC
**** Function _convert_value
#+BEGIN_SRC python
def _convert_value(
    value: Any,
    original_value: Any,
    dtype: Optional[DType] = None,
) -> Any:
    try:
        if dtype is not None:
            if dtype == nw.Datetime:
                return datetime.datetime.fromisoformat(value)
            elif dtype == nw.Date:
                return datetime.date.fromisoformat(value)
            elif dtype == nw.Duration:
                return datetime.timedelta(microseconds=float(value))
            elif dtype == nw.Float32:
                return float(value)
            elif dtype == nw.Float64:
                return float(value)
            elif dtype == nw.Int16:
                return int(value)
            elif dtype == nw.Int32:
                return int(value)
            elif dtype == nw.Int64:
                return int(value)
            elif dtype == nw.UInt16:
                return int(value)
            elif dtype == nw.UInt32:
                return int(value)
            elif dtype == nw.UInt64:
                return int(value)
            elif dtype == nw.String:
                return str(value)
            elif dtype == nw.Enum:
                return str(value)
            elif dtype == nw.Categorical:
                return str(value)
            elif dtype == nw.Boolean:
                return bool(value)
            elif dtype == nw.List:
                # Handle list conversion
                if isinstance(value, str):
                    # Attempt to parse string as a list
                    try:
                        return list(ast.literal_eval(value))
                    except (ValueError, SyntaxError):
                        # If parsing fails, split the string
                        return value.split(",")
                elif isinstance(value, list):
                    return value  # type: ignore
                else:
                    # If it's not a string or list, wrap it in a list
                    return [value]
            else:
                LOGGER.warning(f"Unsupported dtype: {dtype}")
                return str(value)

        if original_value is None:
            return value

        # Try to convert the value to the original type
        original_type: Any = type(original_value)

        if isinstance(original_value, (int, float)):
            return original_type(value)
        elif isinstance(original_value, str):
            return str(value)
        elif isinstance(original_value, (datetime.date)):
            return datetime.date.fromisoformat(value)
        elif isinstance(original_value, (datetime.datetime)):
            return datetime.datetime.fromisoformat(value)
        elif isinstance(original_value, (datetime.timedelta)):
            return datetime.timedelta(microseconds=float(value))
        elif isinstance(original_value, list):
            # Handle list conversion
            if isinstance(value, str):
                # Attempt to parse string as a list
                try:
                    return list(ast.literal_eval(value))
                except (ValueError, SyntaxError):
                    # If parsing fails, split the string
                    return list(value.split(","))
            elif isinstance(value, list):
                return value  # type: ignore[return-value]
            else:
                # If it's not a string or list, wrap it in a list
                return [value]
        else:
            return value
    except ValueError as e:
        LOGGER.error(str(e))
        # If conversion fails, return the original value
        return original_value  # type: ignore[return-value]

#+END_SRC
*** data_explorer
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.data_explorer
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/data_explorer.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2023 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING, Any, Callable, Dict, Final, Optional

import marimo._output.data.data as mo_data
from marimo._dependencies.dependencies import DependencyManager
from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import UIElement
from marimo._plugins.ui._impl.tables.utils import get_table_manager

#+END_SRC
**** @mddoc: Class data_explorer
#+BEGIN_SRC python
if TYPE_CHECKING:
    from narwhals.typing import IntoDataFrame


@mddoc
class data_explorer(UIElement[Dict[str, Any], Dict[str, Any]]):
    """
    Quickly explore a DataFrame with automatically suggested visualizations.

    **Example.**

    ```python
    mo.ui.data_explorer(data)
    ```

    **Attributes.**

    - `value`: the resulting DataFrame chart spec

    **Initialization Args.**

    - `df`: the DataFrame to visualize
    """

    _name: Final[str] = "marimo-data-explorer"

    def __init__(
        self,
        df: IntoDataFrame,
        on_change: Optional[Callable[[Dict[str, Any]], None]] = None,
    ) -> None:
        # Drop the index since empty column names break the data explorer
        df = _drop_index(df)
        self._data = df

        manager = get_table_manager(df)

        super().__init__(
            component_name=data_explorer._name,
            initial_value={},
            on_change=on_change,
            label="",
            args={
                "data": mo_data.csv(manager.to_csv()).url,
            },
        )

    def _convert_value(self, value: Dict[str, Any]) -> Dict[str, Any]:
        return value

#+END_SRC
**** Function _drop_index
#+BEGIN_SRC python
def _drop_index(df: IntoDataFrame) -> IntoDataFrame:
    if DependencyManager.pandas.imported():
        import pandas as pd

        if isinstance(df, pd.DataFrame):
            return df.reset_index(drop=True)
    return df

#+END_SRC
*** dates
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.dates
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/dates.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import datetime as dt
from typing import (
    Any,
    Callable,
    Final,
    Optional,
    Tuple,
    Union,
    cast,
)

from marimo import _loggers
from marimo._data.series import (
    DataFrameSeries,
    get_date_series_info,
    get_datetime_series_info,
)
from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import UIElement

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment Numeric = Union[int, float]
#+BEGIN_SRC python
Numeric = Union[int, float]

#+END_SRC
**** @mddoc: Class date
#+BEGIN_SRC python
@mddoc
class date(UIElement[str, dt.date]):
    """
    A date picker with an optional start and stop date.

    **Example.**

    ```python
    # initialize the date picker at a given date
    date = mo.ui.date(value="2022-01-01")
    ```

    ```python
    # when value is omitted, date picker initializes with today's date
    date = mo.ui.date()
    ```

    ```python
    # create a date picker with bounds
    date = mo.ui.date(
        value="2022-06-01",
        start="2022-01-01",
        stop="2022-12-31",
    )
    ```

    Or from a dataframe series:

    ```python
    date = mo.ui.date.from_series(df["column_name"])
    ```

    **Attributes.**

    - `value`: a str (YYYY-MM-DD) or `datetime.date` object of the chosen date
    - `start`: the start date
    - `stop`: the stop date

    **Initialization Args.**

    - `start`: minimum date selectable; if None, defaults to 01-01-0001
    - `stop`: maximum date selectable; if None, defaults to 12-31-9999
    - `value`: default date
        - if `None` and `start` and `stop` are `None`, defaults to the
          current day;
        - else if `None` and `start` is not `None`, defaults to `start`;
        - else if `None` and `stop` is not `None`, defaults to `stop`
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of its
        container
    """

    _name: Final[str] = "marimo-date"

    DATE_FORMAT = "%Y-%m-%d"

    def __init__(
        self,
        start: Optional[dt.date | str] = None,
        stop: Optional[dt.date | str] = None,
        value: Optional[dt.date | str] = None,
        *,
        label: str = "",
        on_change: Optional[Callable[[dt.date], None]] = None,
        full_width: bool = False,
    ) -> None:
        if isinstance(start, str):
            start = self._convert_value(start)
        if isinstance(stop, str):
            stop = self._convert_value(stop)
        if isinstance(value, str):
            value = self._convert_value(value)

        if value is None:
            if start is None and stop is None:
                value = dt.date.today()
            elif start is not None:
                value = start
            else:
                value = stop
        value = cast(dt.date, value)

        self._start = dt.date(dt.MINYEAR, 1, 1) if start is None else start
        self._stop = dt.date(dt.MAXYEAR, 12, 31) if stop is None else stop

        if self._stop < self._start:
            raise ValueError(
                f"The stop date ({stop}) must be greater than "
                f"the start date ({start})"
            )
        elif value < self._start or value > self._stop:
            raise ValueError(
                f"The default value ({value}) must be greater than "
                f"the start date ({start}) and less than the stop "
                f"date ({stop})."
            )

        super().__init__(
            component_name=date._name,
            initial_value=value.isoformat(),
            label=label,
            args={
                "start": self._start.isoformat(),
                "stop": self._stop.isoformat(),
                "full-width": full_width,
            },
            on_change=on_change,
        )

    @staticmethod
    def from_series(series: DataFrameSeries, **kwargs: Any) -> "date":
        """Create a date picker from a dataframe series."""
        info = get_date_series_info(series)
        start = kwargs.pop("start", info.min)
        stop = kwargs.pop("stop", info.max)
        label = kwargs.pop("label", info.label)
        return date(start=start, stop=stop, label=label, **kwargs)

    def _convert_value(self, value: str) -> dt.date:
        # Catch different initialization formats
        if isinstance(value, dt.date):
            return value
        if isinstance(value, dt.datetime):
            return value.date()
        return dt.datetime.strptime(value, self.DATE_FORMAT).date()

    @property
    def start(self) -> dt.date:
        return self._start

    @property
    def stop(self) -> dt.date:
        return self._stop

#+END_SRC
**** @mddoc: Class datetime
#+BEGIN_SRC python
@mddoc
class datetime(UIElement[Optional[str], Optional[dt.datetime]]):
    """
    A datetime picker over an interval.

    **Example.**

    ```python
    datetime_picker = mo.ui.datetime(
        start=dt.datetime(2023, 1, 1),
        stop=dt.datetime(2023, 12, 31, 23, 59, 59),
    )
    ```

    Or from a dataframe series:

    ```python
    datetime_picker = mo.ui.datetime.from_series(df["datetime_column"])
    ```

    **Attributes.**

    - `value`: the selected datetime, possibly `None`
    - `start`: the minimum selectable datetime
    - `stop`: the maximum selectable datetime

    **Initialization Args.**

    - `start`: the minimum selectable datetime (default: minimum datetime)
    - `stop`: the maximum selectable datetime (default: maximum datetime)
    - `value`: default value
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of
      its container
    """

    _name: Final[str] = "marimo-datetime"
    DATETIME_FORMAT: Final[str] = "%Y-%m-%dT%H:%M:%S"

    def __init__(
        self,
        start: Optional[dt.datetime | str] = None,
        stop: Optional[dt.datetime | str] = None,
        value: Optional[dt.datetime | str] = None,
        *,
        label: Optional[str] = None,
        on_change: Optional[Callable[[Optional[dt.datetime]], None]] = None,
        full_width: bool = False,
    ):
        if isinstance(start, str):
            start = self._convert_value(start)
        if isinstance(stop, str):
            stop = self._convert_value(stop)
        if isinstance(value, str):
            value = self._convert_value(value)

        self._start = dt.datetime.min if start is None else start
        self._stop = dt.datetime.max if stop is None else stop

        if self._stop < self._start:
            raise ValueError(
                f"The stop datetime ({stop}) must be greater than "
                f"the start datetime ({start})"
            )

        if value is None:
            if start is None and stop is None:
                value = dt.datetime.today()
            elif start is not None:
                value = start
            else:
                value = stop
        value = cast(dt.datetime, value)

        if value < self._start or value > self._stop:
            raise ValueError(
                f"The default value ({value}) must be greater than "
                f"the start datetime ({start}) and less than the stop "
                f"datetime ({stop})."
            )

        super().__init__(
            component_name=datetime._name,
            initial_value=value.isoformat(timespec="seconds"),
            label=label,
            args={
                "start": self._start.strftime(self.DATETIME_FORMAT),
                "stop": self._stop.strftime(self.DATETIME_FORMAT),
                "full-width": full_width,
            },
            on_change=on_change,
        )

    @staticmethod
    def from_series(series: DataFrameSeries, **kwargs: Any) -> "datetime":
        """Create a datetime picker from a dataframe series."""
        info = get_datetime_series_info(series)
        start = kwargs.pop("start", info.min)
        stop = kwargs.pop("stop", info.max)
        label = kwargs.pop("label", info.label)
        return datetime(start=start, stop=stop, label=label, **kwargs)

    def _convert_value(self, value: Optional[str]) -> Optional[dt.datetime]:
        if value is None:
            return None
        POSSIBLE_FORMATS = [
            self.DATETIME_FORMAT,
            "%Y-%m-%d",
            "%Y-%m-%dT%H",
            "%Y-%m-%dT%H:%M",
            "%Y-%m-%dT%H:%M:%S",
            "%Y-%m-%dT%H:%M:%S.%f",
        ]
        for fmt in POSSIBLE_FORMATS:
            try:
                return dt.datetime.strptime(value, fmt)
            except ValueError:
                pass
        raise ValueError(f"Invalid datetime format: {value}")

    @property
    def start(self) -> dt.datetime:
        return self._start

    @property
    def stop(self) -> dt.datetime:
        return self._stop

#+END_SRC
**** @mddoc: Class date_range
#+BEGIN_SRC python
@mddoc
class date_range(UIElement[Tuple[str, str], Tuple[dt.date, dt.date]]):
    """
    A date range picker over an interval.

    **Example.**

    ```python
    date_range = mo.ui.date_range(
        start=dt.date(2023, 1, 1), stop=dt.date(2023, 12, 31)
    )
    ```

    Or from a dataframe series:

    ```python
    date_range = mo.ui.date_range.from_series(df["date_column"])
    ```

    **Attributes.**

    - `value`: a tuple of two dates representing the selected range
    - `start`: the minimum selectable date
    - `stop`: the maximum selectable date

    **Initialization Args.**

    - `start`: the minimum selectable date (default: minimum date)
    - `stop`: the maximum selectable date (default: maximum date)
    - `value`: default value (tuple of two dates)
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of its
      container
    """

    _name: Final[str] = "marimo-date-range"
    DATEFORMAT: Final[str] = "%Y-%m-%d"

    def __init__(
        self,
        start: Optional[dt.date | str] = None,
        stop: Optional[dt.date | str] = None,
        value: Optional[Tuple[dt.date, dt.date] | Tuple[str, str]] = None,
        *,
        label: Optional[str] = None,
        on_change: Optional[Callable[[Tuple[dt.date, dt.date]], None]] = None,
        full_width: bool = False,
    ):
        if isinstance(start, str):
            start = self._convert_single_value(start)
        if isinstance(stop, str):
            stop = self._convert_single_value(stop)
        if value is not None:
            value = self._convert_value(value)

        self._start = dt.date(dt.MINYEAR, 1, 1) if start is None else start
        self._stop = dt.date(dt.MAXYEAR, 12, 31) if stop is None else stop

        if self._stop < self._start:
            raise ValueError(
                f"The stop date ({stop}) must be greater than "
                f"the start date ({start})"
            )

        if value is None:
            value = (dt.date.today(), dt.date.today())
        elif (
            value[0] < self._start
            or value[1] > self._stop
            or value[0] > value[1]
        ):
            raise ValueError(
                f"The default value ({value}) must be within "
                f"the range [{start}, {stop}] and the first date "
                f"must not be greater than the second date."
            )

        super().__init__(
            component_name=date_range._name,
            initial_value=(value[0].isoformat(), value[1].isoformat()),
            label=label,
            args={
                "start": self._start.isoformat(),
                "stop": self._stop.isoformat(),
                "full-width": full_width,
            },
            on_change=on_change,
        )

    @staticmethod
    def from_series(series: DataFrameSeries, **kwargs: Any) -> "date_range":
        """Create a date range picker from a dataframe series."""
        info = get_date_series_info(series)
        start = kwargs.pop("start", info.min)
        stop = kwargs.pop("stop", info.max)
        label = kwargs.pop("label", info.label)
        return date_range(start=start, stop=stop, label=label, **kwargs)

    def _convert_value(
        self, value: Tuple[str, str] | Tuple[dt.date, dt.date]
    ) -> Tuple[dt.date, dt.date]:
        return (
            self._convert_single_value(value[0]),
            self._convert_single_value(value[1]),
        )

    def _convert_single_value(self, value: str | dt.date) -> dt.date:
        if isinstance(value, dt.date):
            return value
        if isinstance(value, dt.datetime):
            return value.date()
        return dt.datetime.strptime(value, self.DATEFORMAT).date()

    @property
    def start(self) -> dt.date:
        return self._start

    @property
    def stop(self) -> dt.date:
        return self._stop

#+END_SRC
*** dictionary
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.dictionary
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/dictionary.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Callable, Optional

from marimo._output.formatters.structures import format_structure
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.stateless.flex import hstack, vstack
from marimo._plugins.stateless.json_output import json_output
from marimo._plugins.ui._core.ui_element import UIElement
from marimo._plugins.ui._impl.batch import _batch_base

#+END_SRC
**** @mddoc: Class dictionary
#+BEGIN_SRC python
@mddoc
class dictionary(_batch_base):
    """
    A dictionary of UI elements.

    Use a dictionary to

    - create a set of UI elements at runtime
    - group together logically related UI elements
    - keep the number of global variables in your program small

    Access the values of the elements using the `value` attribute of the
    dictionary.

    The elements in the dictionary can be accessed using square brackets
    (`dictionary[key]`) and embedded in other marimo outputs. You can also
    iterate over the UI elements using the same syntax used for Python dicts.

    Note: The UI elements in the dictionary are clones of the original
    elements: interacting with the dictionary will _not_ update the original
    elements, and vice versa.

    The main reason to use mo.ui.dictionary is for reactive execution  when you
    interact with an element in a mo.ui.dictionary, all cells that reference the
    mo.ui.dictionary run automatically, just like all other ui elements. When you
    use a regular dictionary, you don't get this reactivity.

    **Examples.**

    A heterogeneous collection of UI elements:

    ```python
    d = mo.ui.dictionary(
        {
            "slider": mo.ui.slider(1, 10),
            "text": mo.ui.text(),
            "date": mo.ui.date(),
        }
    )
    ```

    Get the values of the `slider`, `text`, and `date` elements via
    `d.value`:

    ```python
    # d.value returns a dict with keys "slider", "text", "date"
    d.value
    ```

    Access and output a UI element in the array:

    ```python
    mo.md(f"This is a slider: {d['slider']}")
    ```

    Some number of UI elements, determined at runtime:

    ```python
    mo.ui.dictionary(
        {
            f"option {i}": mo.ui.slider(1, 10)
            for i in range(random.randint(4, 8))
        }
    )
    ```

    Quick layouts of UI elements:

    ```python
    mo.ui.dictionary(
        {
            f"option {i}": mo.ui.slider(1, 10)
            for i in range(random.randint(4, 8))
        }
    ).vstack()  # Can also use `hstack`, `callout`, `center`, etc.
    ```

    **Attributes.**

    - `value`: a dict holding the values of the UI elements, keyed by
               their names.
    - `elements`: a dict of the wrapped elements (clones of the originals)
    - `on_change`: optional callback to run when this element's value changes

    **Initialization Args.**

    - `elements`: a dict mapping names to UI elements to include
    - `label`: a descriptive name for the dictionary
       to trigger value updates
    """

    def __init__(
        self,
        elements: dict[str, UIElement[Any, Any]],
        *,
        label: str = "",
        on_change: Optional[Callable[[dict[str, object]], None]] = None,
    ) -> None:
        # Why we clone the wrapped elements:
        #
        # We don't have good semantics for embedding the original
        # elements into the dictionary. Here are some complications
        # with doing that:
        #
        # 1. Interacting with an element in the dict might cause the cell
        # that created the dict to re-run (if the element were declared
        # in another cell), causing the dict to be destroyed and recreated
        # with a new object-id, which in turn will re-initialize the dict
        # and interrupt all interactivity
        #
        # 2. Interacting with the original element in another cell may
        # again cause the dict to be destroyed/recreated; moreover, the
        # interaction will not update the value of the dictionary (unless
        # additional logic were added to the frontend DictPlugin to spy on
        # marimoValueUpdateEvents of children), and in any case will not
        # trigger cells that ref the dictionary to run, leading to confusion
        elements = {key: element._clone() for key, element in elements.items()}

        self._label = label
        # slot a JSON tree viewer as the contents of this element
        slotted_html = json_output(
            json_data=format_structure(elements),
            name="dictionary" if not label else label,
        )
        super().__init__(
            html=slotted_html,
            elements=elements,
            label=label,
            on_change=on_change,
        )

    def _clone(self) -> dictionary:
        """Custom clone method so new dict gets copies of UI elements."""
        return dictionary(
            self.elements, label=self._label, on_change=self._on_change
        )

    def hstack(self, **kwargs: Any) -> Html:
        """
        Stack the elements horizontally.

        For kwargs, see `marimo.hstack`.
        """
        return hstack(items=list(self.elements.values()), **kwargs)

    def vstack(self, **kwargs: Any) -> Html:
        """
        Stack the elements vertically.

        For kwargs, see `marimo.vstack`.
        """
        return vstack(items=list(self.elements.values()), **kwargs)

#+END_SRC
*** from_anywidget
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.from_anywidget
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/from_anywidget.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import weakref
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any, Dict, Optional

import marimo._output.data.data as mo_data
from marimo import _loggers
from marimo._output.rich_help import mddoc
from marimo._plugins.core.json_encoder import WebComponentEncoder
from marimo._plugins.ui._core.ui_element import InitializationArgs, UIElement
from marimo._plugins.ui._impl.comm import MarimoComm
from marimo._runtime.functions import Function

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from anywidget import (  # type: ignore [import-not-found,unused-ignore]  # noqa: E501
        AnyWidget,
    )

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment cache: Dict[Any, UIElement[Any, Any]] = weakref.WeakKeyDictionary()
#+BEGIN_SRC python
# Weak dictionary
# When the widget is deleted, the UIElement will be deleted as well
cache: Dict[Any, UIElement[Any, Any]] = weakref.WeakKeyDictionary()

#+END_SRC
**** Function from_anywidget
#+BEGIN_SRC python
# type: ignore[no-untyped-call, unused-ignore, assignment]  # noqa: E501


def from_anywidget(widget: "AnyWidget") -> UIElement[Any, Any]:
    """Create a UIElement from an AnyWidget."""
    if widget not in cache:
        cache[widget] = anywidget(widget)  # type: ignore[no-untyped-call, unused-ignore, assignment]  # noqa: E501
    return cache[widget]

#+END_SRC
**** Assignment T = Dict[str, Any]
#+BEGIN_SRC python
T = Dict[str, Any]

#+END_SRC
**** @dataclass: Class SendToWidgetArgs
#+BEGIN_SRC python
@dataclass
class SendToWidgetArgs:
    content: Any
    buffers: Optional[Any] = None

#+END_SRC
**** @mddoc: Class anywidget
#+BEGIN_SRC python
@mddoc
class anywidget(UIElement[T, T]):
    """
    Create a UIElement from an AnyWidget.
    This proxies all the widget's attributes and methods.

    **Example.**

    ```python
    from drawdata import ScatterWidget
    import marimo as mo

    scatter = ScatterWidget()
    scatter = mo.ui.anywidget(scatter)

    # In another cell, access its value
    # This works for all widgets
    scatter.value

    # Or attributes specifically on the ScatterWidget
    scatter.data_as_pandas
    scatter.data_as_polars
    ```

    **Attributes.**

    - `value`: The value of the widget's traits as a dictionary.
    - `widget`: The widget being wrapped.

    **Initialization Args.**

    - `widget`: The widget to wrap.
    """

    def __init__(self, widget: "AnyWidget"):
        self.widget = widget
        # This gets set to True in super().__init__()
        self._initialized = False

        # Get all the traits of the widget
        args: T = widget.trait_values()
        ignored_traits = [
            "comm",
            "layout",
            "log",
            "tabbable",
            "tooltip",
            "keys",
            "_esm",
            "_css",
            "_anywidget_id",
            "_msg_callbacks",
            "_dom_classes",
            "_model_module",
            "_model_module_version",
            "_model_name",
            "_property_lock",
            "_states_to_send",
            "_view_count",
            "_view_module",
            "_view_module_version",
            "_view_name",
        ]
        # Remove ignored traits
        for trait_name in ignored_traits:
            args.pop(trait_name, None)
        # Keep only classes that are json serialize-able
        json_args: T = {}
        for k, v in args.items():
            try:
                # Try to see if it is json-serializable
                WebComponentEncoder.json_dumps(v)
                # Just add the plain value, it will be json-serialized later
                json_args[k] = v
            except TypeError:
                pass
            except ValueError:
                # Handle circular dependencies
                pass

        js: str = widget._esm if hasattr(widget, "_esm") else ""  # type: ignore [unused-ignore]  # noqa: E501
        css: str = widget._css if hasattr(widget, "_css") else ""  # type: ignore [unused-ignore]  # noqa: E501
        import ipywidgets  # type: ignore

        _remove_buffers = ipywidgets.widgets.widget._remove_buffers  # type: ignore
        _state, buffer_paths, buffers = _remove_buffers(widget.get_state())  # type: ignore

        def on_change(change: T) -> None:
            _put_buffers = ipywidgets.widgets.widget._put_buffers  # type: ignore
            _put_buffers(change, buffer_paths, buffers)
            widget.set_state(change)

        super().__init__(
            component_name="marimo-anywidget",
            initial_value=json_args,
            label="",
            args={
                "js-url": mo_data.js(js).url if js else "",  # type: ignore [unused-ignore]  # noqa: E501
                "css": css,
                "buffer-paths": buffer_paths,
            },
            on_change=on_change,
            functions=(
                Function(
                    name="send_to_widget",
                    arg_cls=SendToWidgetArgs,
                    function=self._receive_from_frontend,
                ),
            ),
        )

    def _initialize(
        self,
        initialization_args: InitializationArgs[
            Dict[str, Any], Dict[str, Any]
        ],
    ) -> None:
        super()._initialize(initialization_args)
        # Add the ui_element_id after the widget is initialized
        comm = self.widget.comm
        if isinstance(comm, MarimoComm):
            comm.ui_element_id = self._id

    def _receive_from_frontend(self, args: SendToWidgetArgs) -> None:
        self.widget._handle_custom_msg(args.content, args.buffers)

    def _convert_value(self, value: T) -> T:
        return value

    # After the widget has been initialized
    # forward all setattr to the widget
    def __setattr__(self, name: str, value: Any) -> None:
        if self._initialized:
            # If the widget has the attribute, set it
            if hasattr(self.widget, name):
                return setattr(self.widget, name, value)
            return super().__setattr__(name, value)
        return super().__setattr__(name, value)

    # After the widget has been initialized
    # forward all getattr to the widget
    def __getattr__(self, name: str) -> Any:
        if name in ("widget", "_initialized"):
            try:
                return self.__getattribute__(name)
            except AttributeError:
                return None
        return getattr(self.widget, name)

#+END_SRC
*** from_panel
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.from_panel
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/from_panel.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import base64
import sys
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    List,
    Optional,
    Tuple,
    Type,
    TypeVar,
    cast,
)

from marimo import _loggers
from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import InitializationArgs, UIElement
from marimo._plugins.ui._impl.comm import MarimoComm, MarimoCommManager
from marimo._runtime.functions import Function

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
if TYPE_CHECKING:
    from panel.viewable import Viewable

LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment COMM_MANAGER = MarimoCommManager()
#+BEGIN_SRC python
COMM_MANAGER = MarimoCommManager()

#+END_SRC
**** Assignment comm_class: Optional[Type[Any]] = None
#+BEGIN_SRC python
comm_class: Optional[Type[Any]] = None

#+END_SRC
**** Assignment loaded_extension: int = 0
#+BEGIN_SRC python
loaded_extension: int = 0

#+END_SRC
**** Assignment loaded_extensions: list[str] = []
#+BEGIN_SRC python
loaded_extensions: list[str] = []

#+END_SRC
**** Assignment T = TypeVar("T", bound=Dict[str, Any])
#+BEGIN_SRC python
T = TypeVar("T", bound=Dict[str, Any])

#+END_SRC
**** @dataclass: Class SendToWidgetArgs
#+BEGIN_SRC python
@dataclass
class SendToWidgetArgs:
    message: Any
    buffers: Optional[List[Any]] = None

#+END_SRC
**** Function _get_comm_class
#+BEGIN_SRC python
# Singleton, we only create one instance of this class
def _get_comm_class() -> Type[Any]:
    global comm_class
    if comm_class:
        return comm_class

    from pyviz_comms import Comm  # type: ignore

    class MarimoPanelComm(Comm):  # type: ignore
        def __init__(self, *args: Any, **kwargs: Any):
            super().__init__(*args, **kwargs)
            self._comm = MarimoComm(
                comm_id=str(self.id),
                target_name="panel.comms",
                data={},
                comm_manager=COMM_MANAGER,
            )
            self._comm.on_msg(self._handle_msg)
            if self._on_open:
                self._on_open({})

        @classmethod
        def decode(cls, msg: SendToWidgetArgs) -> dict[str, Any]:
            buffers: Dict[int, Any] = {
                i: memoryview(base64.b64decode(v))
                for i, v in enumerate(msg.buffers or [])
            }
            return dict(msg.message, _buffers=buffers)

        def send(
            self, data: Any = None, metadata: Any = None, buffers: Any = None
        ) -> None:
            buffers = buffers or []
            self.comm.send(
                {"content": data}, metadata=metadata, buffers=buffers
            )

    comm_class = MarimoPanelComm
    return comm_class

#+END_SRC
**** Function render_extension
#+BEGIN_SRC python
def render_extension(load_timeout: int = 500, loaded: bool = False) -> str:
    """
    Render Panel extension JavaScript.

    Args:
        load_timeout: Timeout for loading resources (in milliseconds)
        loaded: Whether the extension has been loaded before

    Returns:
        JavaScript code for Panel extension
    """
    from panel.config import panel_extension

    new_exts: list[str] = [
        ext
        for ext in panel_extension._loaded_extensions
        if ext not in loaded_extensions
    ]
    if loaded and not new_exts:
        return ""

    from bokeh.io.notebook import curstate  # type: ignore
    from bokeh.resources import CDN, INLINE
    from bokeh.settings import settings
    from panel.config import config
    from panel.io.notebook import (  # type: ignore
        Resources,
        _autoload_js,
        _Unset,
        bundle_resources,
        require_components,
        state,
    )

    curstate().output_notebook()

    resources = INLINE if config.inline else CDN
    prev_resources = settings.resources(default="server")
    user_resources = settings.resources._user_value is not _Unset
    nb_endpoint = not state._is_pyodide
    resources = Resources.from_bokeh(resources, notebook=nb_endpoint)  # type: ignore[no-untyped-call]

    try:
        bundle = bundle_resources(  # type: ignore[no-untyped-call]
            None,
            resources,
            notebook=nb_endpoint,
            reloading=loaded,
            enable_mathjax="auto",
        )
        configs, requirements, exports, skip_imports = require_components()  # type: ignore[no-untyped-call]
        ipywidget = "ipywidgets_bokeh" in sys.modules
        bokeh_js = _autoload_js(  # type: ignore[no-untyped-call]
            bundle=bundle,
            configs=configs,
            requirements=requirements,
            exports=exports,
            skip_imports=skip_imports,
            ipywidget=ipywidget,
            reloading=loaded,
            load_timeout=load_timeout,
        )
    finally:
        if user_resources:
            settings.resources = prev_resources
        else:
            settings.resources.unset_value()
    loaded_extensions.extend(new_exts)
    return bokeh_js  # type: ignore[no-any-return]

#+END_SRC
**** Function render_component
#+BEGIN_SRC python
def render_component(
    obj: Viewable,
) -> Tuple[str, dict[str, Any], dict[str, Any]]:
    """
    Render a Panel component.

    Args:
        obj: Panel Viewable object

    Returns:
        Tuple containing reference ID, docs JSON, and render JSON
    """
    from bokeh.document import Document
    from bokeh.embed.util import standalone_docs_json_and_render_items
    from panel.io.model import add_to_doc

    doc = Document()
    comm = _get_comm_class()()
    root = obj._render_model(doc, comm)
    ref = root.ref["id"]
    obj._comms[ref] = (comm, comm)
    add_to_doc(root, doc, True)
    (docs_json, [render_item]) = standalone_docs_json_and_render_items(
        [root], suppress_callback_warning=True
    )
    render_json = render_item.to_json()
    return ref, docs_json, render_json  # type: ignore[return-value]

#+END_SRC
**** @mddoc: Class panel
#+BEGIN_SRC python
@mddoc
class panel(UIElement[T, T]):
    """
    Create a UIElement from a Panel component.
    This proxies all the widget's attributes and methods.

    **Example.**

    ```python
    import marimo as mo
    import panel as pn

    slider = pn.widgets.IntSlider(start=0, end=10, value=5)
    rx_stars = mo.ui.panel(slider.rx() * "*")

    # In another cell, access its value
    # This works for all widgets
    slider.value
    ```

    **Attributes.**

    - `obj`: The widget being wrapped.

    **Initialization Args.**

    - `obj`: The widget to wrap.
    """

    def __init__(self, obj: Any):
        from panel.models.comm_manager import CommManager as PanelCommManager
        from panel.pane import panel as panel_func

        self.obj = obj = panel_func(obj)
        # This gets set to True in super().__init__()
        self._initialized = False

        ref, docs_json, render_json = render_component(obj)
        self._ref = ref
        self._manager = PanelCommManager(plot_id=ref)  # type: ignore[no-untyped-call]

        global loaded_extension
        extension = render_extension(loaded=loaded_extension == id(self))
        if loaded_extension == 0:
            loaded_extension = id(self)

        super().__init__(
            component_name="marimo-panel",
            initial_value=cast(T, {}),
            label="",
            args={
                "extension": extension,
                "render_json": render_json,
                "docs_json": docs_json,
            },
            on_change=None,
            functions=(
                Function(
                    name="send_to_widget",
                    arg_cls=SendToWidgetArgs,
                    function=self._handle_msg,
                ),
            ),
        )

    def _handle_msg(self, msg: SendToWidgetArgs) -> None:
        ref = self._ref
        comm = self.obj._comms[ref][0]
        msg = comm.decode(msg)
        self.obj._on_msg(ref, self._manager, msg)
        comm.send(data={"type": "ACK"})

    def _initialize(
        self,
        initialization_args: InitializationArgs[T, T],
    ) -> None:
        super()._initialize(initialization_args)
        for comm, _ in self.obj._comms.values():
            if isinstance(comm.comm, MarimoComm):
                comm.comm.ui_element_id = self._id

    def _convert_value(self, value: T) -> T:
        return value

    # After the panel component has been initialized
    # forward all setattr to the component
    def __setattr__(self, name: str, value: Any) -> None:
        if self._initialized:
            # If the widget has the attribute, set it
            if hasattr(self.obj, name):
                return setattr(self.obj, name, value)
            return super().__setattr__(name, value)
        return super().__setattr__(name, value)

    # After the panel component has been initialized
    # forward all getattr to the component
    def __getattr__(self, name: str) -> Any:
        if name in ("widget", "_initialized"):
            try:
                return self.__getattribute__(name)
            except AttributeError:
                return None
        return getattr(self.obj, name)

#+END_SRC
*** input
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.input
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/input.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import base64
import dataclasses
import os
import pathlib
import sys
import traceback
from dataclasses import dataclass
from typing import (
    Any,
    Callable,
    Dict,
    Final,
    List,
    Literal,
    Optional,
    Sequence,
    Tuple,
    TypeVar,
    Union,
    cast,
)

from marimo import _loggers
from marimo._data.series import (
    DataFrameSeries,
    get_category_series_info,
    get_number_series_info,
)
from marimo._dependencies.dependencies import DependencyManager
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType
from marimo._plugins.ui._core.ui_element import S as JSONTypeBound, UIElement
from marimo._plugins.validators import (
    validate_between_range,
    validate_range,
    warn_js_safe_number,
)
from marimo._runtime.functions import Function
from marimo._server.files.os_file_system import OSFileSystem
from marimo._server.models.files import FileInfo

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment Numeric = Union[int, float]
#+BEGIN_SRC python
Numeric = Union[int, float]

#+END_SRC
**** @mddoc: Class number
#+BEGIN_SRC python
@mddoc
class number(UIElement[Optional[Numeric], Optional[Numeric]]):
    """
    A number picker over an interval.

    **Example.**

    ```python
    number = mo.ui.number(start=1, stop=10, step=2)
    ```

    Or for integer-only values:

    ```python
    number = mo.ui.number(step=1)
    ```

    Or from a dataframe series:

    ```python
    number = mo.ui.number.from_series(df["column_name"])
    ```

    **Attributes.**

    - `value`: the value of the number, possibly `None`
    - `start`: the minimum value of the interval
    - `stop`: the maximum value of the interval
    - `step`: the number increment

    **Initialization Args.**

    - `start`: optional, the minimum value of the interval
    - `stop`: optional, the maximum value of the interval
    - `step`: the number increment
    - `value`: default value
    - `debounce`: whether to debounce (rate-limit) value
        updates from the frontend
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of its
        container
    """

    _name: Final[str] = "marimo-number"

    def __init__(
        self,
        start: Optional[float] = None,
        stop: Optional[float] = None,
        step: Optional[float] = None,
        value: Optional[float] = None,
        debounce: bool = False,
        *,
        label: str = "",
        on_change: Optional[Callable[[Optional[Numeric]], None]] = None,
        full_width: bool = False,
    ) -> None:
        validate_range(min_value=start, max_value=stop)
        validate_between_range(value, min_value=start, max_value=stop)
        warn_js_safe_number(start, stop, value)

        # Set value to min or max if None
        if value is None:
            if start is not None:
                value = start
            elif stop is not None:
                value = stop

        # Lower bound
        self.start = start
        # Upper bound
        self.stop = stop
        # Increment size
        self.step = step
        super().__init__(
            component_name=number._name,
            initial_value=value,
            label=label,
            args={
                "start": start,
                "stop": stop,
                "step": step if step is not None else None,
                "debounce": debounce,
                "full-width": full_width,
            },
            on_change=on_change,
        )

    @staticmethod
    def from_series(series: DataFrameSeries, **kwargs: Any) -> "number":
        """Create a number picker from a dataframe series."""
        info = get_number_series_info(series)
        start = kwargs.pop("start", info.min)
        stop = kwargs.pop("stop", info.max)
        label = kwargs.pop("label", info.label)
        return number(start=start, stop=stop, label=label, **kwargs)

    def _convert_value(self, value: Optional[Numeric]) -> Optional[Numeric]:
        """Value is `None` if user uses keyboard to delete contents of input"""
        return value

#+END_SRC
**** @mddoc: Class slider
#+BEGIN_SRC python
@mddoc
class slider(UIElement[Numeric, Numeric]):
    """
    A numeric slider over an interval.

    **Example.**

    ```python
    slider = mo.ui.slider(start=1, stop=10, step=2)
    ```

    Or from a dataframe series:

    ```python
    slider = mo.ui.slider.from_series(df["column_name"])
    ```

    Or using numpy arrays:

    ```python
    import numpy as np

    # linear steps
    steps = np.array([1, 2, 3, 4, 5])
    slider = mo.ui.slider(steps=steps)
    # log steps
    log_slider = mo.ui.slider(steps=np.logspace(0, 3, 4))
    # power steps
    power_slider = mo.ui.slider(steps=np.power([1, 2, 3], 2))
    ```

    **Attributes.**

    - `value`: the current numeric value of the slider
    - `start`: the minimum value of the interval
    - `stop`: the maximum value of the interval
    - `step`: the slider increment
    - `steps`: list of steps

    **Initialization Args.**

    - `start`: the minimum value of the interval
    - `stop`: the maximum value of the interval
    - `step`: the slider increment
    - `value`: default value
    - `debounce`: whether to debounce the slider to only send
        the value on mouse-up or drag-end
    - `orientation`: the orientation of the slider,
        either "horizontal" or "vertical"
    - `show_value`: whether to display the current value of the slider
    - `steps`: list of steps to customize the slider, mutually exclusive
        with `start`, `stop`, and `step`
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of its
        container
    """

    _name: Final[str] = "marimo-slider"
    _mapping: Optional[Dict[int, Numeric]] = None

    def __init__(
        self,
        start: Optional[Numeric] = None,
        stop: Optional[Numeric] = None,
        step: Optional[Numeric] = None,
        value: Optional[Numeric] = None,
        debounce: bool = False,
        orientation: Literal["horizontal", "vertical"] = "horizontal",
        show_value: bool = False,
        steps: Optional[Sequence[Numeric]] = None,
        *,
        label: str = "",
        on_change: Optional[Callable[[Optional[Numeric]], None]] = None,
        full_width: bool = False,
    ) -> None:
        self.start: Numeric
        self.stop: Numeric
        self.step: Optional[Numeric]
        self.steps: Optional[Sequence[Numeric]]
        warn_js_safe_number(start, stop, value)

        # Guard against conflicting arguments
        if steps is not None and (
            start is not None or stop is not None or step is not None
        ):
            raise ValueError(
                "Invalid arguments: `steps` is mutually exclusive with "
                "`start`, `stop`, and `step`."
            )
        if steps is None and (start is None or stop is None):
            raise ValueError(
                "Missing arguments: `steps` xor both `start`"
                "and `stop` must be provided."
            )
        # If steps are provided
        if steps is not None:
            # Cast to a list in case user passes a numpy array
            if not isinstance(steps, list):
                steps = _convert_numpy_array(steps)
            self._dtype = _infer_dtype(steps)
            self._mapping = dict(enumerate(steps))
            try:
                # check if steps is a sequence of numbers
                assert all(isinstance(num, (int, float)) for num in steps)
                assert len(steps) > 0
                value = steps[0] if value is None else value
                value = steps.index(value)
            except ValueError:
                sys.stderr.write(
                    "Value out of bounds: default value should be in the steps"
                    ", set to first value.\n"
                )
                value = 0
            except AssertionError as e:
                raise TypeError(
                    "Invalid steps: steps must be a sequence of numbers."
                ) from e

            # minimum value of interval
            self.start = steps[0]
            # maximum value of interval
            self.stop = steps[-1]
            # slider increment
            self.step = None
            # list of steps
            self.steps = steps

            super().__init__(
                component_name=slider._name,
                initial_value=value,
                label=label,
                args={
                    "start": 0,
                    "stop": len(steps) - 1,
                    "step": 1,
                    "steps": steps,
                    "debounce": debounce,
                    "orientation": orientation,
                    "show-value": show_value,
                    "full-width": full_width,
                },
                on_change=on_change,
            )
        else:
            assert start is not None
            assert stop is not None

            self._dtype = _infer_dtype([start, stop, step, value])
            value = start if value is None else value

            if stop < start:
                raise ValueError(
                    f"Invalid bounds: stop value ({stop}) "
                    "must be greater than "
                    f"start value ({start})"
                )
            if value < start or value > stop:
                raise ValueError(
                    f"Value out of bounds: default value ({value}) must be "
                    f"greater than start ({start}) "
                    f"and less than stop ({stop})."
                )

            self.start = start
            self.stop = stop
            self.step = step
            self.steps = None

            super().__init__(
                component_name=slider._name,
                initial_value=value,
                label=label,
                args={
                    "start": start,
                    "stop": stop,
                    "step": step if step is not None else None,
                    "steps": [],
                    "debounce": debounce,
                    "orientation": orientation,
                    "show-value": show_value,
                    "full-width": full_width,
                },
                on_change=on_change,
            )

    @staticmethod
    def from_series(series: DataFrameSeries, **kwargs: Any) -> "slider":
        """Create a slider from a dataframe series."""
        info = get_number_series_info(series)
        start = kwargs.pop("start", info.min)
        stop = kwargs.pop("stop", info.max)
        label = kwargs.pop("label", info.label)
        return slider(start=start, stop=stop, label=label, **kwargs)

    def _convert_value(self, value: Numeric) -> Numeric:
        if self._mapping is not None:
            return cast(Numeric, self._dtype(self._mapping[int(value)]))
        return cast(Numeric, self._dtype(value))

#+END_SRC
**** @mddoc: Class range_slider
#+BEGIN_SRC python
@mddoc
class range_slider(UIElement[List[Numeric], Sequence[Numeric]]):
    """
    A numeric slider for specifying a range over an interval.

    **Example.**

    ```python
    range_slider = mo.ui.range_slider(start=1, stop=10, step=2, value=[2, 6])
    ```

    Or from a dataframe series:

    ```python
    range_slider = mo.ui.range_slider.from_series(df["column_name"])
    ```

    Or using numpy arrays:

    ```python
    import numpy as np

    steps = np.array([1, 2, 3, 4, 5])
    # linear steps
    range_slider = mo.ui.range_slider(steps=steps)
    # log steps
    log_range_slider = mo.ui.range_slider(steps=np.logspace(0, 3, 4))
    # power steps
    power_range_slider = mo.ui.range_slider(steps=np.power([1, 2, 3], 2))
    ```

    **Attributes.**

    - `value`: the current range value of the slider
    - `start`: the minimum value of the interval
    - `stop`: the maximum value of the interval
    - `step`: the slider increment
    - `steps`: list of steps

    **Initialization Args.**

    - `start`: the minimum value of the interval
    - `stop`: the maximum value of the interval
    - `step`: the slider increment
    - `value`: default value
    - `debounce`: whether to debounce the slider to only send
        the value on mouse-up or drag-end
    - `orientation`: the orientation of the slider,
        either "horizontal" or "vertical"
    - `show_value`: whether to display the current value of the slider
    - `steps`: list of steps to customize the slider, mutually exclusive
        with `start`, `stop`, and `step`
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of its
        container
    """

    _name: Final[str] = "marimo-range-slider"
    _mapping: Optional[dict[int, Numeric]] = None

    def __init__(
        self,
        start: Optional[Numeric] = None,
        stop: Optional[Numeric] = None,
        step: Optional[Numeric] = None,
        value: Optional[Sequence[Numeric]] = None,
        debounce: bool = False,
        orientation: Literal["horizontal", "vertical"] = "horizontal",
        show_value: bool = False,
        steps: Optional[Sequence[Numeric]] = None,
        *,
        label: str = "",
        on_change: Optional[Callable[[Sequence[Numeric]], None]] = None,
        full_width: bool = False,
    ) -> None:
        self.start: Numeric
        self.stop: Numeric
        self.step: Optional[Numeric]
        self.steps: Optional[Sequence[Numeric]]
        warn_js_safe_number(start, stop, *(value or []))

        if steps is not None and (
            start is not None or stop is not None or step is not None
        ):
            raise ValueError(
                "Invalid arguments: `steps` is mutually exclusive with "
                "`start`, `stop`, and `step`."
            )
        if steps is None and (start is None or stop is None):
            raise ValueError(
                "Missing arguments: `steps` xor both `start`"
                "and `stop` must be provided."
            )

        if steps is not None:
            # Cast to a list in case user passes a numpy array
            if not isinstance(steps, list):
                steps = _convert_numpy_array(steps)
            self._dtype = _infer_dtype(steps)
            self._mapping = dict(enumerate(steps))

            try:
                assert all(isinstance(num, (int, float)) for num in steps)
                assert len(steps) > 0
                value = [steps[0], steps[-1]] if value is None else value
                value = [steps.index(num) for num in value]
            except ValueError:
                sys.stderr.write(
                    "Value out of bounds: default value should be in the"
                    "steps, set to first and last values.\n"
                )
                value = [0, len(steps) - 1]
            except AssertionError as e:
                raise TypeError(
                    "Invalid steps: steps must be a sequence of numbers."
                ) from e

            # minimum value of interval
            self.start = steps[0]
            # maximum value of interval
            self.stop = steps[-1]
            # slider increment
            self.step = None
            # list of steps
            self.steps = steps

            super().__init__(
                component_name=range_slider._name,
                initial_value=list(value),
                label=label,
                args={
                    "start": 0,
                    "stop": len(steps) - 1,
                    "step": 1,
                    "steps": steps,
                    "debounce": debounce,
                    "orientation": orientation,
                    "show-value": show_value,
                    "full-width": full_width,
                },
                on_change=on_change,
            )
        else:
            assert start is not None
            assert stop is not None

            self._dtype = _infer_dtype([start, stop, step, value])

            value = [start, stop] if value is None else value

            if stop < start or value[1] < value[0]:
                raise ValueError(
                    "Invalid bounds: stop value must be "
                    "greater than start value."
                )
            if value[0] < start or value[1] > stop:
                raise ValueError(
                    f"Value out of bounds: default value ({value}) must be "
                    f"a range within start ({start}) and stop ({stop})."
                )

            self.start = start
            self.stop = stop
            self.step = step
            self.steps = None

            super().__init__(
                component_name=range_slider._name,
                initial_value=list(value),
                label=label,
                args={
                    "start": start,
                    "stop": stop,
                    "step": step if step is not None else None,
                    "steps": [],
                    "debounce": debounce,
                    "orientation": orientation,
                    "show-value": show_value,
                    "full-width": full_width,
                },
                on_change=on_change,
            )

    @staticmethod
    def from_series(series: DataFrameSeries, **kwargs: Any) -> "range_slider":
        """Create a range slider from a dataframe series."""
        info = get_number_series_info(series)
        start = kwargs.pop("start", info.min)
        stop = kwargs.pop("stop", info.max)
        label = kwargs.pop("label", info.label)
        return range_slider(start=start, stop=stop, label=label, **kwargs)

    def _convert_value(self, value: List[Numeric]) -> Sequence[Numeric]:
        if self._mapping is not None:
            return cast(
                Sequence[Numeric],
                [self._dtype(self._mapping[int(v)]) for v in value],
            )
        return cast(Sequence[Numeric], [self._dtype(v) for v in value])

#+END_SRC
**** Function _infer_dtype
#+BEGIN_SRC python
def _infer_dtype(
    items: Sequence[Union[Numeric, Sequence[Numeric], None]],
) -> type[int] | type[float]:
    """Infer the dtype of a sequence of numbers."""
    for item in items:
        if isinstance(item, Sequence):
            if any(isinstance(subitem, float) for subitem in item):
                return float
        if any(isinstance(item, float) for item in items):
            return float
    return int

#+END_SRC
**** @mddoc: Class checkbox
#+BEGIN_SRC python
@mddoc
class checkbox(UIElement[bool, bool]):
    """
    A boolean checkbox.

    **Example.**

    ```python
    checkbox = mo.ui.checkbox()
    ```

    **Attributes.**

    - `value`: a boolean, `True` if checked

    **Initialization Args.**

    - `value`: default value, True or False
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """

    _name: Final[str] = "marimo-checkbox"

    def __init__(
        self,
        value: bool = False,
        *,
        label: str = "",
        on_change: Optional[Callable[[bool], None]] = None,
    ) -> None:
        super().__init__(
            component_name=checkbox._name,
            initial_value=value,
            label=label,
            args={},
            on_change=on_change,
        )

    def _convert_value(self, value: bool) -> bool:
        return value

#+END_SRC
**** @mddoc: Class radio
#+BEGIN_SRC python
@mddoc
class radio(UIElement[Optional[str], Any]):
    """
    A radio group.

    **Example.**

    ```python
    radiogroup = mo.ui.radio(
        options=["a", "b", "c"], value="a", label="choose one"
    )
    ```

    ```python
    radiogroup = mo.ui.radio(
        options={"one": 1, "two": 2, "three": 3},
        value="one",
        label="pick a number",
    )
    ```

    Or from a dataframe series:

    ```python
    radiogroup = mo.ui.radio.from_series(df["column_name"])
    ```

    **Attributes.**

    - `value`: the value of the selected radio option
    - `options`: a dict mapping option name to option value

    **Initialization Args.**

    - `options`: sequence of text options, or dict mapping option name
                 to option value
    - `value`: default option name, if None, starts with nothing checked
    - `label`: optional markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """

    _name: Final[str] = "marimo-radio"

    def __init__(
        self,
        options: Sequence[str] | dict[str, Any],
        value: Optional[str] = None,
        inline: bool = False,
        *,
        label: str = "",
        on_change: Optional[Callable[[Any], None]] = None,
    ) -> None:
        if not isinstance(options, dict):
            if len(set(options)) != len(options):
                raise ValueError("A radio group cannot have repeated options.")
            options = {option: option for option in options}
        self.options = options
        super().__init__(
            component_name=radio._name,
            initial_value=value,
            label=label,
            args={
                "options": list(options.keys()),
                "inline": inline,
            },
            on_change=on_change,
        )

    @staticmethod
    def from_series(series: DataFrameSeries, **kwargs: Any) -> "radio":
        """Create a radio group from a dataframe series."""
        info = get_category_series_info(series)
        options = kwargs.pop("options", info.categories)
        label = kwargs.pop("label", info.label)
        return radio(options=options, label=label, **kwargs)

    def _convert_value(self, value: Optional[str]) -> Any:
        return self.options[value] if value is not None else None

#+END_SRC
**** @mddoc: Class text
#+BEGIN_SRC python
@mddoc
class text(UIElement[str, str]):
    """
    A text input.

    **Example.**

    ```python
    text = mo.ui.text(value="Hello, World!")
    ```

    **Attributes.**

    - `value`: a string of the input's contents

    **Initialization Args.**

    - `value`: default value of text box
    - `placeholder`: placeholder text to display when the text area is empty
    - `kind`: input kind, one of `"text"`, `"password"`, `"email"`, or `"url"`
        defaults to `"text"`
    - `max_length`: maximum length of input
    - `disabled`: whether the input is disabled
    - `debounce`: whether the input is debounced. If number, debounce by
        that many milliseconds. If True, then value is only emitted on Enter
        or when the input loses focus.
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of its
        container
    """

    _name: Final[str] = "marimo-text"

    def __init__(
        self,
        value: str = "",
        placeholder: str = "",
        kind: Literal["text", "password", "email", "url"] = "text",
        max_length: Optional[int] = None,
        disabled: bool = False,
        debounce: bool | int = True,
        *,
        label: str = "",
        on_change: Optional[Callable[[str], None]] = None,
        full_width: bool = False,
    ) -> None:
        super().__init__(
            component_name=text._name,
            initial_value=value,
            label=label,
            args={
                "placeholder": placeholder,
                "kind": kind,
                "max-length": max_length,
                "full-width": full_width,
                "disabled": disabled,
                "debounce": debounce,
            },
            on_change=on_change,
        )

    def _convert_value(self, value: str) -> str:
        return value

#+END_SRC
**** @mddoc: Class text_area
#+BEGIN_SRC python
@mddoc
class text_area(UIElement[str, str]):
    """
    A text area that is larger than `ui.text`.

    **Example.**

    ```python
    text_area = mo.ui.text_area()
    ```

    **Attributes.**

    - `value`: a string of the text area contents

    **Initialization Args.**

    - `value`: initial value of the text area
    - `placeholder`: placeholder text to display when the text area is empty
    - `max_length`: maximum length of input
    - `disabled`: whether the input is disabled
    - `debounce`: whether the input is debounced. If number, debounce by that
        many milliseconds. If True, then value is only emitted on Ctrl+Enter
        or when the input loses focus.
    - `rows`: number of rows of text to display
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of its
        container
    """

    _name: Final[str] = "marimo-text-area"

    def __init__(
        self,
        value: str = "",
        placeholder: str = "",
        max_length: Optional[int] = None,
        disabled: bool = False,
        debounce: bool | int = True,
        rows: Optional[int] = None,
        *,
        label: str = "",
        on_change: Optional[Callable[[str], None]] = None,
        full_width: bool = False,
    ) -> None:
        super().__init__(
            component_name=text_area._name,
            initial_value=value,
            label=label,
            args={
                "placeholder": placeholder,
                "max-length": max_length,
                "disabled": disabled,
                "debounce": debounce,
                "full-width": full_width,
                "rows": rows,
            },
            on_change=on_change,
        )

    def _convert_value(self, value: str) -> str:
        return value

#+END_SRC
**** @mddoc: Class code_editor
#+BEGIN_SRC python
@mddoc
class code_editor(UIElement[str, str]):
    """
    A code editor.

    **Example.**

    ```python
    code_editor = mo.ui.code_editor()
    ```

    **Attributes.**

    - `value`: a string of the code editor contents

    **Initialization Args.**

    - `value`: initial value of the code editor
    - `language`: language of the code editor, defaults to `"python"`; most
        major languages are supported, including "sql", "javascript",
        "typescript", "html", "css", "c", "cpp", "rust", and more
    - `placeholder`: placeholder text to display when the code editor is empty
    - `theme`: theme of the code editor, defaults to the editor's default
    - `disabled`: whether the input is disabled
    - `min_height`: minimum height of the code editor in pixels
    - `max_height`: maximum height of the code editor in pixels
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """

    _name: Final[str] = "marimo-code-editor"

    def __init__(
        self,
        value: str = "",
        language: str = "python",
        placeholder: str = "",
        theme: Optional[Literal["light", "dark"]] = None,
        disabled: bool = False,
        min_height: Optional[int] = None,
        max_height: Optional[int] = None,
        *,
        label: str = "",
        on_change: Optional[Callable[[str], None]] = None,
    ) -> None:
        if (
            min_height is not None
            and max_height is not None
            and min_height > max_height
        ):
            raise ValueError(
                f"min_height ({min_height}) must be <= max_height {max_height}"
            )

        super().__init__(
            component_name=code_editor._name,
            initial_value=value,
            label=label,
            args={
                "language": language,
                "placeholder": placeholder,
                "theme": theme,
                "disabled": disabled,
                "min-height": min_height,
                "max-height": max_height,
            },
            on_change=on_change,
        )

    def _convert_value(self, value: str) -> str:
        return value

#+END_SRC
**** @mddoc: Class dropdown
#+BEGIN_SRC python
@mddoc
class dropdown(UIElement[List[str], Any]):
    """
    A dropdown menu.

    **Example.**

    ```python
    dropdown = mo.ui.dropdown(
        options=["a", "b", "c"], value="a", label="choose one"
    )
    ```

    ```python
    dropdown = mo.ui.dropdown(
        options={"one": 1, "two": 2, "three": 3},
        value="one",
        label="pick a number",
    )
    ```

    Or from a dataframe series:

    ```python
    dropdown = mo.ui.dropdown.from_series(df["column_name"])
    ```

    **Attributes.**

    - `value`: the selected value, or `None` if no selection
    - `options`: a dict mapping option name to option value
    - `selected_key`: the selected option's key, or `None` if no selection

    **Initialization Args.**

    - `options`: sequence of text options, or dict mapping option name
                 to option value
    - `value`: default option name
    - `allow_select_none`: whether to include special option (`"--"`) for a
                           `None` value; when `None`, defaults to `True` when
                           `value` is `None`
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of its
        container
    """

    _MAX_OPTIONS: Final[int] = 1000
    _name: Final[str] = "marimo-dropdown"
    _selected_key: Optional[str] = None

    def __init__(
        self,
        options: Sequence[str] | dict[str, Any],
        value: Optional[str] = None,
        allow_select_none: Optional[bool] = None,
        *,
        label: str = "",
        on_change: Optional[Callable[[Any], None]] = None,
        full_width: bool = False,
    ) -> None:
        if len(options) > dropdown._MAX_OPTIONS:
            raise ValueError(
                "The maximum number of dropdown options allowed "
                f"is {dropdown._MAX_OPTIONS}, but your dropdown has "
                f"{len(options)} options. "
                "If you really want to expose that many options, consider "
                "using `mo.ui.text()` to let the user type an option name, "
                "and `mo.ui.table()` to present the options matching the "
                "user's query.",
            )

        if not isinstance(options, dict):
            options = {option: option for option in options}

        if "--" in options:
            raise ValueError(
                "The option name '--' is reserved by marimo"
                "; please use another name."
            )

        self.options = options
        initial_value = [value] if value is not None else []
        if allow_select_none is None:
            allow_select_none = value is None
        elif not allow_select_none and value is None:
            raise ValueError(
                "when `allow_select_none` is False, a non-None default value "
                "must be provided."
            )

        super().__init__(
            component_name=dropdown._name,
            initial_value=initial_value,
            label=label,
            args={
                "options": list(self.options.keys()),
                "allow-select-none": allow_select_none,
                "full-width": full_width,
            },
            on_change=on_change,
        )

    @staticmethod
    def from_series(series: DataFrameSeries, **kwargs: Any) -> "dropdown":
        """Create a dropdown from a dataframe series."""
        info = get_category_series_info(series)
        options = kwargs.pop("options", info.categories)
        label = kwargs.pop("label", info.label)
        return dropdown(options=options, label=label, **kwargs)

    def _convert_value(self, value: list[str]) -> Any:
        if value:
            assert len(value) == 1
            self._selected_key = value[0]
            return self.options[value[0]]
        else:
            self._selected_key = None
            return None

    @property
    def selected_key(self) -> Optional[str]:
        """The selected option's key, or `None` if no selection."""
        return self._selected_key

#+END_SRC
**** @mddoc: Class multiselect
#+BEGIN_SRC python
@mddoc
class multiselect(UIElement[List[str], List[object]]):
    """
    A multiselect input.

    **Example.**

    ```python
    multiselect = mo.ui.multiselect(
        options=["a", "b", "c"], label="choose some options"
    )
    ```

    Or from a dataframe series:

    ```python
    multiselect = mo.ui.multiselect.from_series(df["column_name"])
    ```

    **Attributes.**

    - `value`: the selected values, or `None` if no selection
    - `options`: a dict mapping option name to option value

    **Initialization Args.**

    - `options`: sequence of text options, or dict mapping option name
                 to option value
    - `value`: a list of initially selected options
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of its
        container
    - `max_selections`: maximum number of items that can be selected
    """

    _MAX_OPTIONS: Final[int] = 100000
    _name: Final[str] = "marimo-multiselect"

    def __init__(
        self,
        options: Sequence[str] | dict[str, Any],
        value: Optional[Sequence[str]] = None,
        *,
        label: str = "",
        on_change: Optional[Callable[[List[object]], None]] = None,
        full_width: bool = False,
        max_selections: Optional[int] = None,
    ) -> None:
        if len(options) > multiselect._MAX_OPTIONS:
            raise ValueError(
                "The maximum number of options allowed "
                f"is {multiselect._MAX_OPTIONS}, but your multiselect has "
                f"{len(options)} options. "
                "If you really want to expose that many options, consider "
                "using `mo.ui.text()` to let the user type an option name, "
                "and `mo.ui.table()` to present the options matching the "
                "user's query.",
            )

        if not isinstance(options, dict):
            options = {option: option for option in options}

        self.options = options
        initial_value = list(value) if value is not None else []

        if max_selections is not None:
            if max_selections < 0:
                raise ValueError("max_selections cannot be less than 0.")
            if max_selections < len(initial_value):
                raise ValueError(
                    "Initial value cannot be greater than max_selections."
                )

        super().__init__(
            component_name=multiselect._name,
            initial_value=initial_value,
            label=label,
            args={
                "options": list(self.options.keys()),
                "full-width": full_width,
                "max-selections": max_selections,
            },
            on_change=on_change,
        )

    @staticmethod
    def from_series(series: DataFrameSeries, **kwargs: Any) -> "multiselect":
        """Create a multiselect from a dataframe series."""
        info = get_category_series_info(series)
        options = kwargs.pop("options", info.categories)
        label = kwargs.pop("label", info.label)
        return multiselect(options=options, label=label, **kwargs)

    def _convert_value(self, value: list[str]) -> list[object]:
        return [self.options[v] for v in value]

#+END_SRC
**** @mddoc: Class button
#+BEGIN_SRC python
@mddoc
class button(UIElement[Any, Any]):
    """
    A button with an optional callback and optional value.

    **Example.**

    ```python
    # a button that when clicked will execute
    # any cells referencing that button
    button = mo.ui.button()
    ```

    ```python
    # a counter implementation
    counter_button = mo.ui.button(
        value=0, on_click=lambda value: value + 1, label="increment"
    )

    # adding intent
    delete_button = mo.ui.button(
        label="Do not click",
        kind="danger",
    )
    ```

    **Attributes.**

    - `value`: the value of the button

    **Initialization Args.**

    - `on_click`: a callable called on click that takes the current
       value of the button and returns a new value
    - `value`: an initial value for the button
    - `kind`: 'neutral', 'success', 'warn', or 'danger'
    - `disabled`: whether the button is disabled
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of its
        container
    - `keyboard_shortcut`: keyboard shortcut to trigger the button (e.g. 'Ctrl-L')
    """

    _name: Final[str] = "marimo-button"

    def __init__(
        self,
        on_click: Optional[Callable[[Any], Any]] = None,
        value: Optional[Any] = None,
        kind: Literal["neutral", "success", "warn", "danger"] = "neutral",
        disabled: bool = False,
        tooltip: Optional[str] = None,
        *,
        label: str = "click here",
        on_change: Optional[Callable[[Any], None]] = None,
        full_width: bool = False,
        keyboard_shortcut: Optional[str] = None,
    ) -> None:
        self._on_click = (lambda _: value) if on_click is None else on_click
        self._initial_value = value
        # This should be kept in sync with mo.ui.run_button()
        super().__init__(
            component_name=button._name,
            # frontend's value is always a counter
            initial_value=0,
            label=label,
            args={
                "kind": kind,
                "disabled": disabled,
                "tooltip": tooltip,
                "full-width": full_width,
                "keyboard-shortcut": keyboard_shortcut,
            },
            on_change=on_change,
        )

    def _convert_value(self, value: Any) -> Any:
        if value == 0:
            # frontend's value == 0 only during initialization; first value
            # frontend will send is 1
            return self._initial_value
        try:
            return self._on_click(self._value)
        except Exception:
            sys.stderr.write(
                "on_click handler for button (%s) raised an Exception:\n %s\n"
                % (str(self), traceback.format_exc())
            )
            return None

#+END_SRC
**** @dataclass: Class FileUploadResults
#+BEGIN_SRC python
@dataclass
class FileUploadResults:
    """A file's name and its contents."""

    name: str
    contents: bytes

    def __repr__(self) -> str:
        # Truncate contents because it can be very long
        return f"FileUploadResults(name='{self.name}', contents=...)"

#+END_SRC
**** @mddoc: Class file
#+BEGIN_SRC python
@mddoc
class file(UIElement[List[Tuple[str, str]], Sequence[FileUploadResults]]):
    """
    A button or drag-and-drop area to upload a file.

    Once a file is uploaded, the UI element's value is a list of
    `namedtuples (name, contents)`, where `name` is the filename and
    `contents` is the contents of the file. Alternatively, use the methods
    `name(index: int = 0)` and `contents(index: int = 0)` to retrieve the
    name or contents of the file at a specified index.

    Use the `kind` argument to switch between a button and a drag-and-drop
    area.

    The maximum file size is 100MB.

    **Examples.**

    Uploading a single file:

    ```python
    f = mo.ui.file()

    # access the uploaded file's name
    f.value[0].name
    # or
    f.name()

    # access the uploaded file's contents
    f.value[0].contents
    # or
    f.contents()
    ```

    Uploading multiple files, accepting only .png and .jpg extensions:

    ```python
    f = mo.ui.file(filetypes=[".png", ".jpg"], multiple=True)

    # access an uploaded file's name
    f.value[index].name
    # or
    f.name(index)

    # access the uploaded file's contents
    f.value[index].contents
    # or
    f.contents(index)
    ```

    **Attributes.**

    - `value`: a sequence of `FileUploadResults`, which have string `name` and
               `bytes` `contents` fields

    **Methods.**

    - `name(self, index: int = 0) -> Optional[str]`: Get the name of the
      uploaded file at `index`.
    - `contents(self, index: int = 0) -> Optional[bytes]`: Get the contents of
      the uploaded file at `index`.

    **Initialization Args.**

    - `filetypes`: the file types accepted; for example,
       `filetypes=[".png", ".jpg"]`. If `None`, all files are accepted.
       In addition to extensions, you may provide `"audio/*"`, `"video/*"`,
       or `"image/*"` to accept any audio, video, or image file.
    - `multiple`: if True, allow the user to upload multiple files
    - `kind`: `"button"` or `"area"`
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """

    _name: Final[str] = "marimo-file"

    def __init__(
        self,
        filetypes: Optional[Sequence[str]] = None,
        multiple: bool = False,
        kind: Literal["button", "area"] = "button",
        *,
        label: str = "",
        on_change: Optional[
            Callable[[Sequence[FileUploadResults]], None]
        ] = None,
    ) -> None:
        super().__init__(
            component_name=file._name,
            initial_value=[],
            label=label,
            args={
                "filetypes": filetypes if filetypes is not None else [],
                "multiple": multiple,
                "kind": kind,
            },
            on_change=on_change,
        )

    def _convert_value(
        self, value: list[tuple[str, str]]
    ) -> Sequence[FileUploadResults]:
        return tuple(
            FileUploadResults(name=e[0], contents=base64.b64decode(e[1]))
            for e in value
        )

    def name(self, index: int = 0) -> Optional[str]:
        """Get file name at index."""
        if not self.value or index >= len(self.value):
            return None
        else:
            return self.value[index].name

    def contents(self, index: int = 0) -> Optional[bytes]:
        """Get file contents at index."""
        if not self.value or index >= len(self.value):
            return None
        else:
            return self.value[index].contents

#+END_SRC
**** @dataclass: Class ListDirectoryArgs
#+BEGIN_SRC python
@dataclass
class ListDirectoryArgs:
    path: str

#+END_SRC
**** @dataclass: Class ListDirectoryResponse
#+BEGIN_SRC python
@dataclass
class ListDirectoryResponse:
    files: List[FileInfo]

#+END_SRC
**** @mddoc: Class file_browser
#+BEGIN_SRC python
@mddoc
class file_browser(UIElement[List[Dict[str, Any]], Sequence[FileInfo]]):
    """
    File browser for browsing and selecting server-side files.

    **Examples.**

    Selecting multiple files:

    ```python
    file_browser = mo.ui.file_browser(
        initial_path="path/to/dir", multiple=True
    )

    # Access the selected file path(s):
    file_browser.path(index)

    # Get name of selected file(s)
    file_browser.name(index)
    ```

    **Attributes.**

    - `value`: a sequence of file paths representing selected files.

    **Initialization Args.**

    - `initial_path`: starting directory, default current working directory.
    - `filetypes`: the file types to display in each directory; for example,
       `filetypes=[".txt", ".csv"]`. If `None`, all files are displayed.
    - `selection_mode`: either "file" or "directory".
    - `multiple`: if True, allow the user to select multiple files.
    - `restrict_navigation`: if True, prevent the user from navigating
       any level above the given path.
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """

    _name: Final[str] = "marimo-file-browser"

    def __init__(
        self,
        initial_path: str = "",
        filetypes: Optional[Sequence[str]] = None,
        selection_mode: str = "file",
        multiple: bool = True,
        restrict_navigation: bool = False,
        *,
        label: str = "",
        on_change: Optional[Callable[[Sequence[FileInfo]], None]] = None,
    ) -> None:
        self.filetypes = filetypes

        if (
            selection_mode != "file"
            and selection_mode != "directory"
            and selection_mode != "all"
        ):
            raise ValueError(
                "Invalid argument for selection_mode. "
                + "Must be either 'file' or 'directory'."
            )
        else:
            self.selection_mode = selection_mode

        if not initial_path:
            initial_path = os.getcwd()

        # frontend plugin can't handle relative paths
        initial_path = os.path.realpath(os.path.expanduser(initial_path))
        # initial path must be a directory
        if not os.path.isdir(initial_path):
            raise ValueError(
                f"Initial path {initial_path} is not a directory."
            )

        self.restrict_navigation = restrict_navigation
        self.initial_path = initial_path
        super().__init__(
            component_name=file_browser._name,
            initial_value=[],
            label=label,
            args={
                "initial-path": initial_path,
                "selection-mode": selection_mode,
                "filetypes": filetypes if filetypes is not None else [],
                "multiple": multiple,
                "restrict-navigation": restrict_navigation,
            },
            functions=(
                Function(
                    name=self.list_directory.__name__,
                    arg_cls=ListDirectoryArgs,
                    function=self.list_directory,
                ),
            ),
            on_change=on_change,
        )

    def list_directory(self, args: ListDirectoryArgs) -> ListDirectoryResponse:
        # When navigation is restricted, the navigated-to path cannot be
        # be a parent of the initial path
        if (
            self.restrict_navigation
            and pathlib.Path(args.path)
            in pathlib.Path(self.initial_path).parents
        ):
            raise RuntimeError(
                "Navigation is restricted; navigating to a "
                "parent of initial path is not allowed."
            )

        files = []
        files_in_path = OSFileSystem().list_files(args.path)

        for file in files_in_path:
            _, extension = os.path.splitext(file.name)

            if self.selection_mode == "directory" and not file.is_directory:
                continue

            if self.filetypes and not file.is_directory:
                if extension not in self.filetypes:
                    continue

            files.append(file)

        return ListDirectoryResponse(files)

    def _convert_value(
        self, value: list[Dict[str, Any]]
    ) -> Sequence[FileInfo]:
        return tuple(
            FileInfo(
                id=file["id"],
                name=file["name"],
                path=file["path"],
                is_directory=file["is_directory"],
                is_marimo_file=file["is_marimo_file"],
            )
            for file in value
        )

    def name(self, index: int = 0) -> Optional[str]:
        """Get file name at index."""
        if not self.value or index >= len(self.value):
            return None
        else:
            return self.value[index].name

    def path(self, index: int = 0) -> Optional[str]:
        """Get file path at index."""
        if not self.value or index >= len(self.value):
            return None
        else:
            return self.value[index].path

#+END_SRC
**** Assignment T = TypeVar("T")
#+BEGIN_SRC python
T = TypeVar("T")

#+END_SRC
**** @dataclasses.dataclass: Class ValueArgs
#+BEGIN_SRC python
@dataclasses.dataclass
class ValueArgs:
    value: Optional[JSONType] = None

#+END_SRC
**** @mddoc: Class form
#+BEGIN_SRC python
@mddoc
class form(UIElement[Optional[JSONTypeBound], Optional[T]]):
    """
    A submittable form linked to a UIElement.

    Use a `form` to prevent sending UI element values to Python until a button
    is clicked.

    The value of a `form` is the value of the underlying
    element the last time the form was submitted.

    **Example.**

    ```python
    # Create a form with chaining
    form = mo.ui.slider(1, 100).form()
    ```

    ```python
    # Create a form with multiple elements
    form = (
        mo.md('''
        **Your form.**

        {name}

        {date}
    ''')
        .batch(
            name=mo.ui.text(label="name"),
            date=mo.ui.date(label="date"),
        )
        .form(show_clear_button=True, bordered=False)
    )
    ```

    ```python
    # Instantiate a form directly
    form = mo.ui.form(element=mo.ui.slider(1, 100))
    ```

    **Attributes.**

    - `value`: the value of the wrapped element when the form's submit button
      was last clicked
    - `element`: a copy of the wrapped element

    **Initialization Args.**

    - `element`: the element to wrap
    - `bordered`: whether the form should have a border
    - `loading`: whether the form should be in a loading state
    - `submit_button_label`: the label of the submit button
    - `submit_button_tooltip`: the tooltip of the submit button
    - `submit_button_disabled`: whether the submit button should be disabled
    - `clear_on_submit`: whether the form should clear its contents after
        submitting
    - `show_clear_button`: whether the form should show a clear button
    - `clear_button_label`: the label of the clear button
    - `clear_button_tooltip`: the tooltip of the clear button
    - `validate`: a function that takes the form's value and returns an error
        message if the value is invalid, or `None` if the value is valid
    - `label`: markdown label for the form
    - `on_change`: optional callback to run when this element's value changes
    """

    _name: Final[str] = "marimo-form"

    def __init__(
        self,
        element: UIElement[JSONTypeBound, T],
        *,
        bordered: bool = True,
        loading: bool = False,
        submit_button_label: str = "Submit",
        submit_button_tooltip: Optional[str] = None,
        submit_button_disabled: bool = False,
        clear_on_submit: bool = False,
        show_clear_button: bool = False,
        clear_button_label: str = "Clear",
        clear_button_tooltip: Optional[str] = None,
        validate: Optional[
            Callable[[Optional[JSONType]], Optional[str]]
        ] = None,
        label: str = "",
        on_change: Optional[Callable[[Optional[T]], None]] = None,
    ) -> None:
        self.element = element._clone()
        self.validate = validate
        super().__init__(
            component_name=form._name,
            initial_value=None,
            label=label,
            args={
                "element-id": self.element._id,
                "loading": loading,
                "bordered": bordered,
                "submit-button-label": submit_button_label,
                "submit-button-tooltip": submit_button_tooltip,
                "submit-button-disabled": submit_button_disabled,
                "clear-on-submit": clear_on_submit,
                "show-clear-button": show_clear_button,
                "clear-button-label": clear_button_label,
                "clear-button-tooltip": clear_button_tooltip,
                "should-validate": validate is not None,
            },
            slotted_html=self.element.text,
            on_change=on_change,
            functions=(
                Function(
                    name="validate",
                    arg_cls=ValueArgs,
                    function=self._validate,
                ),
            ),
        )

    def _validate(self, value: ValueArgs) -> Optional[str]:
        if self.validate is None:
            return None
        return self.validate(value.value)

    def _convert_value(self, value: Optional[JSONTypeBound]) -> Optional[T]:
        if value is None:
            return None
        self.element._update(value)
        return self.element.value

#+END_SRC
**** Function _convert_numpy_array
#+BEGIN_SRC python
def _convert_numpy_array(steps: Any) -> list[Numeric]:
    """Convert numpy array to list if needed."""
    if DependencyManager.numpy.has():
        import numpy as np

        if isinstance(steps, np.ndarray):
            return steps.tolist()  # type: ignore[no-any-return]
    return steps  # type: ignore[no-any-return]

#+END_SRC
*** microphone
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.microphone
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/microphone.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import base64
import io
from typing import Callable, Final, Optional

from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import UIElement

#+END_SRC
**** @mddoc: Class microphone
#+BEGIN_SRC python
@mddoc
class microphone(UIElement[str, io.BytesIO]):
    """An audio recorder element.

    Use `mo.ui.microphone` to record audio via the user's browser. The
    user must grant permission to use the microphone.

    **Example.**

    ```python
    mic = mo.ui.microphone()
    mic
    ```

    ```python
    mo.audio(mic.value)
    ```

    **Attributes.**

    - `value`: The blob of the recorded audio, as an `io.BytesIO` object.

    **Initialization Args.**

    - `label`: optional markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """

    name: Final[str] = "marimo-microphone"

    def __init__(
        self,
        *,
        label: str = "",
        on_change: Optional[Callable[[io.BytesIO], None]] = None,
    ) -> None:
        super().__init__(
            component_name=microphone.name,
            initial_value="",
            label=label,
            args={},
            on_change=on_change,
        )

    def _convert_value(self, value: str) -> io.BytesIO:
        return io.BytesIO(base64.b64decode(value))

#+END_SRC
*** plotly
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.plotly
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/plotly.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import json
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Final,
    List,
    Optional,
    cast,
)

from marimo import _loggers
from marimo._dependencies.dependencies import DependencyManager
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType
from marimo._plugins.ui._core.ui_element import UIElement

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
**** Assignment PlotlySelection = Dict[str, JSONType]
#+BEGIN_SRC python
if TYPE_CHECKING:
    import plotly.graph_objects as go  # type:ignore

# Selection is a dictionary of the form:
# {
#   "points": {
#     "field1": "value1",
#     "field2": "value2",
#   }[],
#   "range": {
#     "field1": [min, max],
#     "field2": [min, max],
#   },
#  "indices": int[],
# }
PlotlySelection = Dict[str, JSONType]

#+END_SRC
**** @mddoc: Class plotly
#+BEGIN_SRC python
@mddoc
class plotly(UIElement[PlotlySelection, List[Dict[str, Any]]]):
    """Make reactive plots with Plotly.

    Use `mo.ui.plotly` to make plotly plots reactive: select data with your
    cursor on the frontend, get them as a list of dicts in Python!

    This function currently only supports scatter plots, treemaps charts,
    and sunbursts charts.

    **Example.**

    ```python
    import plotly.express as px
    import marimo as mo
    from vega_datasets import data

    _plot = px.scatter(
        data.cars(), x="Horsepower", y="Miles_per_Gallon", color="Origin"
    )

    plot = mo.ui.plotly(_plot)
    ```

    ```
    # View the plot and selected data
    mo.hstack([plot, plot.value])
    ```

    Or with custom configuration:

    ```python
    plot = mo.ui.plotly(
        _plot,
        config={"staticPlot": True},
    )
    ```

    **Attributes.**

    - `value`: a dict of the plot data
    - `ranges`: the selection of the plot; this may be an interval along
       the name of an axis

    **Initialization Args.**

    - `figure`: A `plotly.graph_objects.Figure`
    - `config`: optional configuration for the plot.
        This is a dictionary that is passed directly to the plotly.
        See the plotly documentation for more information:
        https://plotly.com/javascript/configuration-options/
        This takes precedence over the default configuration of the renderer.
    - `renderer_name`: optional renderer to use for the plot.
        If this is not provided, the default renderer (pio.renderers.default)
        is used.
    - `label`: optional markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """

    name: Final[str] = "marimo-plotly"

    def __init__(
        self,
        figure: go.Figure,
        config: Optional[Dict[str, Any]] = None,
        renderer_name: Optional[str] = None,
        *,
        label: str = "",
        on_change: Optional[Callable[[JSONType], None]] = None,
    ) -> None:
        DependencyManager.plotly.require("for `mo.ui.plotly`")

        import plotly.io as pio  # type:ignore

        json_str = pio.to_json(figure)

        resolved_config: Dict[str, Any] = {}
        if config is not None:
            resolved_config = config
        else:
            try:
                resolved_name: str = renderer_name or cast(
                    str, pio.renderers.default
                )
                default_renderer: Any = (
                    pio.renderers[resolved_name]
                    if resolved_name and resolved_name in pio.renderers
                    else None
                )
                if default_renderer is not None:
                    resolved_config = default_renderer.config or {}
            except AttributeError:
                LOGGER.warning(
                    "Could not find default renderer configuration. "
                    "Using an empty configuration."
                )

        super().__init__(
            component_name=plotly.name,
            initial_value={},
            label=label,
            args={
                "figure": json.loads(json_str),
                "config": resolved_config,
            },
            on_change=on_change,
        )

    @property
    def ranges(self) -> Dict[str, List[float]]:
        if not self._selection_data:
            return {}
        if "range" not in self._selection_data:
            return {}
        return self._selection_data["range"]  # type:ignore

    @property
    def points(self) -> List[Dict[str, Any]]:
        if not self._selection_data:
            return []
        if "points" not in self._selection_data:
            return []
        return self._selection_data["points"]  # type:ignore

    @property
    def indices(self) -> List[int]:
        if not self._selection_data:
            return []
        if "indices" not in self._selection_data:
            return []
        return self._selection_data["indices"]  # type:ignore

    def _convert_value(self, value: PlotlySelection) -> Any:
        # Store the selection data
        self._selection_data = value
        # Default to returning the points
        return self.points

#+END_SRC
*** refresh
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.refresh
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/refresh.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Callable, Final, Optional, Union

from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import UIElement

#+END_SRC
**** @mddoc: Class refresh
#+BEGIN_SRC python
@mddoc
class refresh(UIElement[int, int]):
    """
    A refresh button that will auto-refresh its descendants for a
    given interval.

    Each option value can either be a number (int or float) in seconds or a
    human-readable string (e.g. "1s", "10s", "1m").

    You can also combine multiple time units (e.g. "1m 30s").

    Note: The refresh interval may not be exact, as it depends on the
    time it takes to render the content and the time it takes to send
    the content to the client. Also, due to the buffering of UI element
    changes, if the downstream cells take a long time to render, the
    refresh interval may be longer than expected.

    **Example.**

    ```python
    refresh_button = mo.ui.refresh(
        options=["1m", "5m 30s", "10m"],
        default_interval="10m",
    )
    refresh_button
    ```

    **Attributes.**

    - `value`: The time in seconds since the refresh has been activated.

    **Initialization Args.**

    - `options`: The options for the refresh interval, as a list of
    human-readable strings or numbers (int or float) in seconds.
    If no options are provided and default_interval is provided,
    the options will be generated automatically.
    If no options are provided and default_interval is not provided,
    the refresh button will not be displayed with a dropdown for auto-refresh.
    - `default_interval`: The default value of the refresh interval.
    - `label`: optional markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """

    name: Final[str] = "marimo-refresh"

    def __init__(
        self,
        options: Optional[list[Union[int, float, str]]] = None,
        default_interval: Optional[Union[int, float, str]] = None,
        *,
        label: str = "",
        on_change: Optional[Callable[[int], None]] = None,
    ) -> None:
        if default_interval and not isinstance(
            default_interval, (int, float, str)
        ):
            raise ValueError(
                "Invalid type: `default_interval` must be "
                + "an int, float or str, not %s" % type(default_interval)
            )

        # If no options are provided and default_interval is provided,
        if options is None:
            resolved_options = [default_interval] if default_interval else []
        else:
            resolved_options = options

        if not isinstance(resolved_options, list):
            raise ValueError(
                "Invalid type: `options` must be a list, not %s"
                % type(resolved_options)
            )

        # If has options and default_interval is provided,
        # check that default_interval is in options.
        if (
            default_interval
            and len(resolved_options) > 0
            and (default_interval not in resolved_options)
        ):
            raise ValueError(
                "Invalid value: `default_interval` must be "
                + "one of the options, not %s" % default_interval
            )

        super().__init__(
            component_name=refresh.name,
            initial_value=0,
            label=label,
            args={
                "options": resolved_options,
                "default-interval": default_interval,
            },
            on_change=on_change,
        )

    def _convert_value(self, value: int) -> int:
        return value

#+END_SRC
*** run_button
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.run_button
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/run_button.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Callable, Final, Literal, Optional

from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import UIElement
from marimo._plugins.ui._impl.input import button
from marimo._runtime.context.types import ContextNotInitializedError

#+END_SRC
**** @mddoc: Class run_button
#+BEGIN_SRC python
@mddoc
class run_button(UIElement[Any, Any]):
    """
    A button that can be used to trigger computation.

    **Example.**

    ```python
    # a button that when clicked will have its value set to True;
    # any cells referencing that button will automatically run.
    button = mo.ui.run_button()
    button
    ```

    ```python
    slider = mo.ui.slider(1, 10)
    slider
    ```

    ```python
    # if the button hasn't been clicked, don't run.
    mo.stop(not button.value)

    slider.value
    ```

    When clicked, `run_button`'s value is set to `True`, and any cells
    referencing it are run. After those cells are run, `run_button`'s
    value will automatically be set back to `False` as long as automatic
    execution is enabled.

    **Attributes.**

    - `value`: the value of the button; `True` when clicked, and reset to
      `False` after cells referencing the button finish running (when
      automatic execution is enabled).

    **Initialization Args.**

    - `kind`: 'neutral', 'success', 'warn', or 'danger'
    - `disabled`: whether the button is disabled
    - `tooltip`: a tooltip to display for the button
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `full_width`: whether the input should take up the full width of its
        container
    - `keyboard_shortcut`: keyboard shortcut to trigger the button (e.g. 'Ctrl-L')
    """

    # We reuse the button plugin on the frontend, UI/logic are the same
    _name: Final[str] = button._name

    def __init__(
        self,
        kind: Literal["neutral", "success", "warn", "danger"] = "neutral",
        disabled: bool = False,
        tooltip: Optional[str] = None,
        *,
        label: str = "click to run",
        on_change: Optional[Callable[[Any], None]] = None,
        full_width: bool = False,
        keyboard_shortcut: Optional[str] = None,
    ) -> None:
        self._initial_value = False
        super().__init__(
            component_name=button._name,
            # frontend's value is a counter
            initial_value=0,
            label=label,
            args={
                "kind": kind,
                "disabled": disabled,
                "tooltip": tooltip,
                "full-width": full_width,
                "keyboard-shortcut": keyboard_shortcut,
            },
            on_change=on_change,
        )

    def _convert_value(self, value: Any) -> Any:
        if value == 0:
            # frontend's value == 0 only during initialization; first value
            # frontend will send is 1
            return False
        else:
            return True

    def _on_update_completion(self) -> None:
        from marimo._runtime.context import get_context
        from marimo._runtime.context.kernel_context import KernelRuntimeContext

        try:
            ctx = get_context()
        except ContextNotInitializedError:
            self._value = False
            return

        if isinstance(ctx, KernelRuntimeContext) and ctx.lazy:
            # Resetting to False in lazy kernels makes the button pointless,
            # since its value hasn't been read by downstream cells on update
            # completion.
            #
            # The right thing to do would be to somehow set to False after
            # all cells that were marked stale because of the update were run,
            # but that's too complicated.
            return
        else:
            self._value = False

#+END_SRC
*** switch
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.switch
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/switch.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Callable, Final, Optional

from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import UIElement

#+END_SRC
**** @mddoc: Class switch
#+BEGIN_SRC python
@mddoc
class switch(UIElement[bool, bool]):
    """
    A boolean switch.

    **Example.**

    ```python
    switch = mo.ui.switch()
    ```

    **Attributes.**

    - `value`: A boolean, `True` if checked.

    **Initialization Args.**

    - `value`: default value, True or False
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """

    _name: Final[str] = "marimo-switch"

    def __init__(
        self,
        value: bool = False,
        *,
        label: str = "",
        on_change: Optional[Callable[[bool], None]] = None,
    ) -> None:
        if not isinstance(value, bool):
            raise ValueError(
                "Invalid type: `value` must be a bool, but got %s"
                % type(value)
            )
        if not isinstance(label, str):
            raise ValueError(
                "Invalid type: `label` must be a str, but got %s" % type(label)
            )

        super().__init__(
            component_name=switch._name,
            initial_value=value,
            label=label,
            args={},
            on_change=on_change,
        )

    def _convert_value(self, value: bool) -> bool:
        return value

#+END_SRC
*** table
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.table
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/table.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import functools
from dataclasses import dataclass
from typing import (
    Any,
    Callable,
    Dict,
    Final,
    List,
    Literal,
    Optional,
    Sequence,
    Union,
)

from narwhals.typing import IntoDataFrame

import marimo._output.data.data as mo_data
from marimo import _loggers
from marimo._data.models import NonNestedLiteral
from marimo._output.mime import MIME
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType
from marimo._plugins.ui._core.ui_element import UIElement
from marimo._plugins.ui._impl.dataframes.transforms.apply import (
    get_handler_for_dataframe,
)
from marimo._plugins.ui._impl.dataframes.transforms.types import (
    Condition,
    FilterRowsTransform,
    TransformType,
)
from marimo._plugins.ui._impl.tables.table_manager import (
    ColumnName,
    TableManager,
)
from marimo._plugins.ui._impl.tables.utils import get_table_manager
from marimo._plugins.ui._impl.utils.dataframe import ListOrTuple, TableData
from marimo._plugins.validators import validate_no_integer_columns
from marimo._runtime.functions import EmptyArgs, Function
from marimo._utils.narwhals_utils import unwrap_narwhals_dataframe

#+END_SRC
**** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
**** @dataclass: Class DownloadAsArgs
#+BEGIN_SRC python
@dataclass
class DownloadAsArgs:
    format: Literal["csv", "json"]

#+END_SRC
**** @dataclass: Class ColumnSummary
#+BEGIN_SRC python
@dataclass
class ColumnSummary:
    column: str
    nulls: Optional[int]
    # int, float, datetime
    min: Optional[NonNestedLiteral]
    max: Optional[NonNestedLiteral]
    # str
    unique: Optional[int]
    # bool
    true: Optional[NonNestedLiteral] = None
    false: Optional[NonNestedLiteral] = None

#+END_SRC
**** @dataclass: Class ColumnSummaries
#+BEGIN_SRC python
@dataclass
class ColumnSummaries:
    data: Union[JSONType, str]
    summaries: List[ColumnSummary]
    # Disabled because of too many columns/rows
    # This will show a banner in the frontend
    is_disabled: Optional[bool] = None

#+END_SRC
**** @dataclass(frozen=True): Class SearchTableArgs
#+BEGIN_SRC python
@dataclass(frozen=True)
class SearchTableArgs:
    page_size: int
    page_number: int
    query: Optional[str] = None
    sort: Optional[SortArgs] = None
    filters: Optional[List[Condition]] = None
    limit: Optional[int] = None

#+END_SRC
**** @dataclass(frozen=True): Class SearchTableResponse
#+BEGIN_SRC python
@dataclass(frozen=True)
class SearchTableResponse:
    data: Union[JSONType, str]
    total_rows: int

#+END_SRC
**** @dataclass(frozen=True): Class SortArgs
#+BEGIN_SRC python
@dataclass(frozen=True)
class SortArgs:
    by: ColumnName
    descending: bool

#+END_SRC
**** @mddoc: Class table
#+BEGIN_SRC python
@mddoc
class table(UIElement[List[str], Union[List[JSONType], IntoDataFrame]]):
    """
    A table component with selectable rows. Get the selected rows with
    `table.value`.

    The table data can be supplied a:

    1. a list of dicts, with one dict for each row, keyed by column names;
    2. a list of values, representing a table with a single column;
    3. a Pandas dataframe; or
    4. a Polars dataframe; or
    5. an Ibis dataframe; or
    6. a PyArrow table.

    **Examples.**

    Create a table from a list of dicts, one for each row.

    ```python
    table = mo.ui.table(
        data=[
            {"first_name": "Michael", "last_name": "Scott"},
            {"first_name": "Dwight", "last_name": "Schrute"},
        ],
        label="Users",
    )
    ```

    Create a table from a single column of data:

    table = mo.ui.table(
      data=[
        {'first_name': 'Michael', 'last_name': 'Scott'},
        {'first_name': 'Dwight', 'last_name': 'Schrute'}
      ],
      label='Users'
    )

    Create a table from a dataframe:

    ```python
    # df is a Pandas or Polars dataframe
    table = mo.ui.table(
        data=df,
        # use pagination when your table has many rows
        pagination=True,
        label="Dataframe",
    )
    ```

    Create a table with format mapping:

    ```python
    # format_mapping is a dict keyed by column names,
    # with values as formatting functions or strings
    def format_name(name):
        return name.upper()


    table = mo.ui.table(
        data=[
            {"first_name": "Michael", "last_name": "Scott", "age": 45},
            {"first_name": "Dwight", "last_name": "Schrute", "age": 40},
        ],
        format_mapping={
            "first_name": format_name,  # Use callable to format first names
            "age": "{:.1f}".format,  # Use string format for age
        },
        label="Format Mapping",
    )
    ```
    In each case, access the table data with `table.value`.

    **Attributes.**

    - `value`: the selected rows, in the same format as the original data,
       or `None` if no selection
    - `data`: the original table data

    **Initialization Args.**

    - `data`: Values can be primitives (`str`,
      `int`, `float`, `bool`, or `None`) or marimo elements: e.g.
      `mo.ui.button(...)`, `mo.md(...)`, `mo.as_html(...)`, etc. Data can be
      passed in many ways:
        - as dataframes: a pandas dataframe, a polars dataframe
        - as rows: a list of dicts, where each dict represents a row in the
          table
        - as columns: a dict keyed by column names, where the value of each
          entry is a list representing a column
        - as a single column: a list of values
    - `pagination`: whether to paginate; if `False`, all rows will be shown
      defaults to `True` when above 10 rows, `False` otherwise
    - `selection`: 'single' or 'multi' to enable row selection, or `None` to
        disable
    - `page_size`: the number of rows to show per page.
      defaults to 10
    - `show_column_summaries`: whether to show column summaries
      defaults to `True` when the table has less than 40 columns, `False` otherwise
    - `show_download`: whether to show the download button
      defaults to `True` for dataframes, `False` otherwise
    - `format_mapping`: a mapping from column names to formatting strings
    or functions
    - `freeze_columns_left`: list of column names to freeze on the left
    - `freeze_columns_right`: list of column names to freeze on the right
    - `text_justify_columns`: dictionary of column names to text justification
      options: `left`, `center`, `right`
    - `wrapped_columns`: list of column names to wrap
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `max_columns`: maximum number of columns to display, defaults to 50.
      Set to None to show all columns.
    """

    _name: Final[str] = "marimo-table"

    def __init__(
        self,
        data: Union[
            ListOrTuple[Union[str, int, float, bool, MIME, None]],
            ListOrTuple[Dict[str, JSONType]],
            Dict[str, ListOrTuple[JSONType]],
            "IntoDataFrame",
        ],
        pagination: Optional[bool] = None,
        selection: Optional[Literal["single", "multi"]] = "multi",
        page_size: int = 10,
        show_column_summaries: Optional[bool] = None,
        format_mapping: Optional[
            Dict[str, Union[str, Callable[..., Any]]]
        ] = None,
        freeze_columns_left: Optional[Sequence[str]] = None,
        freeze_columns_right: Optional[Sequence[str]] = None,
        text_justify_columns: Optional[
            Dict[str, Literal["left", "center", "right"]]
        ] = None,
        wrapped_columns: Optional[List[str]] = None,
        show_download: bool = True,
        max_columns: Optional[int] = 50,
        *,
        label: str = "",
        on_change: Optional[
            Callable[
                [
                    Union[
                        List[JSONType],
                        Dict[str, ListOrTuple[JSONType]],
                        "IntoDataFrame",
                    ]
                ],
                None,
            ]
        ] = None,
        # The _internal_* arguments are for overriding and unit tests
        # table should take the value unconditionally
        _internal_column_charts_row_limit: Optional[int] = None,
        _internal_summary_row_limit: Optional[int] = None,
        _internal_total_rows: Optional[Union[int, Literal["too_many"]]] = None,
    ) -> None:
        validate_no_integer_columns(data)

        # The original data passed in
        self._data = data
        # Holds the original data
        self._manager = get_table_manager(data)
        self._max_columns = max_columns

        # Set the default value for show_column_summaries,
        # if it is not set by the user
        if show_column_summaries is None:
            show_column_summaries = (
                self._manager.get_num_columns()
                <= TableManager.DEFAULT_SUMMARY_CHARTS_COLUMN_LIMIT
            )
        self._show_column_summaries = show_column_summaries

        if _internal_column_charts_row_limit is not None:
            self._column_charts_row_limit = _internal_column_charts_row_limit
        else:
            self._column_charts_row_limit = (
                TableManager.DEFAULT_SUMMARY_CHARTS_ROW_LIMIT
            )

        if _internal_summary_row_limit is not None:
            self._column_summary_row_limit = _internal_summary_row_limit
        else:
            self._column_summary_row_limit = (
                TableManager.DEFAULT_SUMMARY_STATS_ROW_LIMIT
            )

        # Holds the data after user searching from original data
        # (searching operations include query, sort, filter, etc.)
        self._searched_manager = self._manager
        # Holds the data after user selecting from the component
        self._selected_manager: Optional[TableManager[Any]] = None

        # We will need this when calling table manager's to_data()
        self._format_mapping = format_mapping

        field_types = self._manager.get_field_types()

        if _internal_total_rows is not None:
            total_rows = _internal_total_rows
        else:
            num_rows = self._manager.get_num_rows(force=True)
            total_rows = num_rows if num_rows is not None else "too_many"

        if pagination is False and total_rows != "too_many":
            page_size = total_rows
        # pagination defaults to True if there are more than page_size rows
        if pagination is None:
            if total_rows == "too_many":
                pagination = True
            elif total_rows > page_size:
                pagination = True
            else:
                pagination = False

        # Search first page
        search_result = self.search(
            SearchTableArgs(
                page_size=page_size,
                page_number=0,
                query=None,
                sort=None,
                filters=None,
            )
        )

        # Validate frozen columns
        if (
            freeze_columns_left is not None
            and freeze_columns_right is not None
        ):
            for column in freeze_columns_left:
                if column not in freeze_columns_right:
                    continue
                raise ValueError(
                    "The same column cannot be frozen on both sides."
                )
        else:
            column_names = self._manager.get_column_names()
            if freeze_columns_left is not None:
                for column in freeze_columns_left:
                    if column not in column_names:
                        raise ValueError(
                            f"Column '{column}' not found in table."
                        )
            if freeze_columns_right is not None:
                for column in freeze_columns_right:
                    if column not in column_names:
                        raise ValueError(
                            f"Column '{column}' not found in table."
                        )

        if text_justify_columns:
            valid_justifications = {"left", "center", "right"}
            column_names = self._manager.get_column_names()

            for column, justify in text_justify_columns.items():
                if column not in column_names:
                    raise ValueError(f"Column '{column}' not found in table.")
                if justify not in valid_justifications:
                    raise ValueError(
                        f"Invalid justification '{justify}' for column '{column}'. "
                        f"Must be one of: {', '.join(valid_justifications)}."
                    )

        if wrapped_columns:
            column_names = self._manager.get_column_names()
            for column in wrapped_columns:
                if column not in column_names:
                    raise ValueError(f"Column '{column}' not found in table.")

        # Clamp field types to max columns
        if (
            self._max_columns is not None
            and len(field_types) > self._max_columns
        ):
            field_types = field_types[: self._max_columns]

        super().__init__(
            component_name=table._name,
            label=label,
            initial_value=[],
            args={
                "data": search_result.data,
                "total-rows": total_rows,
                "total-columns": self._manager.get_num_columns(),
                "banner-text": self._get_banner_text(),
                "pagination": pagination,
                "page-size": page_size,
                "field-types": field_types or None,
                "selection": (
                    selection if self._manager.supports_selection() else None
                ),
                "show-filters": self._manager.supports_filters(),
                "show-download": show_download
                and self._manager.supports_download(),
                "show-column-summaries": show_column_summaries,
                "row-headers": self._manager.get_row_headers(),
                "freeze-columns-left": freeze_columns_left,
                "freeze-columns-right": freeze_columns_right,
                "text-justify-columns": text_justify_columns,
                "wrapped-columns": wrapped_columns,
            },
            on_change=on_change,
            functions=(
                Function(
                    name=self.download_as.__name__,
                    arg_cls=DownloadAsArgs,
                    function=self.download_as,
                ),
                Function(
                    name=self.get_column_summaries.__name__,
                    arg_cls=EmptyArgs,
                    function=self.get_column_summaries,
                ),
                Function(
                    name=self.search.__name__,
                    arg_cls=SearchTableArgs,
                    function=self.search,
                ),
            ),
        )

    @property
    def data(
        self,
    ) -> TableData:
        return self._data

    def _get_banner_text(self) -> str:
        total_columns = self._manager.get_num_columns()
        if self._max_columns is not None and total_columns > self._max_columns:
            return (
                f"Only showing {self._max_columns} of {total_columns} columns."
            )
        return ""

    def _convert_value(
        self, value: list[str]
    ) -> Union[List[JSONType], "IntoDataFrame"]:
        indices = [int(v) for v in value]
        self._selected_manager = self._searched_manager.select_rows(indices)
        self._has_any_selection = len(indices) > 0
        return unwrap_narwhals_dataframe(self._selected_manager.data)  # type: ignore[no-any-return]

    def download_as(self, args: DownloadAsArgs) -> str:
        # download selected rows if there are any, otherwise use all rows
        # not apply formatting here, raw data is downloaded
        manager = (
            self._selected_manager
            if self._selected_manager and self._has_any_selection
            # use _searched_manager here to download the full data
            else self._searched_manager
        )

        ext = args.format
        if ext == "csv":
            return mo_data.csv(manager.to_csv()).url
        elif ext == "json":
            return mo_data.json(manager.to_json()).url
        else:
            raise ValueError("format must be one of 'csv' or 'json'.")

    def get_column_summaries(self, args: EmptyArgs) -> ColumnSummaries:
        del args
        if not self._show_column_summaries:
            return ColumnSummaries(
                data=None,
                summaries=[],
                # This is not 'disabled' because of too many rows
                # so we don't want to display the banner
                is_disabled=False,
            )

        total_rows = self._searched_manager.get_num_rows(force=True) or 0

        # Avoid expensive column summaries calculation by setting a upper limit
        # if we are above the limit, we hide the column summaries
        if total_rows > self._column_summary_row_limit:
            return ColumnSummaries(
                data=None,
                summaries=[],
                is_disabled=True,
            )

        # Get column summaries
        summaries: List[ColumnSummary] = []
        for column in self._manager.get_column_names():
            try:
                summary = self._searched_manager.get_summary(column)
                summaries.append(
                    ColumnSummary(
                        column=column,
                        nulls=summary.nulls,
                        min=summary.min,
                        max=summary.max,
                        unique=summary.unique,
                        true=summary.true,
                        false=summary.false,
                    )
                )
            except BaseException:
                # Catch-all: some libraries like Polars have bugs and raise
                # BaseExceptions, which shouldn't crash the kernel
                LOGGER.warning("Failed to get summary for column %s", column)

        # If we are above the limit to show charts,
        # we don't return the chart data
        if total_rows > self._column_charts_row_limit:
            return ColumnSummaries(
                data=None,
                summaries=summaries,
                # We are still showing summaries,
                # so we don't want to display the banner
                is_disabled=False,
            )

        return ColumnSummaries(
            data=self._searched_manager.to_data({}),
            summaries=summaries,
            is_disabled=False,
        )

    @functools.lru_cache(maxsize=1)  # noqa: B019
    def _apply_filters_query_sort(
        self,
        filters: Optional[List[Condition]],
        query: Optional[str],
        sort: Optional[SortArgs],
    ) -> TableManager[Any]:
        result = self._manager

        if filters:
            data = unwrap_narwhals_dataframe(result.data)
            handler = get_handler_for_dataframe(data)
            data = handler.handle_filter_rows(
                data,
                FilterRowsTransform(
                    type=TransformType.FILTER_ROWS,
                    where=filters,
                    operation="keep_rows",
                ),
            )
            result = get_table_manager(data)

        if query:
            result = result.search(query)

        if sort:
            result = result.sort_values(sort.by, sort.descending)

        return result

    def search(self, args: SearchTableArgs) -> SearchTableResponse:
        offset = args.page_number * args.page_size

        def clamp_rows_and_columns(manager: TableManager[Any]) -> JSONType:
            # Limit to page and column clamping for the frontend
            data = manager.take(args.page_size, offset)
            column_names = data.get_column_names()
            if (
                self._max_columns is not None
                and len(column_names) > self._max_columns
            ):
                data = data.select_columns(column_names[: self._max_columns])
            return data.to_data(self._format_mapping)

        # If no query or sort, return nothing
        # The frontend will just show the original data
        if not args.query and not args.sort and not args.filters:
            self._searched_manager = self._manager
            return SearchTableResponse(
                data=clamp_rows_and_columns(self._manager),
                total_rows=self._manager.get_num_rows(force=True) or 0,
            )

        # Apply filters, query, and functools.sort using the cached method
        result = self._apply_filters_query_sort(
            tuple(args.filters) if args.filters else None,
            args.query,
            args.sort,
        )

        # Save the manager to be used for selection
        self._searched_manager = result

        return SearchTableResponse(
            data=clamp_rows_and_columns(result),
            total_rows=result.get_num_rows(force=True) or 0,
        )

    def __hash__(self) -> int:
        return id(self)

#+END_SRC
*** tabs
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.tabs
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/tabs.py
:END:
**** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Callable, Final, Optional

from marimo._output.formatting import as_html
from marimo._output.md import md
from marimo._output.rich_help import mddoc
from marimo._plugins.stateless.lazy import lazy as lazy_ui
from marimo._plugins.ui._core.ui_element import UIElement

#+END_SRC
**** @mddoc: Class tabs
#+BEGIN_SRC python
@mddoc
class tabs(UIElement[str, str]):
    """Display objects in a tabbed view.

    **Examples.**

    Show content in tabs:

    ```python
    tab1 = mo.vstack([
        "slider": mo.ui.slider(1, 10),
        "text": mo.ui.text(),
        "date": mo.ui.date()
    ])

    tab2 = mo.md("You can show arbitrary content in a tab.")

    tabs = mo.ui.tabs({
        "Heading 1": tab1,
        "Heading 2": tab2
    })
    ```

    Control which tab is selected:

    ```python
    tabs = mo.ui.tabs(
        {"Heading 1": tab1, "Heading 2": tab2}, value="Heading 2"
    )
    ```

    Tab content can be lazily loaded:

    ```python
    tabs = mo.ui.tabs(
        {"Heading 1": tab1, "Heading 2": expensive_component}, lazy=True
    )
    ```

    **Attributes.**

    - `value`: A string, the name of the selected tab.

    **Initialization Args.**

    - `tabs`: a dictionary of tab names to tab content; strings are interpreted
              as markdown
    - `value`: the name of the tab to open; defaults to the first tab
    - `lazy`: a boolean, whether to lazily load the tab content.
              This is a convenience that wraps each tab in a `mo.lazy`
              component.
    """

    _name: Final[str] = "marimo-tabs"

    def __init__(
        self,
        tabs: dict[str, object],
        value: Optional[str] = None,
        lazy: bool = False,
        *,
        label: str = "",
        on_change: Optional[Callable[[str], None]] = None,
    ) -> None:
        def render_content(tab: object) -> str:
            if lazy:
                return lazy_ui(tab).text
            if isinstance(tab, str):
                return md(tab).text
            return as_html(tab).text

        tab_items = "".join(
            [
                "<div data-kind='tab'>" + render_content(tab) + "</div>"
                for tab in tabs.values()
            ]
        )

        self._tab_keys = list(tabs.keys())
        tab_labels = list(md(label).text for label in tabs.keys())

        index = (
            str(self._tab_keys.index(value))
            if value in self._tab_keys and tabs
            else None
        )

        super().__init__(
            component_name=self._name,
            initial_value=index or "",
            label=label,
            args={"tabs": tab_labels},
            on_change=on_change,
            slotted_html=tab_items,
        )

    def _convert_value(self, value: str) -> str:
        if not value:
            return self._tab_keys[0]
        index = int(value)
        return self._tab_keys[index]

#+END_SRC
*** anywidget
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.anywidget
:END:
**** init
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.anywidget.init
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/anywidget/init.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import TYPE_CHECKING, cast
from uuid import uuid4

#+END_SRC
***** Import
#+BEGIN_SRC python
if TYPE_CHECKING:
    import ipywidgets  # type: ignore

from marimo._dependencies.dependencies import DependencyManager
from marimo._plugins.ui._impl.comm import (  # pyright: ignore[reportMissingTypeStubs]
    BufferType,
    MarimoComm,
    MarimoCommManager,
)

#+END_SRC
***** Function init_marimo_widget
#+BEGIN_SRC python
# Initialize ipywidgets using a MarimoComm
def init_marimo_widget(w: "ipywidgets.Widget") -> None:
    DependencyManager.ipywidgets.require("for anywidget support.")
    import ipywidgets  # type: ignore

    __protocol_version__ = ipywidgets._version.__protocol_version__
    _remove_buffers = ipywidgets.widgets.widget._remove_buffers  # type: ignore

    # Get the initial state of the widget
    state, buffer_paths, buffers = _remove_buffers(w.get_state())  # type: ignore

    # Generate a random model_id so we can assign the same id to the comm
    if getattr(w, "_model_id", None) is None:
        w._model_id = uuid4().hex

    # Initialize the comm...this will also send the initial state of the widget
    w.comm = MarimoComm(
        comm_id=w._model_id,  # pyright: ignore
        comm_manager=COMM_MANAGER,
        target_name="jupyter.widgets",
        data={"state": state, "buffer_paths": buffer_paths},
        buffers=cast(BufferType, buffers),
        # TODO: should this be hard-coded?
        metadata={"version": __protocol_version__},
        # html_deps=session._process_ui(TagList(widget_dep))["deps"],
    )

#+END_SRC
***** Assignment COMM_MANAGER = MarimoCommManager()
#+BEGIN_SRC python
COMM_MANAGER = MarimoCommManager()

#+END_SRC
*** charts
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.charts
:END:
**** altair_transformer
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.charts.altair_transformer
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/charts/altair_transformer.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import base64
from typing import Any, Dict, Literal, TypedDict, Union

import narwhals.stable.v1 as nw
from narwhals.typing import IntoDataFrame

import marimo._output.data.data as mo_data
from marimo._dependencies.dependencies import DependencyManager
from marimo._output.utils import build_data_url
from marimo._plugins.ui._impl.tables.utils import (
    get_table_manager,
    get_table_manager_or_none,
)

#+END_SRC
***** Assignment Data = Union[Dict[Any, Any], IntoDataFrame, nw.DataFrame[Any]]
#+BEGIN_SRC python
Data = Union[Dict[Any, Any], IntoDataFrame, nw.DataFrame[Any]]

#+END_SRC
***** Assignment _DataType = Union[Dict[Any, Any], IntoDataFrame, nw.DataFrame[Any]]
#+BEGIN_SRC python
_DataType = Union[Dict[Any, Any], IntoDataFrame, nw.DataFrame[Any]]

#+END_SRC
***** Class _JsonFormatDict
#+BEGIN_SRC python
class _JsonFormatDict(TypedDict):
    type: Literal["json"]

#+END_SRC
***** Class _CsvFormatDict
#+BEGIN_SRC python
class _CsvFormatDict(TypedDict):
    type: Literal["csv"]

#+END_SRC
***** Class _ToJsonReturnUrlDict
#+BEGIN_SRC python
class _ToJsonReturnUrlDict(TypedDict):
    url: str
    format: _JsonFormatDict

#+END_SRC
***** Class _ToCsvReturnUrlDict
#+BEGIN_SRC python
class _ToCsvReturnUrlDict(TypedDict):
    url: str
    format: _CsvFormatDict

#+END_SRC
***** Function _to_marimo_json
#+BEGIN_SRC python
def _to_marimo_json(data: Data, **kwargs: Any) -> _ToJsonReturnUrlDict:
    """
    Custom implementation of altair.utils.data.to_json that
    returns a VirtualFile URL instead of writing to disk.
    """
    del kwargs
    data_json = _data_to_json_string(data)
    virtual_file = mo_data.json(data_json.encode("utf-8"))
    return {"url": virtual_file.url, "format": {"type": "json"}}

#+END_SRC
***** Function _to_marimo_csv
#+BEGIN_SRC python
def _to_marimo_csv(data: Data, **kwargs: Any) -> _ToCsvReturnUrlDict:
    """
    Custom implementation of altair.utils.data.to_csv that
    returns a VirtualFile URL instead of writing to disk.
    """
    del kwargs
    data_csv = _data_to_csv_string(data)
    virtual_file = mo_data.csv(data_csv.encode("utf-8"))
    return {"url": virtual_file.url, "format": {"type": "csv"}}

#+END_SRC
***** Function _to_marimo_inline_csv
#+BEGIN_SRC python
def _to_marimo_inline_csv(data: Data, **kwargs: Any) -> _ToCsvReturnUrlDict:
    """
    Custom implementation of altair.utils.data.to_csv that
    inlines the CSV data in the URL.
    """
    del kwargs
    data_csv = _data_to_csv_string(data)
    url = build_data_url(
        mimetype="text/csv",
        data=base64.b64encode(data_csv.encode("utf-8")),
    )
    return {"url": url, "format": {"type": "csv"}}

#+END_SRC
***** Function _data_to_json_string
#+BEGIN_SRC python
# Copied from https://github.com/altair-viz/altair/blob/0ca83784e2455f2b84d0f6d789af2abbe8814348/altair/utils/data.py#L263C1-L288C10
def _data_to_json_string(data: _DataType) -> str:
    """Return a JSON string representation of the input data"""
    import altair as alt  # type: ignore[import-not-found,import-untyped,unused-ignore] # noqa: E501
    import pandas as pd

    if isinstance(data, pd.DataFrame):
        if "sanitize_pandas_dataframe" in dir(alt.utils):
            sanitized = alt.utils.sanitize_pandas_dataframe(data)
        elif "sanitize_dataframe" in dir(alt.utils):
            sanitized = alt.utils.sanitize_dataframe(data)
        else:
            raise NotImplementedError(
                "No sanitize_pandas_dataframe or "
                "sanitize_dataframe in altair.utils."
            )
        as_str = sanitized.to_json(orient="records", double_precision=15)
        assert isinstance(as_str, str)
        return as_str

    if DependencyManager.narwhals.has():
        import narwhals

        if isinstance(data, narwhals.DataFrame):
            return _data_to_json_string(narwhals.to_native(data))

    tm = get_table_manager_or_none(data)
    if tm:
        return tm.to_json().decode("utf-8")

    raise NotImplementedError(
        "to_marimo_json only works with data expressed as a DataFrame "
        + " or as a dict. Got %s" % type(data)
    )

#+END_SRC
***** Function _data_to_csv_string
#+BEGIN_SRC python
def _data_to_csv_string(data: _DataType) -> str:
    """Return a CSV string representation of the input data"""
    return get_table_manager(data).to_csv().decode("utf-8")

#+END_SRC
***** Function register_transformers
#+BEGIN_SRC python
def register_transformers() -> None:
    """
    Register custom data transformers for Altair.

    We register a CSV transformer and a JSON transformer. These
    transformers return a VirtualFile URL instead of writing to disk,
    which is the default behavior of Altair's to_csv and to_json.

    By registering these transformers, we are able to use
    much larger datasets.
    """
    import altair as alt

    # We keep the previous options, in case the user has set them
    # we don't want to override them.

    # Default to CSV. Due to the columnar nature of CSV, it is more efficient
    # than JSON for large datasets (~80% smaller file size).
    alt.data_transformers.register("marimo", _to_marimo_csv)
    alt.data_transformers.register("marimo_inline_csv", _to_marimo_inline_csv)
    alt.data_transformers.register("marimo_json", _to_marimo_json)
    alt.data_transformers.register("marimo_csv", _to_marimo_csv)

#+END_SRC
*** chat
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.chat
:END:
**** chat
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.chat.chat
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/chat/chat.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import inspect
from dataclasses import dataclass
from typing import Any, Callable, Dict, Final, List, Optional, Union, cast

from marimo._ai.types import (
    ChatMessage,
    ChatModelConfig,
    ChatModelConfigDict,
)
from marimo._output.formatting import as_html
from marimo._output.md import md
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType
from marimo._plugins.ui._core.ui_element import UIElement
from marimo._plugins.ui._impl.chat.utils import from_chat_message_dict
from marimo._runtime.context.kernel_context import KernelRuntimeContext
from marimo._runtime.context.types import ContextNotInitializedError
from marimo._runtime.functions import EmptyArgs, Function
from marimo._runtime.requests import SetUIElementValueRequest

#+END_SRC
***** @dataclass: Class SendMessageRequest
#+BEGIN_SRC python
@dataclass
class SendMessageRequest:
    messages: List[ChatMessage]
    config: ChatModelConfig

#+END_SRC
***** @dataclass: Class GetChatHistoryResponse
#+BEGIN_SRC python
@dataclass
class GetChatHistoryResponse:
    messages: List[ChatMessage]

#+END_SRC
***** @mddoc: Class chat
#+BEGIN_SRC python
@mddoc
class chat(UIElement[Dict[str, Any], List[ChatMessage]]):
    """
    A chatbot UI element for interactive conversations.

    **Example: Using a custom model.**

    Define a chatbot by implementing a function that takes a list of
    `ChatMessage`s and optionally a config object as input, and returns the
    chat response. The response can be any object, including text, plots, or
    marimo UI elements.

    ```python
    def my_rag_model(messages, config):
        # Each message has a `content` attribute, as well as a `role`
        # attribute ("user", "system", "assistant");
        question = messages[-1].content
        docs = find_docs(question)
        prompt = template(question, docs, messages)
        response = query(prompt)
        if is_dataset(response):
            return dataset_to_chart(response)
        return response


    chat = mo.ui.chat(my_rag_model)
    ```

    Async functions and async generators are also supported, meaning these
    are both valid chat functions:

    ```python
    async def my_rag_model(messages):
        return await my_async_function(messages)
    ```

    ```python
    async def my_rag_model(messages):
        for response in my_async_iterator(messages):
            yield response
    ```

    The last value yielded by the async generator is treated as the model
    response. ui.chat does not yet support streaming responses to the frontend.
    Please file a GitHub issue if this is important to you:
    https://github.com/marimo-team/marimo/issues

    **Example: Using a built-in model.**

    Instead of defining a chatbot function, you can use a built-in model from
    the `mo.ai.llm` module.

    ```python
    chat = mo.ui.chat(
        mo.ai.llm.openai(
            "gpt-4o",
            system_message="You are a helpful assistant.",
        ),
    )
    ```

    You can also allow the user to include attachments in their messages.

    ```python
    chat = mo.ui.chat(
        mo.ai.llm.openai(
            "gpt-4o",
        ),
        allow_attachments=["image/png", "image/jpeg"],
    )
    ```

    **Attributes.**

    - `value`: the current chat history, a list of `ChatMessage` objects.

    **Initialization Args.**

    - `model`: `(Callable[[List[ChatMessage], ChatModelConfig], object])` a
        callable that takes in the chat history and returns a response
    - `prompts`: optional list of initial prompts to present to the user
    - `on_message`: optional callback function to handle new messages
    - `show_configuration_controls`: whether to show the configuration controls
    - `config`: optional `ChatModelConfigDict` to override the default
        configuration. Keys include:
        - `max_tokens`
        - `temperature`
        - `top_p`
        - `top_k`
        - `frequency_penalty`
        - `presence_penalty`
    - `allow_attachments`: (bool | List[str]) allow attachments. True for any
        attachments types, or pass a list of mime types
    - `max_height`: optional maximum height for the chat element
    """

    _name: Final[str] = "marimo-chatbot"

    def __init__(
        self,
        model: Callable[[List[ChatMessage], ChatModelConfig], object],
        *,
        prompts: Optional[List[str]] = None,
        on_message: Optional[Callable[[List[ChatMessage]], None]] = None,
        show_configuration_controls: bool = False,
        config: Optional[ChatModelConfigDict] = None,
        allow_attachments: Union[bool, List[str]] = False,
        max_height: Optional[int] = None,
    ) -> None:
        self._model = model
        self._chat_history: List[ChatMessage] = []

        super().__init__(
            component_name=chat._name,
            initial_value={"messages": self._chat_history},
            on_change=on_message,
            label="",
            args={
                "prompts": prompts,
                "show-configuration-controls": show_configuration_controls,
                "config": cast(JSONType, config or {}),
                "allow-attachments": allow_attachments,
                "max-height": max_height,
            },
            functions=(
                Function(
                    name="get_chat_history",
                    arg_cls=EmptyArgs,
                    function=self._get_chat_history,
                ),
                Function(
                    name="send_prompt",
                    arg_cls=SendMessageRequest,
                    function=self._send_prompt,
                ),
            ),
        )

    def _get_chat_history(self, _args: EmptyArgs) -> GetChatHistoryResponse:
        return GetChatHistoryResponse(messages=self._chat_history)

    async def _send_prompt(self, args: SendMessageRequest) -> str:
        messages = args.messages

        # If the model is a callable that takes a single argument,
        # call it with just the messages.
        response: object
        if (
            callable(self._model)
            and not isinstance(self._model, type)
            and len(inspect.signature(self._model).parameters) == 1
        ):
            response = self._model(messages)  # type: ignore
        else:
            response = self._model(messages, args.config)

        if inspect.isawaitable(response):
            response = await response
        elif inspect.isasyncgen(response):
            # We support functions that stream the response with an async
            # generator; each yielded value is the latest representation of the
            # response, and the last value is the full value
            latest_response = None
            async for latest_response in response:  # noqa: B007
                # TODO(akshayka, mscolnick): Stream response to frontend
                # once bidirectional communication is implemented.
                #
                # RPCs don't yet support bidirectional communication, so we
                # just ignore all the initial responses; ideally we'd stream
                # the response back to the frontend.
                pass
            response = latest_response

        response_message = ChatMessage(role="assistant", content=response)
        self._chat_history = messages + [response_message]

        from marimo._runtime.context import get_context

        # The frontend doesn't manage state, so we have to manually enqueue
        # a control request.
        try:
            ctx = get_context()
        except ContextNotInitializedError:
            # For testing ... this should never happen in real usage.
            self._value = self._chat_history
            if self._on_change is not None:
                self._on_change(self._value)
        else:
            if isinstance(ctx, KernelRuntimeContext):
                ctx._kernel.enqueue_control_request(
                    SetUIElementValueRequest(
                        object_ids=[self._id],
                        values=[{"messages": self._chat_history}],
                    )
                )

        # Return the response as HTML
        # If the response is a string, convert it to markdown
        if isinstance(response, str):
            return md(response).text
        return as_html(response).text

    def _convert_value(self, value: Dict[str, Any]) -> List[ChatMessage]:
        if not isinstance(value, dict) or "messages" not in value:
            raise ValueError("Invalid chat history format")

        messages = value["messages"]
        return [from_chat_message_dict(msg) for msg in messages]

#+END_SRC
**** utils
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.chat.utils
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/chat/utils.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import List, Optional

from marimo._ai.types import (
    ChatAttachment,
    ChatMessage,
    ChatMessageDict,
)

#+END_SRC
***** Function from_chat_message_dict
#+BEGIN_SRC python
def from_chat_message_dict(d: ChatMessageDict) -> ChatMessage:
    if isinstance(d, ChatMessage):
        return d

    attachments_dict = d.get("attachments", None)
    attachments: Optional[List[ChatAttachment]] = None
    if attachments_dict is not None:
        attachments = [
            ChatAttachment(
                name=attachment["name"] or "attachment",
                content_type=attachment["content_type"],
                url=attachment["url"],
            )
            for attachment in attachments_dict
        ]
    else:
        attachments = None

    return ChatMessage(
        role=d["role"],
        content=d["content"],
        attachments=attachments,
    )

#+END_SRC
*** dataframes
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.dataframes
:END:
**** dataframe
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.dataframes.dataframe
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/dataframes/dataframe.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import inspect
import sys
from dataclasses import dataclass
from typing import (
    Any,
    Callable,
    Dict,
    Final,
    List,
    Optional,
    Union,
)

from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import UIElement
from marimo._plugins.ui._impl.dataframes.transforms.apply import (
    TransformsContainer,
    get_handler_for_dataframe,
)
from marimo._plugins.ui._impl.dataframes.transforms.types import (
    DataFrameType,
    Transformations,
)
from marimo._plugins.ui._impl.table import (
    SearchTableArgs,
    SearchTableResponse,
    SortArgs,
)
from marimo._plugins.ui._impl.tables.table_manager import (
    FieldTypes,
    TableManager,
)
from marimo._plugins.ui._impl.tables.utils import (
    get_table_manager,
)
from marimo._plugins.validators import validate_no_integer_columns
from marimo._runtime.functions import EmptyArgs, Function
from marimo._utils.memoize import memoize_last_value
from marimo._utils.parse_dataclass import parse_raw

#+END_SRC
***** @dataclass: Class GetDataFrameResponse
#+BEGIN_SRC python
@dataclass
class GetDataFrameResponse:
    url: str
    total_rows: int
    # List of column names that are actually row headers
    # This really only applies to Pandas, that has special index columns
    row_headers: List[str]
    field_types: FieldTypes
    python_code: Optional[str] = None
    sql_code: Optional[str] = None

#+END_SRC
***** @dataclass: Class GetColumnValuesArgs
#+BEGIN_SRC python
@dataclass
class GetColumnValuesArgs:
    column: str

#+END_SRC
***** @dataclass: Class GetColumnValuesResponse
#+BEGIN_SRC python
@dataclass
class GetColumnValuesResponse:
    values: List[str | int | float]
    too_many_values: bool

#+END_SRC
***** Class ColumnNotFound
#+BEGIN_SRC python
class ColumnNotFound(Exception):
    def __init__(self, column: str):
        self.column = column
        super().__init__(f"Column {column} does not exist")

#+END_SRC
***** Class GetDataFrameError
#+BEGIN_SRC python
class GetDataFrameError(Exception):
    def __init__(self, error: str):
        self.error = error
        super().__init__(error)

#+END_SRC
***** @mddoc: Class dataframe
#+BEGIN_SRC python
@mddoc
class dataframe(UIElement[Dict[str, Any], DataFrameType]):
    """
    Run transformations on a DataFrame or series.
    Currently only Pandas or Polars DataFrames are supported.

    **Example.**

    ```python
    dataframe = mo.ui.dataframe(data)
    ```

    **Attributes.**

    - `value`: the transformed DataFrame or series

    **Initialization Args.**

    - `df`: the DataFrame or series to transform
    - `page_size`: the number of rows to show in the table
    - `limit`: the number of items to load into memory, in case
        the data is remote and lazily fetched. This is likely true
        for SQL-backed dataframes via Ibis.
    """

    _name: Final[str] = "marimo-dataframe"

    def __init__(
        self,
        df: DataFrameType,
        on_change: Optional[Callable[[DataFrameType], None]] = None,
        page_size: Optional[int] = 5,
        limit: Optional[int] = None,
    ) -> None:
        validate_no_integer_columns(df)
        # This will raise an error if the dataframe type is not supported.
        handler = get_handler_for_dataframe(df)

        # HACK: this is a hack to get the name of the variable that was passed
        dataframe_name = "df"
        try:
            frame = inspect.currentframe()
            if frame is not None and frame.f_back is not None:
                for (
                    var_name,
                    var_value,
                ) in frame.f_back.f_locals.items():
                    if var_value is df:
                        dataframe_name = var_name
                        break
        except Exception:
            pass

        self._limit = limit
        self._dataframe_name = dataframe_name
        self._data = df
        self._handler = handler
        self._manager = self._get_cached_table_manager(df, self._limit)
        self._transform_container = TransformsContainer[DataFrameType](
            df, handler
        )
        self._error: Optional[str] = None
        self._last_transforms = Transformations([])
        self._page_size = page_size or 5  # Default to 5 rows (.head())

        super().__init__(
            component_name=dataframe._name,
            initial_value={
                "transforms": [],
            },
            on_change=on_change,
            label="",
            args={
                "columns": self._get_column_types(),
                "dataframe-name": dataframe_name,
                "total": self._manager.get_num_rows(force=False),
                "page-size": page_size,
            },
            functions=(
                Function(
                    name=self.get_dataframe.__name__,
                    arg_cls=EmptyArgs,
                    function=self.get_dataframe,
                ),
                Function(
                    name=self.get_column_values.__name__,
                    arg_cls=GetColumnValuesArgs,
                    function=self.get_column_values,
                ),
                Function(
                    name=self.search.__name__,
                    arg_cls=SearchTableArgs,
                    function=self.search,
                ),
            ),
        )

    def _get_column_types(self) -> List[List[Union[str, int]]]:
        return [
            [name, dtype[0], dtype[1]]
            for name, dtype in self._manager.get_field_types()
        ]

    def get_dataframe(self, _args: EmptyArgs) -> GetDataFrameResponse:
        if self._error is not None:
            raise GetDataFrameError(self._error)

        manager = self._get_cached_table_manager(self._value, self._limit)
        response = self.search(
            SearchTableArgs(page_size=self._page_size, page_number=0)
        )
        return GetDataFrameResponse(
            url=str(response.data),
            total_rows=response.total_rows,
            row_headers=manager.get_row_headers(),
            field_types=manager.get_field_types(),
            python_code=self._handler.as_python_code(
                self._dataframe_name,
                manager.get_column_names(),
                self._last_transforms.transforms,
            ),
            sql_code=self._handler.as_sql_code(manager.data),
        )

    def get_column_values(
        self, args: GetColumnValuesArgs
    ) -> GetColumnValuesResponse:
        """Get all the unique values in a column."""
        LIMIT = 500

        columns = self._manager.get_column_names()
        if args.column not in columns:
            raise ColumnNotFound(args.column)

        # We get the unique values from the original dataframe, not the
        # transformed one
        unique_values = self._manager.get_unique_column_values(args.column)
        if len(unique_values) <= LIMIT:
            return GetColumnValuesResponse(
                values=list(sorted(unique_values, key=str)),
                too_many_values=False,
            )
        else:
            return GetColumnValuesResponse(
                values=[],
                too_many_values=True,
            )

    def _convert_value(self, value: Dict[str, Any]) -> DataFrameType:
        if value is None:
            self._error = None
            return self._data

        try:
            transformations = parse_raw(value, Transformations)
            result = self._transform_container.apply(transformations)
            self._error = None
            self._last_transforms = transformations
            return result
        except Exception as e:
            error = "Error applying dataframe transform: %s\n\n" % str(e)
            sys.stderr.write(error)
            self._error = error
            return self._data

    def search(self, args: SearchTableArgs) -> SearchTableResponse:
        offset = args.page_number * args.page_size

        # Apply filters, query, and functools.sort using the cached method
        result = self._apply_filters_query_sort(
            args.query,
            args.sort,
        )

        # Save the manager to be used for selection
        data = result.take(args.page_size, offset).to_data()
        return SearchTableResponse(
            data=data,
            total_rows=result.get_num_rows(force=True) or 0,
        )

    def _apply_filters_query_sort(
        self,
        query: Optional[str],
        sort: Optional[SortArgs],
    ) -> TableManager[Any]:
        result = self._get_cached_table_manager(self._value, self._limit)

        if query:
            result = result.search(query)

        if sort:
            result = result.sort_values(sort.by, sort.descending)

        return result

    @memoize_last_value
    def _get_cached_table_manager(
        self, value: Any, limit: Optional[int]
    ) -> TableManager[Any]:
        tm = get_table_manager(value)
        if limit is not None:
            tm = tm.take(limit, 0)
        return tm

#+END_SRC
**** transforms
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.dataframes.transforms
:END:
***** apply
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.dataframes.transforms.apply
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/dataframes/transforms/apply.py
:END:
****** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Generic, List, TypeVar

from marimo._dependencies.dependencies import DependencyManager
from marimo._plugins.ui._impl.dataframes.transforms.handlers import (
    IbisTransformHandler,
    PandasTransformHandler,
    PolarsTransformHandler,
)
from marimo._plugins.ui._impl.dataframes.transforms.types import (
    Transform,
    Transformations,
    TransformHandler,
    TransformType,
)
from marimo._utils.assert_never import assert_never

#+END_SRC
****** Assignment T = TypeVar("T")
#+BEGIN_SRC python
T = TypeVar("T")

#+END_SRC
****** Function _handle
#+BEGIN_SRC python
def _handle(df: T, handler: TransformHandler[T], transform: Transform) -> T:
    if transform.type is TransformType.COLUMN_CONVERSION:
        return handler.handle_column_conversion(df, transform)
    elif transform.type is TransformType.RENAME_COLUMN:
        return handler.handle_rename_column(df, transform)
    elif transform.type is TransformType.SORT_COLUMN:
        return handler.handle_sort_column(df, transform)
    elif transform.type is TransformType.FILTER_ROWS:
        return handler.handle_filter_rows(df, transform)
    elif transform.type is TransformType.GROUP_BY:
        return handler.handle_group_by(df, transform)
    elif transform.type is TransformType.AGGREGATE:
        return handler.handle_aggregate(df, transform)
    elif transform.type is TransformType.SELECT_COLUMNS:
        return handler.handle_select_columns(df, transform)
    elif transform.type is TransformType.SHUFFLE_ROWS:
        return handler.handle_shuffle_rows(df, transform)
    elif transform.type is TransformType.SAMPLE_ROWS:
        return handler.handle_sample_rows(df, transform)
    elif transform.type is TransformType.EXPLODE_COLUMNS:
        return handler.handle_explode_columns(df, transform)
    elif transform.type is TransformType.EXPAND_DICT:
        return handler.handle_expand_dict(df, transform)
    else:
        assert_never(transform.type)

#+END_SRC
****** Function _apply_transforms
#+BEGIN_SRC python
def _apply_transforms(
    df: T, handler: TransformHandler[T], transforms: Transformations
) -> T:
    if not transforms.transforms:
        return df
    for transform in transforms.transforms:
        df = _handle(df, handler, transform)
    return df

#+END_SRC
****** Function get_handler_for_dataframe
#+BEGIN_SRC python
def get_handler_for_dataframe(
    df: Any,
) -> TransformHandler[Any]:
    """
    Gets the handler for the given dataframe.

    raises ValueError if the dataframe type is not supported.
    """
    if DependencyManager.pandas.imported():
        import pandas as pd

        if isinstance(df, pd.DataFrame):
            return PandasTransformHandler()
    if DependencyManager.polars.imported():
        import polars as pl

        if isinstance(df, pl.DataFrame):
            return PolarsTransformHandler()

    if DependencyManager.ibis.imported():
        import ibis  # type: ignore

        if isinstance(df, ibis.Table):
            return IbisTransformHandler()

    if DependencyManager.narwhals.imported():
        import narwhals as nw

        if isinstance(df, nw.DataFrame):
            return get_handler_for_dataframe(df.to_native())

    raise ValueError(
        "Unsupported dataframe type. Must be Pandas or Polars."
        f" Got: {type(df)}"
    )

#+END_SRC
****** Class TransformsContainer
#+BEGIN_SRC python
class TransformsContainer(Generic[T]):
    """
    Keeps internal state of the last transformation applied to the dataframe.
    So that we can incrementally apply transformations.
    """

    def __init__(self, df: T, handler: TransformHandler[T]) -> None:
        self._original_df = df
        # The dataframe for the given transform.
        self._snapshot_df = df
        self._handler = handler
        self._transforms: List[Transform] = []

    def apply(self, transform: Transformations) -> T:
        """
        Applies the given transformations to the dataframe.
        """
        # If the new transformations are a superset of the existing ones,
        # then we can just apply the new ones to the snapshot dataframe.
        if self._is_superset(transform):
            transforms_to_apply = self._get_next_transformations(transform)
            self._snapshot_df = _apply_transforms(
                self._snapshot_df, self._handler, transforms_to_apply
            )
            self._transforms = transform.transforms
            return self._snapshot_df

        # If the new transformations are not a superset of the existing ones,
        # then we need to start from the original dataframe.
        else:
            self._snapshot_df = _apply_transforms(
                self._original_df, self._handler, transform
            )
            self._transforms = transform.transforms
            return self._snapshot_df

    def _is_superset(self, transforms: Transformations) -> bool:
        """
        Checks if the new transformations are a superset of the existing ones.
        """
        if not self._transforms:
            return False

        # If the new transformations are smaller than the existing ones,
        # then it's not a superset.
        if len(self._transforms) > len(transforms.transforms):
            return False

        for i, transform in enumerate(self._transforms):
            if transform != transforms.transforms[i]:
                return False

        return True

    def _get_next_transformations(
        self, transforms: Transformations
    ) -> Transformations:
        """
        Gets the next transformations to apply.
        """
        if self._is_superset(transforms):
            return Transformations(
                transforms.transforms[len(self._transforms) :]
            )
        else:
            return transforms

#+END_SRC
***** handlers
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.dataframes.transforms.handlers
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/dataframes/transforms/handlers.py
:END:
****** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import datetime
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Sequence, cast

from marimo._plugins.ui._impl.dataframes.transforms.print_code import (
    python_print_pandas,
    python_print_polars,
    python_print_transforms,
)
from marimo._plugins.ui._impl.dataframes.transforms.types import (
    AggregateTransform,
    ColumnConversionTransform,
    ExpandDictTransform,
    ExplodeColumnsTransform,
    FilterRowsTransform,
    GroupByTransform,
    RenameColumnTransform,
    SampleRowsTransform,
    SelectColumnsTransform,
    ShuffleRowsTransform,
    SortColumnTransform,
    Transform,
    TransformHandler,
)
from marimo._utils.assert_never import assert_never

#+END_SRC
****** Class PandasTransformHandler
#+BEGIN_SRC python
if TYPE_CHECKING:
    import ibis  # type: ignore
    import ibis.expr.types as ir  # type: ignore
    import pandas as pd
    import polars as pl


class PandasTransformHandler(TransformHandler["pd.DataFrame"]):
    @staticmethod
    def handle_column_conversion(
        df: "pd.DataFrame", transform: ColumnConversionTransform
    ) -> "pd.DataFrame":
        df[transform.column_id] = df[transform.column_id].astype(
            transform.data_type,
            errors=transform.errors,
        )  # type: ignore[call-overload]
        return df

    @staticmethod
    def handle_rename_column(
        df: "pd.DataFrame", transform: RenameColumnTransform
    ) -> "pd.DataFrame":
        return df.rename(
            columns={transform.column_id: transform.new_column_id}
        )

    @staticmethod
    def handle_sort_column(
        df: "pd.DataFrame", transform: SortColumnTransform
    ) -> "pd.DataFrame":
        return df.sort_values(
            by=cast(str, transform.column_id),
            ascending=transform.ascending,
            na_position=transform.na_position,
        )

    @staticmethod
    def handle_filter_rows(
        df: "pd.DataFrame", transform: FilterRowsTransform
    ) -> "pd.DataFrame":
        if not transform.where:
            return df

        import pandas as pd

        clauses: List[pd.Series[Any]] = []
        for condition in transform.where:
            try:
                value = _coerce_value(
                    df[condition.column_id].dtype, condition.value
                )
            except Exception:
                value = condition.value or ""
            if condition.operator == "==":
                df_filter = df[condition.column_id] == value
            elif condition.operator == "!=":
                df_filter = df[condition.column_id] != value
            elif condition.operator == ">":
                df_filter = df[condition.column_id] > value
            elif condition.operator == "<":
                df_filter = df[condition.column_id] < value
            elif condition.operator == ">=":
                df_filter = df[condition.column_id] >= value
            elif condition.operator == "<=":
                df_filter = df[condition.column_id] <= value
            elif condition.operator == "is_true":
                df_filter = df[condition.column_id].eq(True)
            elif condition.operator == "is_false":
                df_filter = df[condition.column_id].eq(False)
            elif condition.operator == "is_nan":
                df_filter = df[condition.column_id].isna()
            elif condition.operator == "is_not_nan":
                df_filter = df[condition.column_id].notna()
            elif condition.operator == "equals":
                df_filter = df[condition.column_id].eq(value)
            elif condition.operator == "does_not_equal":
                df_filter = df[condition.column_id].ne(value)
            elif condition.operator == "contains":
                df_filter = df[condition.column_id].str.contains(
                    value, regex=False, na=False
                )
            elif condition.operator == "regex":
                df_filter = df[condition.column_id].str.contains(
                    value, regex=True, na=False
                )
            elif condition.operator == "starts_with":
                df_filter = df[condition.column_id].str.startswith(
                    value, na=False
                )
            elif condition.operator == "ends_with":
                df_filter = df[condition.column_id].str.endswith(
                    value, na=False
                )
            elif condition.operator == "in":
                df_filter = df[condition.column_id].isin(value)
            else:
                assert_never(condition.operator)

            clauses.append(df_filter)

        if transform.operation == "keep_rows":
            df = df[pd.concat(clauses, axis=1).all(axis=1)]
        elif transform.operation == "remove_rows":
            df = df[~pd.concat(clauses, axis=1).all(axis=1)]
        else:
            assert_never(transform.operation)

        return df

    @staticmethod
    def handle_group_by(
        df: "pd.DataFrame", transform: GroupByTransform
    ) -> "pd.DataFrame":
        group = df.groupby(transform.column_ids, dropna=transform.drop_na)
        if transform.aggregation == "count":
            return group.count()
        elif transform.aggregation == "sum":
            return group.sum()
        elif transform.aggregation == "mean":
            return group.mean(numeric_only=True)
        elif transform.aggregation == "median":
            return group.median(numeric_only=True)
        elif transform.aggregation == "min":
            return group.min()
        elif transform.aggregation == "max":
            return group.max()
        else:
            assert_never(transform.aggregation)

    @staticmethod
    def handle_aggregate(
        df: "pd.DataFrame", transform: AggregateTransform
    ) -> "pd.DataFrame":
        dict_of_aggs = {
            column_id: transform.aggregations
            for column_id in transform.column_ids
        }

        # Pandas type-checking doesn't like the fact that the values
        # are lists of strings (function names), even though the docs permit
        # such a value
        return cast("pd.DataFrame", df.agg(dict_of_aggs))  # type: ignore  # noqa: E501

    @staticmethod
    def handle_select_columns(
        df: "pd.DataFrame", transform: SelectColumnsTransform
    ) -> "pd.DataFrame":
        return df[transform.column_ids]

    @staticmethod
    def handle_shuffle_rows(
        df: "pd.DataFrame", transform: ShuffleRowsTransform
    ) -> "pd.DataFrame":
        return df.sample(frac=1, random_state=transform.seed)

    @staticmethod
    def handle_sample_rows(
        df: "pd.DataFrame", transform: SampleRowsTransform
    ) -> "pd.DataFrame":
        return df.sample(
            n=transform.n,
            random_state=transform.seed,
            replace=transform.replace,
        )

    @staticmethod
    def handle_explode_columns(
        df: "pd.DataFrame", transform: ExplodeColumnsTransform
    ) -> "pd.DataFrame":
        return df.explode(transform.column_ids)

    @staticmethod
    def handle_expand_dict(
        df: "pd.DataFrame", transform: ExpandDictTransform
    ) -> "pd.DataFrame":
        import pandas as pd

        column_id = transform.column_id
        return df.join(
            pd.DataFrame(df.pop(cast(str, column_id)).values.tolist())
        )

    @staticmethod
    def as_python_code(
        df_name: str, columns: List[str], transforms: List[Transform]
    ) -> str:
        return python_print_transforms(
            df_name, columns, transforms, python_print_pandas
        )

#+END_SRC
****** Class PolarsTransformHandler
#+BEGIN_SRC python
class PolarsTransformHandler(TransformHandler["pl.DataFrame"]):
    @staticmethod
    def handle_column_conversion(
        df: "pl.DataFrame", transform: ColumnConversionTransform
    ) -> "pl.DataFrame":
        import polars.datatypes as pl_datatypes

        return df.cast(
            {
                str(
                    transform.column_id
                ): pl_datatypes.numpy_char_code_to_dtype(transform.data_type)
            },
            strict=transform.errors == "raise",
        )

    @staticmethod
    def handle_rename_column(
        df: "pl.DataFrame", transform: RenameColumnTransform
    ) -> "pl.DataFrame":
        return df.rename(
            {str(transform.column_id): str(transform.new_column_id)}
        )

    @staticmethod
    def handle_sort_column(
        df: "pl.DataFrame", transform: SortColumnTransform
    ) -> "pl.DataFrame":
        return df.sort(
            by=transform.column_id,
            descending=not transform.ascending,
            nulls_last=transform.na_position == "last",
        )

    @staticmethod
    def handle_filter_rows(
        df: "pl.DataFrame", transform: FilterRowsTransform
    ) -> "pl.DataFrame":
        import polars as pl
        from polars import col

        # Start with no filter (all rows included)
        filter_expr: Optional[pl.Expr] = None

        # Iterate over all conditions and build the filter expression
        for condition in transform.where:
            column = col(str(condition.column_id))
            dtype = df.schema[str(condition.column_id)]
            value = condition.value

            # If columns type is a Datetime, we need to convert the value to a datetime
            if dtype == pl.Datetime and isinstance(value, str):
                value = datetime.datetime.fromisoformat(value)
            elif dtype == pl.Date and isinstance(value, str):
                value = datetime.date.fromisoformat(value)
            elif dtype == pl.Time and isinstance(value, str):
                value = datetime.time.fromisoformat(value)

            # Build the expression based on the operator
            if condition.operator == "==":
                condition_expr = column == value
            elif condition.operator == "!=":
                condition_expr = column != value
            elif condition.operator == ">":
                condition_expr = column > value
            elif condition.operator == "<":
                condition_expr = column < value
            elif condition.operator == ">=":
                condition_expr = column >= value
            elif condition.operator == "<=":
                condition_expr = column <= value
            elif condition.operator == "is_true":
                condition_expr = column.eq(True)
            elif condition.operator == "is_false":
                condition_expr = column.eq(False)
            elif condition.operator == "is_nan":
                condition_expr = column.is_null()
            elif condition.operator == "is_not_nan":
                condition_expr = column.is_not_null()
            elif condition.operator == "equals":
                condition_expr = column == value
            elif condition.operator == "does_not_equal":
                condition_expr = column != value
            elif condition.operator == "contains":
                condition_expr = column.str.contains(value or "", literal=True)
            elif condition.operator == "regex":
                condition_expr = column.str.contains(
                    value or "", literal=False
                )
            elif condition.operator == "starts_with":
                condition_expr = column.str.starts_with(value or "")
            elif condition.operator == "ends_with":
                condition_expr = column.str.ends_with(value or "")
            elif condition.operator == "in":
                condition_expr = column.is_in(value or [])
            else:
                assert_never(condition.operator)

            # Combine the condition expression with the filter expression
            if filter_expr is None:
                filter_expr = condition_expr
            else:
                filter_expr = filter_expr & condition_expr

        if filter_expr is None:
            return df

        # Handle the operation (keep_rows or remove_rows)
        if transform.operation == "keep_rows":
            return df.filter(filter_expr)
        elif transform.operation == "remove_rows":
            return df.filter(~filter_expr)
        else:
            assert_never(transform.operation)

    @staticmethod
    def handle_group_by(
        df: "pl.DataFrame", transform: GroupByTransform
    ) -> "pl.DataFrame":
        aggs: list[pl.Expr] = []
        from polars import col

        group_by_column_id_set = set(transform.column_ids)
        agg_columns = [
            column_id
            for column_id in df.columns
            if column_id not in group_by_column_id_set
        ]
        for column_id in agg_columns:
            agg_func = transform.aggregation
            if agg_func == "count":
                aggs.append(col(column_id).count().alias(f"{column_id}_count"))
            elif agg_func == "sum":
                aggs.append(col(column_id).sum().alias(f"{column_id}_sum"))
            elif agg_func == "mean":
                aggs.append(col(column_id).mean().alias(f"{column_id}_mean"))
            elif agg_func == "median":
                aggs.append(
                    col(column_id).median().alias(f"{column_id}_median")
                )
            elif agg_func == "min":
                aggs.append(col(column_id).min().alias(f"{column_id}_min"))
            elif agg_func == "max":
                aggs.append(col(column_id).max().alias(f"{column_id}_max"))
            else:
                assert_never(agg_func)

        return df.group_by(transform.column_ids, maintain_order=True).agg(aggs)

    @staticmethod
    def handle_aggregate(
        df: "pl.DataFrame", transform: AggregateTransform
    ) -> "pl.DataFrame":
        import polars as pl

        selected_df = df.select(transform.column_ids)
        result_df = pl.DataFrame()
        for agg_func in transform.aggregations:
            if agg_func == "count":
                agg_df = selected_df.count()
            elif agg_func == "sum":
                agg_df = selected_df.sum()
            elif agg_func == "mean":
                agg_df = selected_df.mean()
            elif agg_func == "median":
                agg_df = selected_df.median()
            elif agg_func == "min":
                agg_df = selected_df.min()
            elif agg_func == "max":
                agg_df = selected_df.max()
            else:
                assert_never(agg_func)

            # Rename all
            agg_df = agg_df.rename(
                {column: f"{column}_{agg_func}" for column in agg_df.columns}
            )
            # Add to result
            result_df = result_df.hstack(agg_df)

        return result_df

    @staticmethod
    def handle_select_columns(
        df: "pl.DataFrame", transform: SelectColumnsTransform
    ) -> "pl.DataFrame":
        return df.select(transform.column_ids)

    @staticmethod
    def handle_shuffle_rows(
        df: "pl.DataFrame", transform: ShuffleRowsTransform
    ) -> "pl.DataFrame":
        return df.sample(fraction=1, shuffle=True, seed=transform.seed)

    @staticmethod
    def handle_sample_rows(
        df: "pl.DataFrame", transform: SampleRowsTransform
    ) -> "pl.DataFrame":
        return df.sample(
            n=transform.n,
            shuffle=True,
            seed=transform.seed,
            with_replacement=transform.replace,
        )

    @staticmethod
    def handle_explode_columns(
        df: "pl.DataFrame", transform: ExplodeColumnsTransform
    ) -> "pl.DataFrame":
        return df.explode(cast(Sequence[str], transform.column_ids))

    @staticmethod
    def handle_expand_dict(
        df: "pl.DataFrame", transform: ExpandDictTransform
    ) -> "pl.DataFrame":
        import polars as pl

        column_id = transform.column_id
        column = df.select(column_id).to_series()
        df = df.drop(cast(str, column_id))
        return df.hstack(pl.DataFrame(column.to_list()))

    @staticmethod
    def as_python_code(
        df_name: str, columns: List[str], transforms: List[Transform]
    ) -> str:
        return python_print_transforms(
            df_name, columns, transforms, python_print_polars
        )

#+END_SRC
****** Class IbisTransformHandler
#+BEGIN_SRC python
class IbisTransformHandler(TransformHandler["ibis.Table"]):
    @staticmethod
    def handle_column_conversion(
        df: "ibis.Table", transform: ColumnConversionTransform
    ) -> "ibis.Table":
        import ibis

        if transform.errors == "ignore":
            try:
                # Use coalesce to handle conversion errors
                return df.mutate(
                    ibis.coalesce(
                        df[transform.column_id].cast(
                            ibis.dtype(transform.data_type)
                        ),
                        df[transform.column_id],
                    ).name(transform.column_id)
                )
            except ibis.common.exceptions.IbisTypeError:
                return df
        else:
            # Default behavior (raise errors)
            return df.mutate(
                df[transform.column_id]
                .cast(ibis.dtype(transform.data_type))
                .name(transform.column_id)
            )

    @staticmethod
    def handle_rename_column(
        df: "ibis.Table", transform: RenameColumnTransform
    ) -> "ibis.Table":
        return df.rename({transform.new_column_id: transform.column_id})

    @staticmethod
    def handle_sort_column(
        df: "ibis.Table", transform: SortColumnTransform
    ) -> "ibis.Table":
        return df.order_by(
            [
                df[transform.column_id].asc()
                if transform.ascending
                else df[transform.column_id].desc()
            ]
        )

    @staticmethod
    def handle_filter_rows(
        df: "ibis.Table", transform: FilterRowsTransform
    ) -> "ibis.Table":
        import ibis

        filter_conditions: list[ir.BooleanValue] = []
        for condition in transform.where:
            column = df[str(condition.column_id)]
            value = condition.value
            if condition.operator == "==":
                filter_conditions.append(column == value)
            elif condition.operator == "!=":
                filter_conditions.append(column != value)
            elif condition.operator == ">":
                filter_conditions.append(column > value)
            elif condition.operator == "<":
                filter_conditions.append(column < value)
            elif condition.operator == ">=":
                filter_conditions.append(column >= value)
            elif condition.operator == "<=":
                filter_conditions.append(column <= value)
            elif condition.operator == "is_true":
                filter_conditions.append(column)
            elif condition.operator == "is_false":
                filter_conditions.append(~column)
            elif condition.operator == "is_nan":
                filter_conditions.append(column.isnull())
            elif condition.operator == "is_not_nan":
                filter_conditions.append(column.notnull())
            elif condition.operator == "equals":
                filter_conditions.append(column == value)
            elif condition.operator == "does_not_equal":
                filter_conditions.append(column != value)
            elif condition.operator == "contains":
                filter_conditions.append(column.contains(value))
            elif condition.operator == "regex":
                filter_conditions.append(column.re_search(value))
            elif condition.operator == "starts_with":
                filter_conditions.append(column.startswith(value))
            elif condition.operator == "ends_with":
                filter_conditions.append(column.endswith(value))
            elif condition.operator == "in":
                filter_conditions.append(column.isin(value))
            else:
                assert_never(condition.operator)

        combined_condition = ibis.and_(*filter_conditions)

        if transform.operation == "keep_rows":
            return df.filter(combined_condition)
        elif transform.operation == "remove_rows":
            return df.filter(~combined_condition)
        else:
            raise ValueError(f"Unsupported operation: {transform.operation}")

    @staticmethod
    def handle_group_by(
        df: "ibis.Table", transform: GroupByTransform
    ) -> "ibis.Table":
        aggs: list[ir.Expr] = []

        group_by_column_id_set = set(transform.column_ids)
        agg_columns = [
            column_id
            for column_id in df.columns
            if column_id not in group_by_column_id_set
        ]
        for column_id in agg_columns:
            agg_func = transform.aggregation
            if agg_func == "count":
                aggs.append(df[column_id].count().name(f"{column_id}_count"))
            elif agg_func == "sum":
                aggs.append(df[column_id].sum().name(f"{column_id}_sum"))
            elif agg_func == "mean":
                aggs.append(df[column_id].mean().name(f"{column_id}_mean"))
            elif agg_func == "median":
                aggs.append(df[column_id].median().name(f"{column_id}_median"))
            elif agg_func == "min":
                aggs.append(df[column_id].min().name(f"{column_id}_min"))
            elif agg_func == "max":
                aggs.append(df[column_id].max().name(f"{column_id}_max"))
            else:
                assert_never(agg_func)

        return df.group_by(transform.column_ids).aggregate(aggs)

    @staticmethod
    def handle_aggregate(
        df: "ibis.Table", transform: AggregateTransform
    ) -> "ibis.Table":
        agg_dict: Dict[str, Any] = {}
        for agg_func in transform.aggregations:
            for column_id in transform.column_ids:
                name = f"{column_id}_{agg_func}"
                agg_dict[name] = getattr(df[column_id], agg_func)()
        return df.aggregate(**agg_dict)

    @staticmethod
    def handle_select_columns(
        df: "ibis.Table", transform: SelectColumnsTransform
    ) -> "ibis.Table":
        return df.select(transform.column_ids)

    @staticmethod
    def handle_shuffle_rows(
        df: "ibis.Table", transform: ShuffleRowsTransform
    ) -> "ibis.Table":
        del transform
        import ibis

        return df.order_by(ibis.random())

    @staticmethod
    def handle_sample_rows(
        df: "ibis.Table", transform: SampleRowsTransform
    ) -> "ibis.Table":
        return df.sample(
            transform.n / df.count().execute(),
            method="row",
            seed=transform.seed,
        )

    @staticmethod
    def handle_explode_columns(
        df: "ibis.Table", transform: ExplodeColumnsTransform
    ) -> "ibis.Table":
        for column_id in transform.column_ids:
            df = df.unnest(column_id)
        return df

    @staticmethod
    def handle_expand_dict(
        df: "ibis.Table", transform: ExpandDictTransform
    ) -> "ibis.Table":
        return df.unpack(transform.column_id)

    # TODO: support as_python_code for Ibis
    # @staticmethod
    # def as_python_code(
    #     df_name: str, columns: List[str], transforms: List[Transform]
    # ) -> str | None:
    #     return python_print_transforms(
    #         df_name, columns, transforms, python_print_ibis
    #     )

    @staticmethod
    def as_sql_code(transformed_df: "ibis.Table") -> str | None:
        import ibis

        try:
            return str(ibis.to_sql(transformed_df))
        except Exception:
            # In case it is not a SQL backend
            return None

#+END_SRC
****** Function _coerce_value
#+BEGIN_SRC python
def _coerce_value(dtype: Any, value: Any) -> Any:
    import numpy as np

    return np.array([value]).astype(dtype)[0]

#+END_SRC
***** print_code
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.dataframes.transforms.print_code
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/dataframes/transforms/print_code.py
:END:
****** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Callable, List, Union

from marimo._plugins.ui._impl.dataframes.transforms.types import (
    Condition,
    Transform,
    TransformType,
)
from marimo._utils.assert_never import assert_never

#+END_SRC
****** Function python_print_transforms
#+BEGIN_SRC python
def python_print_transforms(
    df_name: str,
    all_columns: List[str],
    transforms: List[Transform],
    print_transform: Callable[[str, List[str], Transform], str],
) -> str:
    df_next_name = f"{df_name}_next"
    strs: List[str] = []
    for transform in transforms:
        strs.append(
            f"{df_next_name} = {print_transform(df_next_name,all_columns, transform)}"  # noqa: E501
        )
    return "\n".join([f"{df_next_name} = {df_name}"] + strs)

#+END_SRC
****** Function python_print_pandas
#+BEGIN_SRC python
def python_print_pandas(
    df_name: str, all_columns: List[str], transform: Transform
) -> str:
    del all_columns

    def generate_where_clause(df_name: str, where: Condition) -> str:
        column_id, operator, value = (
            where.column_id,
            where.operator,
            where.value,
        )

        if operator == "==":
            return (
                f"{df_name}[{_as_literal(column_id)}] == {_as_literal(value)}"
            )
        elif operator == "equals":
            return (
                f"{df_name}[{_as_literal(column_id)}].eq({_as_literal(value)})"
            )
        elif operator == "does_not_equal":
            return (
                f"{df_name}[{_as_literal(column_id)}].ne({_as_literal(value)})"
            )
        elif operator == "contains":
            return f"{df_name}[{_as_literal(column_id)}].str.contains({_as_literal(value)})"  # noqa: E501
        elif operator == "regex":
            return f"{df_name}[{_as_literal(column_id)}].str.contains({_as_literal(value)}, regex=True)"  # noqa: E501
        elif operator == "starts_with":
            return f"{df_name}[{_as_literal(column_id)}].str.startswith({_as_literal(value)})"  # noqa: E501
        elif operator == "ends_with":
            return f"{df_name}[{_as_literal(column_id)}].str.endswith({_as_literal(value)})"  # noqa: E501
        elif operator == "in":
            return f"{df_name}[{_as_literal(column_id)}].isin({_list_of_strings(value)})"  # noqa: E501
        elif operator == "!=":
            return (
                f"{df_name}[{_as_literal(column_id)}].ne({_as_literal(value)})"
            )
        elif operator in [">", ">=", "<", "<="]:
            return f"{df_name}[{_as_literal(column_id)}] {operator} {_as_literal(value)}"  # noqa: E501
        elif operator == "is_nan":
            return f"{df_name}[{_as_literal(column_id)}].isna()"
        elif operator == "is_not_nan":
            return f"{df_name}[{_as_literal(column_id)}].notna()"
        elif operator == "is_true":
            return f"{df_name}[{_as_literal(column_id)}].eq(True)"
        elif operator == "is_false":
            return f"{df_name}[{_as_literal(column_id)}].eq(False)"
        else:
            raise ValueError(f"Unknown operator: {operator}")

    if transform.type == TransformType.COLUMN_CONVERSION:
        column_id, data_type, errors = (
            transform.column_id,
            transform.data_type,
            transform.errors,
        )
        return f'{df_name}\n{df_name}[{_as_literal(column_id)}] = {df_name}[{_as_literal(column_id)}].astype("{data_type}", errors="{errors}")'  # noqa: E501

    elif transform.type == TransformType.RENAME_COLUMN:
        column_id, new_column_id = (
            transform.column_id,
            transform.new_column_id,
        )
        return f"{df_name}.rename(columns={{{_as_literal(column_id)}: {_as_literal(new_column_id)}}})"  # noqa: E501

    elif transform.type == TransformType.SORT_COLUMN:
        column_id, ascending, na_position = (
            transform.column_id,
            transform.ascending,
            transform.na_position,
        )
        args = _args_list(
            f"by={_as_literal(column_id)}",
            f"ascending={ascending}",
            f"na_position={_as_literal(na_position)}",
        )
        return f"{df_name}.sort_values({args})"

    elif transform.type == TransformType.FILTER_ROWS:
        operation, where = transform.operation, transform.where
        if not where:
            return df_name
        where_clauses = [
            generate_where_clause(df_name, condition) for condition in where
        ]
        if operation == "keep_rows" and len(where_clauses) == 1:
            return f"{df_name}[{where_clauses[0]}]"
        expression = " & ".join(f"({clause})" for clause in where_clauses)
        return (
            f"{df_name}[{expression}]"
            if operation == "keep_rows"
            else f"{df_name}[~({expression})]"
        )

    elif transform.type == TransformType.AGGREGATE:
        column_ids, aggregations = (
            transform.column_ids,
            transform.aggregations,
        )
        if not column_ids:
            return f"{df_name}.agg({_list_of_strings(aggregations)})"
        return f'{df_name}.agg({{{", ".join(f"{_as_literal(column_id)}: {_list_of_strings(aggregations)}" for column_id in column_ids)}}})'  # noqa: E501

    elif transform.type == TransformType.GROUP_BY:
        column_ids, aggregation, drop_na = (
            transform.column_ids,
            transform.aggregation,
            transform.drop_na,
        )
        args = _args_list(_list_of_strings(column_ids), f"dropna={drop_na}")
        group_by = f"{df_name}.groupby({args})"
        if aggregation == "count":
            return f"{group_by}.count()"
        elif aggregation == "sum":
            return f"{group_by}.sum()"
        elif aggregation == "mean":
            return f"{group_by}.mean(numeric_only=True)"
        elif aggregation == "median":
            return f"{group_by}.median(numeric_only=True)"
        elif aggregation == "min":
            return f"{group_by}.min()"
        elif aggregation == "max":
            return f"{group_by}.max()"
        assert_never(aggregation)

    elif transform.type == TransformType.SELECT_COLUMNS:
        column_ids = transform.column_ids
        if not column_ids:
            return df_name
        return (
            f"{df_name}[{_as_literal(column_ids[0])}]"
            if len(column_ids) == 1
            else f"{df_name}[{_list_of_strings(column_ids)}]"
        )

    elif transform.type == TransformType.SAMPLE_ROWS:
        n = transform.n
        return f"{df_name}.sample(n={n})"

    elif transform.type == TransformType.SHUFFLE_ROWS:
        return f"{df_name}.sample(frac=1)"

    elif transform.type == TransformType.EXPLODE_COLUMNS:
        column_ids = transform.column_ids
        return f"{df_name}.explode({_list_of_strings(column_ids)})"

    elif transform.type == TransformType.EXPAND_DICT:
        column_id = _as_literal(transform.column_id)
        args = f"{df_name}.pop({column_id}).values.tolist()"
        return f"{df_name}.join(pd.DataFrame({args}))"

    assert_never(transform.type)

#+END_SRC
****** Function python_print_polars
#+BEGIN_SRC python
def python_print_polars(
    df_name: str, all_columns: List[str], transform: Transform
) -> str:
    def generate_where_clause_polars(where: Condition) -> str:
        column_id, operator, value = (
            where.column_id,
            where.operator,
            where.value,
        )

        if operator == "==" or operator == "equals":
            return f"pl.col({_as_literal(column_id)}) == {_as_literal(value)}"
        elif operator == "does_not_equal" or operator == "!=":
            return f"pl.col({_as_literal(column_id)}) != {_as_literal(value)}"
        elif operator == "contains":
            return f"pl.col({_as_literal(column_id)}).str.contains({_as_literal(value)})"  # noqa: E501
        elif operator == "regex":
            return f"pl.col({_as_literal(column_id)}).str.contains({_as_literal(value)}, literal=False)"  # noqa: E501
        elif operator == "starts_with":
            return f"pl.col({_as_literal(column_id)}).str.starts_with({_as_literal(value)})"  # noqa: E501
        elif operator == "ends_with":
            return f"pl.col({_as_literal(column_id)}).str.ends_with({_as_literal(value)})"  # noqa: E501
        elif operator == "in":
            return f"pl.col({_as_literal(column_id)}).is_in({_list_of_strings(value)})"  # noqa: E501
        elif operator in [">", ">=", "<", "<="]:
            return f"pl.col({_as_literal(column_id)}) {operator} {_as_literal(value)}"  # noqa: E501
        elif operator == "is_nan":
            return f"pl.col({_as_literal(column_id)}).is_null()"
        elif operator == "is_not_nan":
            return f"pl.col({_as_literal(column_id)}).is_not_null()"
        elif operator == "is_true":
            return f"pl.col({_as_literal(column_id)}) == True"
        elif operator == "is_false":
            return f"pl.col({_as_literal(column_id)}) == False"
        else:
            raise ValueError(f"Unknown operator: {operator}")

    if transform.type == TransformType.COLUMN_CONVERSION:
        column_id, data_type = transform.column_id, transform.data_type
        try:
            import polars.datatypes as pl_datatypes

            data_type = str(pl_datatypes.numpy_char_code_to_dtype(data_type))
        except Exception:
            pass
        return f"{df_name}.cast({{{_as_literal(column_id)}: pl.{data_type}}}, strict={transform.errors == 'raise'})"  # noqa: E501

    elif transform.type == TransformType.RENAME_COLUMN:
        column_id, new_column_id = (
            transform.column_id,
            transform.new_column_id,
        )
        return f"{df_name}.rename({{{_as_literal(column_id)}: {_as_literal(new_column_id)}}})"  # noqa: E501

    elif transform.type == TransformType.SORT_COLUMN:
        column_id, ascending, na_position = (
            transform.column_id,
            transform.ascending,
            transform.na_position,
        )
        return f"{df_name}.sort({_as_literal(column_id)}, descending={not ascending}, nulls_last={na_position == 'last'})"  # noqa: E501

    elif transform.type == TransformType.FILTER_ROWS:
        operation, where = transform.operation, transform.where
        if not where:
            return df_name
        where_clauses = [
            generate_where_clause_polars(condition) for condition in where
        ]
        if operation == "keep_rows" and len(where_clauses) == 1:
            return f"{df_name}.filter({where_clauses[0]})"
        expression = " & ".join(f"({clause})" for clause in where_clauses)
        return (
            f"{df_name}.filter({expression})"
            if operation == "keep_rows"
            else f"{df_name}.filter(~({expression}))"
        )

    elif transform.type == TransformType.AGGREGATE:
        column_ids, aggregations = transform.column_ids, transform.aggregations
        selected_df = f"{df_name}.select({_list_of_strings(column_ids)})"
        result_df = "pl.DataFrame()"
        for agg_func in aggregations:
            agg_df = f"{selected_df}.{agg_func}()"
            rename_dict = {
                f"{column}: f'{column}_{agg_func}'" for column in all_columns
            }
            agg_df = f"{agg_df}.rename({rename_dict})"
            result_df = f"{result_df}.join({agg_df})"
        return result_df

    elif transform.type == TransformType.GROUP_BY:
        column_ids, aggregation = transform.column_ids, transform.aggregation
        aggs: list[str] = []
        for column_id in all_columns:
            if column_id not in column_ids:
                if aggregation == "count":
                    aggs.append(
                        f'pl.col("{column_id}").count().alias("{column_id}_count")'
                    )
                elif aggregation == "sum":
                    aggs.append(
                        f'pl.col("{column_id}").sum().alias("{column_id}_sum")'
                    )
                elif aggregation == "mean":
                    aggs.append(
                        f'pl.col("{column_id}").mean().alias("{column_id}_mean")'
                    )
                elif aggregation == "median":
                    aggs.append(
                        f'pl.col("{column_id}").median().alias("{column_id}_median")'
                    )
                elif aggregation == "min":
                    aggs.append(
                        f'pl.col("{column_id}").min().alias("{column_id}_min")'
                    )
                elif aggregation == "max":
                    aggs.append(
                        f'pl.col("{column_id}").max().alias("{column_id}_max")'
                    )
        return f"{df_name}.group_by({_list_of_strings(column_ids)}, maintain_order=True).agg([{', '.join(aggs)}])"  # noqa: E501

    elif transform.type == TransformType.SELECT_COLUMNS:
        column_ids = transform.column_ids
        return f"{df_name}.select({_list_of_strings(column_ids)})"

    elif transform.type == TransformType.SAMPLE_ROWS:
        n = transform.n
        return f"{df_name}.sample_n(n={n})"

    elif transform.type == TransformType.SHUFFLE_ROWS:
        return f"{df_name}.sample(fraction=1.0, shuffle=True)"

    elif transform.type == TransformType.EXPLODE_COLUMNS:
        column_ids = transform.column_ids
        return f"{df_name}.explode({_list_of_strings(column_ids)})"

    elif transform.type == TransformType.EXPAND_DICT:
        column_id = _as_literal(transform.column_id)
        return f"{df_name}.hstack(pl.DataFrame({df_name}.select({column_id}).to_series().to_list())).drop({column_id})"  # noqa: E501
    assert_never(transform.type)

#+END_SRC
****** Function python_print_ibis
#+BEGIN_SRC python
def python_print_ibis(
    df_name: str, all_columns: List[str], transform: Transform
) -> str:
    del df_name, all_columns, transform
    # TODO: this does not fully work yet, but we can output the SQL for Ibis so
    # let's table this for now
    return ""

#+END_SRC
****** Function _as_literal
#+BEGIN_SRC python
#     def generate_where_clause(df_name: str, where: Condition) -> str:
#         column_id, operator, value = (
#             where.column_id,
#             where.operator,
#             where.value,
#         )

#         if operator == "==":
#             return (
#                 f"{df_name}[{_as_literal(column_id)}] == {_as_literal(value)}" # noqa: E501
#             )
#         elif operator == "equals":
#             return (
#                 f"{df_name}[{_as_literal(column_id)}].eq({_as_literal(value)})"  # noqa: E501
#             )
#         elif operator == "does_not_equal" or operator == "!=":
#             return (
#                 f"{df_name}[{_as_literal(column_id)}].ne({_as_literal(value)})"  # noqa: E501
#             )
#         elif operator == "contains":
#             return f"{df_name}[{_as_literal(column_id)}].contains({_as_literal(value)})"  # noqa: E501
#         elif operator == "regex":
#             return f"{df_name}[{_as_literal(column_id)}].re_search({_as_literal(value)})"  # noqa: E501
#         elif operator == "starts_with":
#             return f"{df_name}[{_as_literal(column_id)}].startswith({_as_literal(value)})"  # noqa: E501
#         elif operator == "ends_with":
#             return f"{df_name}[{_as_literal(column_id)}].endswith({_as_literal(value)})"  # noqa: E501
#         elif operator == "in":
#             return f"{df_name}[{_as_literal(column_id)}].isin({_list_of_strings(value)})"  # noqa: E501
#         elif operator in [">", ">=", "<", "<="]:
#             return f"{df_name}[{_as_literal(column_id)}] {operator} {_as_literal(value)}"  # noqa: E501
#         elif operator == "is_nan":
#             return f"{df_name}[{_as_literal(column_id)}].isnull()"
#         elif operator == "is_not_nan":
#             return f"{df_name}[{_as_literal(column_id)}].notnull()"
#         elif operator == "is_true":
#             return f"{df_name}[{_as_literal(column_id)}] == True"
#         elif operator == "is_false":
#             return f"{df_name}[{_as_literal(column_id)}] == False"
#         else:
#             raise ValueError(f"Unknown operator: {operator}")

#     if transform.type == TransformType.COLUMN_CONVERSION:
#         column_id, data_type, errors = (
#             transform.column_id,
#             transform.data_type,
#             transform.errors,
#         )
#         if errors == "ignore":
#             return (
#                 f"{df_name}.select('*', "
#                 f"ibis.coalesce("
#                 f"{df_name}[{_as_literal(column_id)}].cast(ibis.dtype({_as_literal(data_type)})), "  # noqa: E501
#                 f"{df_name}[{_as_literal(column_id)}]"
#                 f").name({_as_literal(column_id)}))"
#             )
#         else:
#             return (
#                 f"{df_name}.select('*', "
#                 f"{df_name}[{_as_literal(column_id)}]"
#                 f".cast(ibis.dtype({_as_literal(data_type)}))"
#                 f".name({_as_literal(column_id)}))"
#             )

#     elif transform.type == TransformType.RENAME_COLUMN:
#         column_id, new_column_id = transform.column_id, transform.new_column_id  # noqa: E501
#         return f"{df_name}.rename({{{_as_literal(new_column_id)}: {_as_literal(column_id)}}})"  # noqa: E501

#     elif transform.type == TransformType.SORT_COLUMN:
#         column_id, ascending = transform.column_id, transform.ascending
#         return f"{df_name}.order_by([{df_name}[{_as_literal(column_id)}].{'asc' if ascending else 'desc'}()])"  # noqa: E501

#     elif transform.type == TransformType.FILTER_ROWS:
#         conditions, operation = transform.where, transform.operation
#         expressions = [
#             generate_where_clause(df_name, condition)
#             for condition in conditions
#         ]
#         expression = " & ".join(expressions)
#         return (
#             f"{df_name}.filter({expression})"
#             if operation == "keep_rows"
#             else f"{df_name}.filter(~({expression}))"
#         )

#     elif transform.type == TransformType.AGGREGATE:
#         column_ids, aggregations = transform.column_ids, transform.aggregations  # noqa: E501
#         agg_dict: Dict[str, str] = {}
#         for col, aggs in zip(column_ids, aggregations):
#             for agg in aggs:
#                 agg_dict[f"{col}_{agg}"] = (
#                     f"{df_name}[{_as_literal(col)}].{agg}()"
#                 )
#         return f"{df_name}.agg({{{', '.join(f'{_as_literal(k)}: {v}' for k, v in agg_dict.items())}}})"  # noqa: E501

#     elif transform.type == TransformType.GROUP_BY:
#         column_ids, aggregation = transform.column_ids, transform.aggregation
#         return f"{df_name}.group_by({_list_of_strings(column_ids)}).{aggregation}()"  # noqa: E501

#     elif transform.type == TransformType.SELECT_COLUMNS:
#         column_ids = transform.column_ids
#         return f"{df_name}.select({_list_of_strings(column_ids)})"

#     elif transform.type == TransformType.SAMPLE_ROWS:
#         n, seed = transform.n, transform.seed
#         return f"{df_name}.sample({n} / {df_name}.count().execute(), method='row', seed={seed})"  # noqa: E501

#     elif transform.type == TransformType.SHUFFLE_ROWS:
#         return f"{df_name}.order_by(ibis.random())"

#     elif transform.type == TransformType.EXPLODE_COLUMNS:
#         column_ids = transform.column_ids
#         return f"{df_name}.unnest({_list_of_strings(column_ids)})"

#     elif transform.type == TransformType.EXPAND_DICT:
#         column_id = transform.column_id
#         return f"{df_name}.unpack({_as_literal(column_id)})"

#     assert_never(transform.type)


def _as_literal(value: Any) -> str:
    if isinstance(value, str):
        # escape backslashes
        value = value.replace("\\", "\\\\")
        # convert newlines to spaces
        value = value.replace("\n", " ")
        # convert \r to spaces
        value = value.replace("\r", " ")
        # escape double quotes
        value = value.replace('"', '\\"')
        # remove null bytes
        value = value.replace("\x00", "")
        return f'"{value}"'
    if value == "inf":
        return "float('inf')"
    if value == "-inf":
        return "float('-inf')"
    return f"{value}"

#+END_SRC
****** Function _list_of_strings
#+BEGIN_SRC python
def _list_of_strings(value: Union[List[Any], Any]) -> str:
    if isinstance(value, list):
        return f'[{", ".join(_as_literal(v) for v in value)}]'
    return _as_literal(value)

#+END_SRC
****** Function _args_list
#+BEGIN_SRC python
def _args_list(*args: str) -> str:
    return ", ".join(arg for arg in args if arg)

#+END_SRC
***** types
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.dataframes.transforms.types
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/dataframes/transforms/types.py
:END:
****** Import
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import abc
from dataclasses import dataclass
from enum import Enum
from typing import (
    Any,
    Generic,
    List,
    Literal,
    Optional,
    TypeVar,
    Union,
)

#+END_SRC
****** Assignment DataFrameType = TypeVar("DataFrameType")
#+BEGIN_SRC python
# Could be a DataFrame from pandas, polars, pyarrow, DataFrameProtocol, etc.
DataFrameType = TypeVar("DataFrameType")

#+END_SRC
****** Assignment ColumnId = Union[str, int]
#+BEGIN_SRC python
ColumnId = Union[str, int]

#+END_SRC
****** Assignment ColumnIds = List[ColumnId]
#+BEGIN_SRC python
ColumnIds = List[ColumnId]

#+END_SRC
****** Assignment NumpyDataType = str
#+BEGIN_SRC python
NumpyDataType = str

#+END_SRC
****** Assignment Operator
#+BEGIN_SRC python
Operator = Literal[
    "==",
    "!=",
    "<",
    ">",
    "<",
    "<=",
    ">=",
    "is_true",
    "is_false",
    "is_nan",
    "is_not_nan",
    "equals",
    "does_not_equal",
    "contains",
    "regex",
    "starts_with",
    "ends_with",
    "in",
]

#+END_SRC
****** Assignment Aggregation
#+BEGIN_SRC python
Aggregation = Literal[
    "count",
    "sum",
    "mean",
    "median",
    "min",
    "max",
]

#+END_SRC
****** Class TransformType
#+BEGIN_SRC python
class TransformType(Enum):
    AGGREGATE = "aggregate"
    COLUMN_CONVERSION = "column_conversion"
    FILTER_ROWS = "filter_rows"
    GROUP_BY = "group_by"
    RENAME_COLUMN = "rename_column"
    SELECT_COLUMNS = "select_columns"
    SORT_COLUMN = "sort_column"
    SHUFFLE_ROWS = "shuffle_rows"
    SAMPLE_ROWS = "sample_rows"
    EXPLODE_COLUMNS = "explode_columns"
    EXPAND_DICT = "expand_dict"

#+END_SRC
****** @dataclass(frozen=True): Class Condition
#+BEGIN_SRC python
@dataclass(frozen=True)
class Condition:
    column_id: ColumnId
    operator: Operator
    value: Optional[Any] = None

    def __hash__(self) -> int:
        return hash((self.column_id, self.operator, self.value))

    def __post_init__(self) -> None:
        if self.operator == "in":
            assert isinstance(
                self.value, list
            ), "value must be a list for 'in' operator"

#+END_SRC
****** @dataclass: Class ColumnConversionTransform
#+BEGIN_SRC python
@dataclass
class ColumnConversionTransform:
    type: Literal[TransformType.COLUMN_CONVERSION]
    column_id: ColumnId
    data_type: NumpyDataType
    errors: Literal["ignore", "raise"]

#+END_SRC
****** @dataclass: Class RenameColumnTransform
#+BEGIN_SRC python
@dataclass
class RenameColumnTransform:
    type: Literal[TransformType.RENAME_COLUMN]
    column_id: ColumnId
    new_column_id: ColumnId

#+END_SRC
****** @dataclass: Class SortColumnTransform
#+BEGIN_SRC python
@dataclass
class SortColumnTransform:
    type: Literal[TransformType.SORT_COLUMN]
    column_id: ColumnId
    ascending: bool
    na_position: Literal["first", "last"]

#+END_SRC
****** @dataclass: Class FilterRowsTransform
#+BEGIN_SRC python
@dataclass
class FilterRowsTransform:
    type: Literal[TransformType.FILTER_ROWS]
    operation: Literal["keep_rows", "remove_rows"]
    where: List[Condition]

#+END_SRC
****** @dataclass: Class GroupByTransform
#+BEGIN_SRC python
@dataclass
class GroupByTransform:
    type: Literal[TransformType.GROUP_BY]
    column_ids: ColumnIds
    drop_na: bool
    aggregation: Aggregation

#+END_SRC
****** @dataclass: Class AggregateTransform
#+BEGIN_SRC python
@dataclass
class AggregateTransform:
    type: Literal[TransformType.AGGREGATE]
    column_ids: ColumnIds
    aggregations: List[Aggregation]

#+END_SRC
****** @dataclass: Class SelectColumnsTransform
#+BEGIN_SRC python
@dataclass
class SelectColumnsTransform:
    type: Literal[TransformType.SELECT_COLUMNS]
    column_ids: ColumnIds

#+END_SRC
****** @dataclass: Class ShuffleRowsTransform
#+BEGIN_SRC python
@dataclass
class ShuffleRowsTransform:
    type: Literal[TransformType.SHUFFLE_ROWS]
    seed: int

#+END_SRC
****** @dataclass: Class SampleRowsTransform
#+BEGIN_SRC python
@dataclass
class SampleRowsTransform:
    type: Literal[TransformType.SAMPLE_ROWS]
    n: int
    replace: bool
    seed: int

#+END_SRC
****** @dataclass: Class ExplodeColumnsTransform
#+BEGIN_SRC python
@dataclass
class ExplodeColumnsTransform:
    type: Literal[TransformType.EXPLODE_COLUMNS]
    column_ids: ColumnIds

#+END_SRC
****** @dataclass: Class ExpandDictTransform
#+BEGIN_SRC python
@dataclass
class ExpandDictTransform:
    type: Literal[TransformType.EXPAND_DICT]
    column_id: ColumnId

#+END_SRC
****** Assignment Transform
#+BEGIN_SRC python
Transform = Union[
    AggregateTransform,
    ColumnConversionTransform,
    FilterRowsTransform,
    GroupByTransform,
    RenameColumnTransform,
    SelectColumnsTransform,
    SortColumnTransform,
    ShuffleRowsTransform,
    SampleRowsTransform,
    ExplodeColumnsTransform,
    ExpandDictTransform,
]

#+END_SRC
****** @dataclass: Class Transformations
#+BEGIN_SRC python
@dataclass
class Transformations:
    transforms: List[Transform]

#+END_SRC
****** Assignment T = TypeVar("T")
#+BEGIN_SRC python
T = TypeVar("T")

#+END_SRC
****** Class TransformHandler
#+BEGIN_SRC python
class TransformHandler(abc.ABC, Generic[T]):
    @staticmethod
    @abc.abstractmethod
    def handle_column_conversion(
        df: T, transform: ColumnConversionTransform
    ) -> T:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def handle_rename_column(df: T, transform: RenameColumnTransform) -> T:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def handle_sort_column(df: T, transform: SortColumnTransform) -> T:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def handle_filter_rows(df: T, transform: FilterRowsTransform) -> T:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def handle_group_by(df: T, transform: GroupByTransform) -> T:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def handle_aggregate(df: T, transform: AggregateTransform) -> T:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def handle_select_columns(df: T, transform: SelectColumnsTransform) -> T:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def handle_shuffle_rows(df: T, transform: ShuffleRowsTransform) -> T:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def handle_sample_rows(df: T, transform: SampleRowsTransform) -> T:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def handle_explode_columns(df: T, transform: ExplodeColumnsTransform) -> T:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def handle_expand_dict(df: T, transform: ExpandDictTransform) -> T:
        raise NotImplementedError

    @staticmethod
    def as_python_code(
        df_name: str, columns: List[str], transforms: List[Transform]
    ) -> str | None:
        del df_name, transforms, columns
        return None

    @staticmethod
    def as_sql_code(transformed_df: T) -> str | None:
        del transformed_df
        return None

#+END_SRC
*** tables
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.tables
:END:
**** default_table
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.tables.default_table
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/tables/default_table.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import (
    Any,
    Dict,
    List,
    Optional,
    Sequence,
    Tuple,
    Union,
    cast,
)

from marimo._data.models import ColumnSummary, ExternalDataType
from marimo._dependencies.dependencies import DependencyManager
from marimo._output.mime import MIME
from marimo._plugins.core.web_component import JSONType
from marimo._plugins.ui._impl.tables.format import (
    FormatMapping,
    format_column,
    format_row,
)
from marimo._plugins.ui._impl.tables.pandas_table import (
    PandasTableManagerFactory,
)
from marimo._plugins.ui._impl.tables.polars_table import (
    PolarsTableManagerFactory,
)
from marimo._plugins.ui._impl.tables.table_manager import (
    ColumnName,
    FieldType,
    FieldTypes,
    TableManager,
)

#+END_SRC
***** Assignment JsonTableData
#+BEGIN_SRC python
JsonTableData = Union[
    Sequence[Union[str, int, float, bool, MIME, None]],
    Sequence[JSONType],
    List[JSONType],
    Dict[str, Sequence[Union[str, int, float, bool, MIME, None]]],
    Dict[str, JSONType],
]

#+END_SRC
***** Class DefaultTableManager
#+BEGIN_SRC python
class DefaultTableManager(TableManager[JsonTableData]):
    type = "dictionary"

    def __init__(self, data: JsonTableData):
        self.data = data
        self.is_column_oriented = _is_column_oriented(data)

    def supports_download(self) -> bool:
        # If we have pandas/polars/pyarrow, we can convert to CSV or JSON
        return (
            DependencyManager.pandas.has()
            or DependencyManager.polars.has()
            or DependencyManager.pyarrow.has()
        )

    def apply_formatting(
        self, format_mapping: Optional[FormatMapping]
    ) -> TableManager[JsonTableData]:
        if not format_mapping:
            return self

        if isinstance(self.data, dict) and self.is_column_oriented:
            return DefaultTableManager(
                {
                    col: format_column(col, values, format_mapping)  # type: ignore
                    for col, values in self.data.items()
                }
            )
        if isinstance(self.data, (list, tuple)) and all(
            isinstance(item, dict) for item in self.data
        ):
            return DefaultTableManager(
                [
                    format_row(row, format_mapping)  # type: ignore
                    for row in self.data
                ]
            )
        return self

    def supports_filters(self) -> bool:
        return False

    def to_data(
        self, format_mapping: Optional[FormatMapping] = None
    ) -> JSONType:
        return self._normalize_data(self.apply_formatting(format_mapping).data)

    def to_csv(self, format_mapping: Optional[FormatMapping] = None) -> bytes:
        if isinstance(self.data, dict) and not self.is_column_oriented:
            return DefaultTableManager(self._normalize_data(self.data)).to_csv(
                format_mapping
            )

        return self._as_table_manager().to_csv(format_mapping)

    def to_json(self) -> bytes:
        if isinstance(self.data, dict) and not self.is_column_oriented:
            return DefaultTableManager(
                self._normalize_data(self.data)
            ).to_json()
        return self._as_table_manager().to_json()

    def select_rows(self, indices: List[int]) -> DefaultTableManager:
        if isinstance(self.data, dict):
            # Column major data
            if self.is_column_oriented:
                new_data: Dict[Any, Any] = {
                    key: [cast(List[JSONType], value)[i] for i in indices]
                    for key, value in self.data.items()
                }
                return DefaultTableManager(new_data)
            else:
                return DefaultTableManager(
                    self._normalize_data(self.data)
                ).select_rows(indices)
        # Row major data
        return DefaultTableManager([self.data[i] for i in indices])

    def select_columns(self, columns: List[str]) -> DefaultTableManager:
        # Column major data
        if isinstance(self.data, dict):
            new_data: Dict[str, Any] = {
                key: value
                for key, value in self.data.items()
                if key in columns
            }
            return DefaultTableManager(new_data)
        # Row major data
        return DefaultTableManager(
            [
                {key: row[key] for key in columns}
                for row in self._normalize_data(self.data)
            ]
        )

    def take(self, count: int, offset: int) -> DefaultTableManager:
        if count < 0:
            raise ValueError("Count must be a positive integer")
        if offset < 0:
            raise ValueError("Offset must be a non-negative integer")

        if isinstance(self.data, dict):
            if self.is_column_oriented:
                return DefaultTableManager(
                    cast(
                        JsonTableData,
                        {
                            key: cast(List[Any], value)[
                                offset : offset + count
                            ]
                            for key, value in self.data.items()
                        },
                    )
                )
            return DefaultTableManager(
                self._normalize_data(self.data)[offset : offset + count]
            )
        return DefaultTableManager(self.data[offset : offset + count])

    def search(self, query: str) -> DefaultTableManager:
        query = query.lower()
        if isinstance(self.data, dict) and self.is_column_oriented:
            mask: List[bool] = [
                any(
                    query in str(cast(List[Any], self.data[key])[row]).lower()
                    for key in self.data.keys()
                )
                for row in range(self.get_num_rows() or 0)
            ]
            results = {
                key: [
                    cast(List[Any], value)[i]
                    for i, match in enumerate(mask)
                    if match
                ]
                for key, value in self.data.items()
            }
            return DefaultTableManager(cast(JsonTableData, results))
        return DefaultTableManager(
            [
                row
                for row in self._normalize_data(self.data)
                if any(query in str(v).lower() for v in row.values())
            ]
        )

    def get_row_headers(self) -> list[str]:
        return []

    def get_field_type(
        self, column_name: str
    ) -> Tuple[FieldType, ExternalDataType]:
        del column_name
        return ("unknown", "object")

    # By default, don't provide any field types
    # so the frontend can infer them
    def get_field_types(self) -> FieldTypes:
        return []

    def _as_table_manager(self) -> TableManager[Any]:
        if DependencyManager.pandas.has():
            import pandas as pd

            return PandasTableManagerFactory.create()(pd.DataFrame(self.data))
        if DependencyManager.polars.has():
            import polars as pl

            if isinstance(self.data, dict) and not self.is_column_oriented:
                return PolarsTableManagerFactory.create()(
                    pl.DataFrame(self._normalize_data(self.data))
                )

            return PolarsTableManagerFactory.create()(
                pl.DataFrame(cast(Any, self.data))
            )

        raise ValueError("No supported table libraries found.")

    def get_summary(self, column: str) -> ColumnSummary:
        del column
        return ColumnSummary()

    def get_num_rows(self, force: bool = True) -> int:
        del force
        if isinstance(self.data, dict):
            if self.is_column_oriented:
                first = next(iter(self.data.values()), None)
                return len(cast(List[Any], first))
            else:
                return len(self.data)
        return len(self.data)

    def get_num_columns(self) -> int:
        return len(self.data) if isinstance(self.data, dict) else 1

    def get_column_names(self) -> List[str]:
        if isinstance(self.data, dict):
            return list(self.data.keys())
        first = next(iter(self.data), None)
        return list(first.keys()) if isinstance(first, dict) else ["value"]

    def get_unique_column_values(self, column: str) -> list[str | int | float]:
        return sorted(
            self._as_table_manager().get_unique_column_values(column)
        )

    def sort_values(
        self, by: ColumnName, descending: bool
    ) -> DefaultTableManager:
        normalized = self._normalize_data(self.data)
        try:
            data = sorted(normalized, key=lambda x: x[by], reverse=descending)
        except TypeError:
            # Handle when all values are not comparable
            data = sorted(
                normalized, key=lambda x: str(x[by]), reverse=descending
            )
        return DefaultTableManager(data)

    @staticmethod
    def is_type(value: Any) -> bool:
        return isinstance(value, (list, tuple, dict))

    @staticmethod
    def _normalize_data(data: JsonTableData) -> list[dict[str, Any]]:
        # If it is a dict of lists (column major),
        # convert to list of dicts (row major)
        if isinstance(data, dict) and _is_column_oriented(data):
            # reshape column major
            #   { "col1": [1, 2, 3], "col2": [4, 5, 6], ... }
            # into row major
            #   [ {"col1": 1, "col2": 4}, {"col1": 2, "col2": 5 }, ...]
            column_values = data.values()
            column_names = list(data.keys())
            return [
                dict(zip(column_names, row_values))
                for row_values in zip(*column_values)
            ]

        # If its a dictionary, convert to key-value pairs
        if isinstance(data, dict):
            return [
                {"key": key, "value": value} for key, value in data.items()
            ]

        # Assert that data is a list
        if not isinstance(data, (list, tuple)):
            raise ValueError(
                "data must be a list or tuple or a dict of lists."
            )

        # Handle empty data
        if len(data) == 0:
            return []

        # Handle single-column data
        if not isinstance(data[0], dict):
            if not isinstance(data[0], (str, int, float, bool, type(None))):
                raise ValueError(
                    "data must be a sequence of JSON-serializable types, or a "
                    "sequence of dicts."
                )

            # we're going to assume that data has the right shape, after
            # having checked just the first entry
            casted = cast(List[Union[str, int, float, bool, MIME, None]], data)
            return [{"value": datum} for datum in casted]
        # Sequence of dicts
        return cast(List[Dict[str, Any]], data)

#+END_SRC
***** Function _is_column_oriented
#+BEGIN_SRC python
def _is_column_oriented(data: JsonTableData) -> bool:
    return isinstance(data, dict) and all(
        isinstance(value, (list, tuple)) for value in data.values()
    )

#+END_SRC
**** format
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.tables.format
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/tables/format.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Callable, Dict, List, Union

from marimo._plugins.core.web_component import JSONType

#+END_SRC
***** Assignment FormatMapping = Dict[str, Union[str, Callable[..., JSONType]]]
#+BEGIN_SRC python
FormatMapping = Dict[str, Union[str, Callable[..., JSONType]]]

#+END_SRC
***** Function format_value
#+BEGIN_SRC python
def format_value(
    col: str, value: JSONType, format_mapping: FormatMapping
) -> JSONType:
    # Return None if the format mapping is None
    if format_mapping is None:
        return value
    # Return None if the value is None
    if value is None:
        return None
    # Apply formatting logic based on column and value
    if col in format_mapping:
        formatter = format_mapping[col]
        if isinstance(formatter, str):
            return formatter.format(value)
        if callable(formatter):
            return formatter(value)
    return value

#+END_SRC
***** Function format_row
#+BEGIN_SRC python
def format_row(
    row: Dict[str, JSONType], format_mapping: FormatMapping
) -> Dict[str, JSONType]:
    # Return None if the format mapping is None
    if format_mapping is None:
        return row
    # Apply formatting to each value in a row dictionary
    return {
        col: format_value(col, value, format_mapping)
        for col, value in row.items()
    }

#+END_SRC
***** Function format_column
#+BEGIN_SRC python
def format_column(
    col: str, values: List[JSONType], format_mapping: FormatMapping
) -> List[JSONType]:
    # Return None if the format mapping is None
    if format_mapping is None:
        return values
    # Apply formatting to each value in a column list
    return [format_value(col, value, format_mapping) for value in values]

#+END_SRC
**** ibis_table
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.tables.ibis_table
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/tables/ibis_table.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Optional, Tuple

from marimo._data.models import (
    ColumnSummary,
    ExternalDataType,
)
from marimo._dependencies.dependencies import DependencyManager
from marimo._plugins.ui._impl.tables.format import (
    FormatMapping,
)
from marimo._plugins.ui._impl.tables.pandas_table import (
    PandasTableManagerFactory,
)
from marimo._plugins.ui._impl.tables.polars_table import (
    PolarsTableManagerFactory,
)
from marimo._plugins.ui._impl.tables.table_manager import (
    ColumnName,
    FieldType,
    TableManager,
    TableManagerFactory,
)
from marimo._utils.memoize import memoize_last_value

#+END_SRC
***** Class IbisTableManagerFactory
#+BEGIN_SRC python
class IbisTableManagerFactory(TableManagerFactory):
    @staticmethod
    def package_name() -> str:
        return "ibis"

    @staticmethod
    def create() -> type[TableManager[Any]]:
        import ibis  # type: ignore

        class IbisTableManager(TableManager[ibis.Table]):
            type = "ibis"

            def to_csv(
                self, format_mapping: Optional[FormatMapping] = None
            ) -> bytes:
                return self._as_table_manager().to_csv(format_mapping)

            def to_json(self) -> bytes:
                return self._as_table_manager().to_json()

            def supports_download(self) -> bool:
                return False

            def apply_formatting(
                self, format_mapping: Optional[FormatMapping]
            ) -> IbisTableManager:
                raise NotImplementedError("Column formatting not supported")

            def supports_filters(self) -> bool:
                return True

            def select_rows(
                self, indices: list[int]
            ) -> TableManager[ibis.Table]:
                if not indices:
                    return self.take(0, 0)  # Return empty table
                # Select rows using Ibis API
                return IbisTableManager(
                    self.data.filter(ibis.row_number().over().isin(indices))
                )

            def select_columns(
                self, columns: list[str]
            ) -> TableManager[ibis.Table]:
                return IbisTableManager(self.data.select(columns))

            def get_row_headers(
                self,
            ) -> list[str]:
                return []

            @staticmethod
            def is_type(value: Any) -> bool:
                return isinstance(value, ibis.Table)

            def take(self, count: int, offset: int) -> IbisTableManager:
                if count < 0:
                    raise ValueError("Count must be a positive integer")
                if offset < 0:
                    raise ValueError("Offset must be a non-negative integer")
                return IbisTableManager(self.data.limit(count, offset=offset))

            def search(self, query: str) -> TableManager[Any]:
                query = query.lower()
                predicates = []
                for column in self.data.columns:
                    col = self.data[column]
                    if col.type().is_string():
                        predicates.append(col.lower().rlike(query))
                    elif col.type().is_numeric():
                        predicates.append(
                            col.cast("string").lower().contains(query)
                        )
                    elif col.type().is_boolean():
                        predicates.append(
                            col.cast("string").lower().contains(query)
                        )
                    elif col.type().is_timestamp():
                        predicates.append(
                            col.cast("string").lower().contains(query)
                        )
                    elif col.type().is_date():
                        predicates.append(
                            col.cast("string").lower().contains(query)
                        )
                    elif col.type().is_time():
                        predicates.append(
                            col.cast("string").lower().contains(query)
                        )

                if predicates:
                    filtered = self.data.filter(ibis.or_(*predicates))
                else:
                    filtered = self.data.filter(ibis.literal(False))

                return IbisTableManager(filtered)

            def get_summary(self, column: str) -> ColumnSummary:
                col = self.data[column]
                total = self.data.count().execute()
                nulls = col.isnull().sum().execute()

                summary = ColumnSummary(total=total, nulls=nulls)

                if col.type().is_numeric():
                    summary.min = col.min().execute()
                    summary.max = col.max().execute()
                    summary.mean = col.mean().execute()
                    summary.median = col.median().execute()
                    summary.std = col.std().execute()

                return summary

            @memoize_last_value
            def get_num_rows(self, force: bool = True) -> Optional[int]:
                if force:
                    return self.data.count().execute()  # type: ignore
                return None

            def get_num_columns(self) -> int:
                return len(self.data.columns)

            def get_column_names(self) -> list[str]:
                return self.data.columns  # type: ignore

            def get_unique_column_values(
                self, column: str
            ) -> list[str | int | float]:
                result = (
                    self.data.distinct(on=column)
                    .select(column)
                    .execute()[column]
                    .tolist()
                )
                return result  # type: ignore

            def sort_values(
                self, by: ColumnName, descending: bool
            ) -> IbisTableManager:
                sorted_data = self.data.order_by(
                    ibis.desc(by) if descending else ibis.asc(by)
                )
                return IbisTableManager(sorted_data)

            def get_field_type(
                self, column_name: str
            ) -> Tuple[FieldType, ExternalDataType]:
                column = self.data[column_name]
                dtype = column.type()
                if dtype.is_string():
                    return ("string", str(dtype))
                elif dtype.is_boolean():
                    return ("boolean", str(dtype))
                elif dtype.is_integer():
                    return ("integer", str(dtype))
                elif dtype.is_floating():
                    return ("number", str(dtype))
                elif dtype.is_timestamp():
                    return ("datetime", str(dtype))
                elif dtype.is_time():
                    return ("time", str(dtype))
                elif dtype.is_date():
                    return ("date", str(dtype))
                else:
                    return ("unknown", str(dtype))

            def _as_table_manager(self) -> TableManager[Any]:
                if DependencyManager.pandas.has():
                    return PandasTableManagerFactory.create()(
                        self.data.to_pandas()
                    )
                if DependencyManager.polars.has():
                    return PolarsTableManagerFactory.create()(
                        self.data.to_polars()
                    )

                raise ValueError(
                    "Requires at least one of pandas, polars, or pyarrow"
                )

        return IbisTableManager

#+END_SRC
**** narwhals_table
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.tables.narwhals_table
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/tables/narwhals_table.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import json
from typing import Any, Optional, Tuple, Union, cast

import narwhals.stable.v1 as nw
from narwhals.typing import IntoFrameT

from marimo._data.models import ColumnSummary, ExternalDataType
from marimo._plugins.ui._impl.tables.format import (
    FormatMapping,
    format_value,
)
from marimo._plugins.ui._impl.tables.table_manager import (
    ColumnName,
    FieldType,
    TableManager,
)
from marimo._utils.narwhals_utils import (
    can_narwhalify,
    dataframe_to_csv,
    is_narwhals_integer_type,
    is_narwhals_string_type,
    is_narwhals_temporal_type,
    unwrap_py_scalar,
)

#+END_SRC
***** Class NarwhalsTableManager
#+BEGIN_SRC python
class NarwhalsTableManager(
    TableManager[Union[nw.DataFrame[IntoFrameT], nw.LazyFrame[IntoFrameT]]]
):
    type = "narwhals"

    @staticmethod
    def from_dataframe(data: IntoFrameT) -> NarwhalsTableManager[IntoFrameT]:
        return NarwhalsTableManager(nw.from_native(data, strict=True))

    def as_frame(self) -> nw.DataFrame[Any]:
        if isinstance(self.data, nw.LazyFrame):
            return self.data.collect()
        return self.data

    def with_new_data(
        self, data: nw.DataFrame[Any] | nw.LazyFrame[Any]
    ) -> TableManager[Any]:
        if type(self) is NarwhalsTableManager:
            return NarwhalsTableManager(data)
        # If this call comes from a subclass, we need to call the constructor
        # of the subclass with the native data.
        return self.__class__(data.to_native())

    def to_csv(
        self,
        format_mapping: Optional[FormatMapping] = None,
    ) -> bytes:
        _data = self.apply_formatting(format_mapping).as_frame()
        return dataframe_to_csv(_data).encode("utf-8")

    def to_json(self) -> bytes:
        csv_str = self.to_csv().decode("utf-8")
        import csv

        csv_reader = csv.DictReader(csv_str.splitlines())
        return json.dumps([row for row in csv_reader]).encode("utf-8")

    def apply_formatting(
        self, format_mapping: Optional[FormatMapping]
    ) -> NarwhalsTableManager[Any]:
        if not format_mapping:
            return self

        _data = self.as_frame().to_dict(as_series=False).copy()
        for col in _data.keys():
            if col in format_mapping:
                _data[col] = [
                    format_value(col, x, format_mapping) for x in _data[col]
                ]
        return NarwhalsTableManager(
            nw.from_dict(
                _data, native_namespace=nw.get_native_namespace(self.data)
            )
        )

    def supports_filters(self) -> bool:
        return True

    def select_rows(self, indices: list[int]) -> TableManager[Any]:
        df = self.as_frame()
        return self.with_new_data(df[indices])

    def select_columns(self, columns: list[str]) -> TableManager[Any]:
        return self.with_new_data(self.data.select(columns))

    def get_row_headers(
        self,
    ) -> list[str]:
        return []

    @staticmethod
    def is_type(value: Any) -> bool:
        return can_narwhalify(value)

    def get_field_type(
        self, column_name: str
    ) -> Tuple[FieldType, ExternalDataType]:
        dtype = self.data.schema[column_name]
        dtype_string = str(dtype)
        if is_narwhals_string_type(dtype):
            return ("string", dtype_string)
        elif dtype == nw.Boolean:
            return ("boolean", dtype_string)
        elif is_narwhals_integer_type(dtype):
            return ("integer", dtype_string)
        elif is_narwhals_temporal_type(dtype):
            return ("date", dtype_string)
        elif dtype.is_numeric():
            return ("number", dtype_string)
        else:
            return ("unknown", dtype_string)

    def take(self, count: int, offset: int) -> TableManager[Any]:
        if count < 0:
            raise ValueError("Count must be a positive integer")
        if offset < 0:
            raise ValueError("Offset must be a non-negative integer")
        return self.with_new_data(self.data[offset : offset + count])

    def search(self, query: str) -> TableManager[Any]:
        query = query.lower()

        expressions: list[Any] = []
        for column, dtype in self.data.schema.items():
            if dtype == nw.String:
                expressions.append(nw.col(column).str.contains(query))
            elif dtype == nw.List(nw.String):
                # expressions.append(
                #     nw.col(column).cast(nw.String).sum().str.contains(query)
                # )
                pass
            elif (
                dtype.is_numeric()
                or is_narwhals_temporal_type(dtype)
                or dtype == nw.Boolean
            ):
                expressions.append(
                    nw.col(column).cast(nw.String).str.contains(f"(?i){query}")
                )

        if not expressions:
            return NarwhalsTableManager(self.data.filter(nw.lit(False)))

        or_expr = expressions[0]
        for expr in expressions[1:]:
            or_expr = or_expr | expr

        filtered = self.data.filter(or_expr)
        return NarwhalsTableManager(filtered)

    def get_summary(self, column: str) -> ColumnSummary:
        summary = self._get_summary_internal(column)
        for key, value in summary.__dict__.items():
            if value is not None:
                summary.__dict__[key] = unwrap_py_scalar(value)
        return summary

    def _get_summary_internal(self, column: str) -> ColumnSummary:
        # If column is not in the dataframe, return an empty summary
        if column not in self.data.schema:
            return ColumnSummary()
        col = self.data[column]
        total = len(col)
        if is_narwhals_string_type(col.dtype):
            return ColumnSummary(
                total=total,
                nulls=col.null_count(),
                unique=col.n_unique(),
            )
        if col.dtype == nw.Boolean:
            return ColumnSummary(
                total=total,
                nulls=col.null_count(),
                true=cast(int, col.sum()),
                false=cast(int, total - col.sum()),
            )
        if col.dtype == nw.Date:
            return ColumnSummary(
                total=total,
                nulls=col.null_count(),
                min=col.min(),
                max=col.max(),
                mean=col.mean(),
                # Quantile not supported on date type
                # median=col.quantile(0.5, interpolation="nearest"),
            )
        if is_narwhals_temporal_type(col.dtype):
            return ColumnSummary(
                total=total,
                nulls=col.null_count(),
                min=col.min(),
                max=col.max(),
                mean=col.mean(),
                median=col.quantile(0.5, interpolation="nearest"),
                p5=col.quantile(0.05, interpolation="nearest"),
                p25=col.quantile(0.25, interpolation="nearest"),
                p75=col.quantile(0.75, interpolation="nearest"),
                p95=col.quantile(0.95, interpolation="nearest"),
            )
        if (
            col.dtype == nw.List
            or col.dtype == nw.Struct
            or col.dtype == nw.Object
            or col.dtype == nw.Array
        ):
            return ColumnSummary(
                total=total,
                nulls=col.null_count(),
            )
        if col.dtype == nw.Unknown:
            return ColumnSummary(
                total=total,
                nulls=col.null_count(),
            )
        return ColumnSummary(
            total=total,
            nulls=col.null_count(),
            unique=col.n_unique()
            if is_narwhals_integer_type(col.dtype)
            else None,
            min=col.min(),
            max=col.max(),
            mean=col.mean(),
            median=col.quantile(0.5, interpolation="nearest"),
            std=col.std(),
            p5=col.quantile(0.05, interpolation="nearest"),
            p25=col.quantile(0.25, interpolation="nearest"),
            p75=col.quantile(0.75, interpolation="nearest"),
            p95=col.quantile(0.95, interpolation="nearest"),
        )

    def get_num_rows(self, force: bool = True) -> Optional[int]:
        # If force is true, collect the data and get the number of rows
        if force:
            return self.as_frame().shape[0]

        # When lazy, we don't know the number of rows
        if isinstance(self.data, nw.LazyFrame):
            return None

        # Otherwise, we can get the number of rows from the shape
        try:
            return self.data.shape[0]
        except Exception:
            # narwhals will raise on metadata-only frames
            return None

    def get_num_columns(self) -> int:
        return len(self.data.schema.names())

    def get_column_names(self) -> list[str]:
        return self.data.schema.names()

    def get_unique_column_values(self, column: str) -> list[str | int | float]:
        return self.data[column].unique().to_list()

    def sort_values(
        self, by: ColumnName, descending: bool
    ) -> TableManager[Any]:
        if isinstance(self.data, nw.LazyFrame):
            return self.with_new_data(
                self.data.sort(by, descending=descending)
            )
        else:
            return self.with_new_data(
                self.data.sort(by, descending=descending)
            )

    def __repr__(self) -> str:
        rows = self.get_num_rows(force=False)
        columns = self.get_num_columns()
        df_type = str(nw.get_native_namespace(self.data).__name__)
        if rows is None:
            return f"{df_type}: {columns:,} columns"
        return f"{df_type}: {rows:,} rows x {columns:,} columns"

#+END_SRC
**** pandas_table
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.tables.pandas_table
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/tables/pandas_table.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Optional, Tuple

import narwhals.stable.v1 as nw

from marimo._data.models import ExternalDataType
from marimo._plugins.ui._impl.tables.format import (
    FormatMapping,
    format_value,
)
from marimo._plugins.ui._impl.tables.narwhals_table import NarwhalsTableManager
from marimo._plugins.ui._impl.tables.table_manager import (
    FieldType,
    TableManager,
    TableManagerFactory,
)

#+END_SRC
***** Class PandasTableManagerFactory
#+BEGIN_SRC python
class PandasTableManagerFactory(TableManagerFactory):
    @staticmethod
    def package_name() -> str:
        return "pandas"

    @staticmethod
    def create() -> type[TableManager[Any]]:
        import pandas as pd

        class PandasTableManager(NarwhalsTableManager[pd.DataFrame]):
            type = "pandas"

            def __init__(self, data: pd.DataFrame) -> None:
                super().__init__(nw.from_native(data))

            def as_pandas_frame(self) -> pd.DataFrame:
                native: Any = self.data.to_native()
                if isinstance(native, pd.DataFrame):
                    return native
                raise ValueError(f"Unsupported native type: {type(native)}")

            # We override narwhals's to_csv to handle pandas
            # headers
            def to_csv(
                self, format_mapping: Optional[FormatMapping] = None
            ) -> bytes:
                has_headers = len(self.get_row_headers()) > 0
                return (
                    self.apply_formatting(format_mapping)
                    .as_pandas_frame()
                    .to_csv(index=has_headers)
                    .encode("utf-8")
                )

            def to_json(self) -> bytes:
                return (
                    self.as_pandas_frame()
                    .to_json(orient="records")
                    .encode("utf-8")
                )

            def apply_formatting(
                self, format_mapping: Optional[FormatMapping]
            ) -> PandasTableManager:
                if not format_mapping:
                    return self

                _data = self.as_pandas_frame().copy()
                for col in _data.columns:
                    if col in format_mapping:
                        _data[col] = _data[col].apply(
                            lambda x, col=col: format_value(  # type: ignore
                                col, x, format_mapping
                            )
                        )
                return PandasTableManager(_data)

            # We override the default implementation to use pandas
            # headers
            def get_row_headers(
                self,
            ) -> list[str]:
                return PandasTableManager._get_row_headers_for_index(
                    self.as_pandas_frame().index
                )

            @staticmethod
            def is_type(value: Any) -> bool:
                return isinstance(value, pd.DataFrame)

            @staticmethod
            def _get_row_headers_for_index(
                index: pd.Index[Any],
            ) -> list[str]:
                # Ignore if it's the default index with no name
                if index.name is None and isinstance(index, pd.RangeIndex):
                    return []

                if isinstance(index, pd.MultiIndex):
                    # recurse
                    headers: list[Any] = []
                    for i in range(index.nlevels):
                        headers.extend(
                            PandasTableManager._get_row_headers_for_index(
                                index.get_level_values(i)
                            )
                        )
                    return headers

                return [str(index.name or "")]

            # We override the default implementation to use pandas's
            # internal fields since they get displayed in the UI.
            def get_field_type(
                self, column_name: str
            ) -> Tuple[FieldType, ExternalDataType]:
                data = self.as_pandas_frame()
                series = data[column_name]
                # If a df has duplicate columns, it won't be a series, but
                # a dataframe. In this case, we take the dtype of the columns
                if isinstance(series, pd.DataFrame):
                    dtype = str(series.columns.dtype)
                else:
                    dtype = str(series.dtype)

                if dtype.startswith("interval"):
                    return ("string", dtype)
                if dtype.startswith("int") or dtype.startswith("uint"):
                    return ("integer", dtype)
                if dtype.startswith("float"):
                    return ("number", dtype)
                if dtype == "object":
                    return ("string", dtype)
                if dtype == "bool":
                    return ("boolean", dtype)
                if dtype == "datetime64[ns]":
                    return ("datetime", dtype)
                if dtype == "date":
                    return ("date", dtype)
                if dtype == "time":
                    return ("time", dtype)
                if dtype == "timedelta64[ns]":
                    return ("string", dtype)
                if dtype == "category":
                    return ("string", dtype)
                if dtype.startswith("complex"):
                    return ("unknown", dtype)
                return ("unknown", dtype)

            # We override the default since narwhals returns a Series
            def get_unique_column_values(
                self, column: str
            ) -> list[str | int | float]:
                return self.as_pandas_frame()[column].unique().tolist()  # type: ignore[no-any-return]

        return PandasTableManager

#+END_SRC
**** polars_table
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.tables.polars_table
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/tables/polars_table.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, Optional, Tuple, Union

import narwhals.stable.v1 as nw

from marimo._data.models import (
    ExternalDataType,
)
from marimo._plugins.ui._impl.tables.format import (
    FormatMapping,
    format_value,
)
from marimo._plugins.ui._impl.tables.narwhals_table import NarwhalsTableManager
from marimo._plugins.ui._impl.tables.table_manager import (
    FieldType,
    TableManager,
    TableManagerFactory,
)

#+END_SRC
***** Class PolarsTableManagerFactory
#+BEGIN_SRC python
class PolarsTableManagerFactory(TableManagerFactory):
    @staticmethod
    def package_name() -> str:
        return "polars"

    @staticmethod
    def create() -> type[TableManager[Any]]:
        import polars as pl

        class PolarsTableManager(
            NarwhalsTableManager[Union[pl.DataFrame, pl.LazyFrame]]
        ):
            type = "polars"

            def __init__(
                self, data: Union[pl.DataFrame, pl.LazyFrame]
            ) -> None:
                super().__init__(nw.from_native(data))

            def collect(self) -> pl.DataFrame:
                native: Any = self.data.to_native()
                if isinstance(native, pl.LazyFrame):
                    return native.collect()
                if isinstance(native, pl.DataFrame):
                    return native
                raise ValueError(f"Unsupported native type: {type(native)}")

            def as_polars_frame(self) -> Union[pl.DataFrame, pl.LazyFrame]:
                native: Any = self.data.to_native()
                if isinstance(native, (pl.LazyFrame, pl.DataFrame)):
                    return native
                raise ValueError(f"Unsupported native type: {type(native)}")

            def schema(self) -> dict[str, pl.DataType]:
                return self.as_polars_frame().schema

            # We override narwhals's to_csv to handle polars
            # nested data types.
            def to_csv(
                self,
                format_mapping: Optional[FormatMapping] = None,
            ) -> bytes:
                _data = self.apply_formatting(format_mapping).collect()
                try:
                    return _data.write_csv().encode("utf-8")
                except pl.exceptions.ComputeError:
                    # Likely CSV format does not support nested data or objects
                    # Try to convert columns to json or strings
                    result = _data
                    for column in result.get_columns():
                        dtype = column.dtype
                        if isinstance(dtype, pl.Struct):
                            result = result.with_columns(
                                column.struct.json_encode()
                            )
                        elif isinstance(dtype, pl.List):
                            result = result.with_columns(
                                column.cast(pl.List(pl.Utf8)).list.join(",")
                            )
                        elif isinstance(dtype, pl.Array):
                            result = result.with_columns(
                                column.cast(
                                    pl.Array(pl.Utf8, shape=dtype.shape)
                                ).arr.join(",")
                            )
                        elif isinstance(dtype, pl.Object):
                            import warnings

                            with warnings.catch_warnings(record=True):
                                result = result.with_columns(
                                    # As of writing this, cast(pl.String) doesn't work
                                    # for pl.Object types, so we use map_elements
                                    column.map_elements(
                                        str, return_dtype=pl.String
                                    )
                                )
                        elif isinstance(dtype, pl.Duration):
                            if dtype.time_unit == "ms":
                                result = result.with_columns(
                                    column.dt.total_milliseconds()
                                )

                            elif dtype.time_unit == "ns":
                                result = result.with_columns(
                                    column.dt.total_nanoseconds()
                                )
                            elif dtype.time_unit == "us":
                                result = result.with_columns(
                                    column.dt.total_microseconds()
                                )
                    return result.write_csv().encode("utf-8")

            def to_json(self) -> bytes:
                return self.collect().write_json().encode("utf-8")

            def apply_formatting(
                self, format_mapping: Optional[FormatMapping]
            ) -> PolarsTableManager:
                if not format_mapping:
                    return self

                _data = self.collect()
                for col in _data.columns:
                    if col in format_mapping:
                        _data = _data.with_columns(
                            pl.Series(
                                col,
                                [
                                    format_value(col, x, format_mapping)
                                    for x in _data[col]
                                ],
                            )
                        )
                return PolarsTableManager(_data)

            @staticmethod
            def is_type(value: Any) -> bool:
                return isinstance(value, pl.DataFrame)

            def search(self, query: str) -> PolarsTableManager:
                query = query.lower()

                expressions: list[pl.Expr] = []
                for column, dtype in self.schema().items():
                    if dtype == pl.String:
                        expressions.append(pl.col(column).str.contains(query))
                    elif dtype == pl.List(pl.Utf8):
                        expressions.append(pl.col(column).list.contains(query))
                    elif (
                        dtype.is_numeric()
                        or dtype.is_temporal()
                        or dtype == pl.Boolean
                    ):
                        expressions.append(
                            pl.col(column)
                            .cast(pl.String)
                            .str.contains(f"(?i){query}")
                        )

                if not expressions:
                    return self

                or_expr = expressions[0]
                for expr in expressions[1:]:
                    or_expr = or_expr | expr

                filtered = self.as_polars_frame().filter(or_expr)
                return PolarsTableManager(filtered)

            # We override the default implementation to use polars's
            # internal fields since they get displayed in the UI.
            def get_field_type(
                self, column_name: str
            ) -> Tuple[FieldType, ExternalDataType]:
                dtype = self.schema()[column_name]
                try:
                    dtype_string = dtype._string_repr()
                except (TypeError, AttributeError):
                    dtype_string = str(dtype)
                if (
                    dtype == pl.String
                    or dtype == pl.Categorical
                    or dtype == pl.Enum
                ):
                    return ("string", dtype_string)
                elif dtype == pl.Boolean:
                    return ("boolean", dtype_string)
                elif dtype.is_integer():
                    return ("integer", dtype_string)
                elif (
                    dtype.is_float()
                    or dtype.is_numeric()
                    or dtype.is_decimal()
                ):
                    return ("number", dtype_string)
                elif dtype == pl.Date:
                    return ("date", dtype_string)
                elif dtype == pl.Time:
                    return ("time", dtype_string)
                elif dtype == pl.Datetime:
                    return ("datetime", dtype_string)
                elif dtype.is_temporal():
                    return ("datetime", dtype_string)
                else:
                    return ("unknown", dtype_string)

        return PolarsTableManager

#+END_SRC
**** table_manager
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.tables.table_manager
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/tables/table_manager.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

import abc
from typing import (
    Any,
    Generic,
    Optional,
    Tuple,
    TypeVar,
)

import marimo._output.data.data as mo_data
from marimo._data.models import ColumnSummary, DataType, ExternalDataType
from marimo._plugins.core.web_component import JSONType
from marimo._plugins.ui._impl.tables.format import FormatMapping

#+END_SRC
***** Assignment T = TypeVar("T")
#+BEGIN_SRC python
T = TypeVar("T")

#+END_SRC
***** Assignment ColumnName = str
#+BEGIN_SRC python
ColumnName = str

#+END_SRC
***** Assignment FieldType = DataType
#+BEGIN_SRC python
FieldType = DataType

#+END_SRC
***** Assignment FieldTypes = list[Tuple[ColumnName, Tuple[FieldType, ExternalDataType]]]
#+BEGIN_SRC python
FieldTypes = list[Tuple[ColumnName, Tuple[FieldType, ExternalDataType]]]

#+END_SRC
***** Class TableManager
#+BEGIN_SRC python
class TableManager(abc.ABC, Generic[T]):
    # Upper limit for column summaries
    # The only sets the default to show column summaries,
    # but it can be overridden by the user
    DEFAULT_SUMMARY_CHARTS_COLUMN_LIMIT = 40
    # Upper limit for frontend table component to show column summary charts
    # to ensure browser performance
    DEFAULT_SUMMARY_CHARTS_ROW_LIMIT = 20_000
    # Upper limit for column summaries to avoid hanging up the kernel
    # Note: Keep this value in sync with DataTablePlugin's banner text
    DEFAULT_SUMMARY_STATS_ROW_LIMIT = 1_000_000

    type: str = ""

    def __init__(self, data: T) -> None:
        self.data = data

    def to_data(
        self,
        format_mapping: Optional[FormatMapping] = None,
    ) -> JSONType:
        """
        The best way to represent the data in a table as JSON.

        By default, this method calls `to_csv` and returns the result as
        a string.
        """
        return mo_data.csv(self.to_csv(format_mapping)).url

    def supports_download(self) -> bool:
        return True

    def supports_selection(self) -> bool:
        return True

    def supports_altair(self) -> bool:
        return True

    @abc.abstractmethod
    def apply_formatting(
        self, format_mapping: Optional[FormatMapping]
    ) -> TableManager[Any]:
        raise NotImplementedError

    @abc.abstractmethod
    def supports_filters(self) -> bool:
        raise NotImplementedError

    @abc.abstractmethod
    def sort_values(
        self, by: ColumnName, descending: bool
    ) -> TableManager[Any]:
        raise NotImplementedError

    @abc.abstractmethod
    def to_csv(
        self,
        format_mapping: Optional[FormatMapping] = None,
    ) -> bytes:
        raise NotImplementedError

    @abc.abstractmethod
    def to_json(self) -> bytes:
        raise NotImplementedError

    @abc.abstractmethod
    def select_rows(self, indices: list[int]) -> TableManager[Any]:
        raise NotImplementedError

    @abc.abstractmethod
    def select_columns(self, columns: list[str]) -> TableManager[Any]:
        raise NotImplementedError

    @abc.abstractmethod
    def get_row_headers(self) -> list[str]:
        raise NotImplementedError

    @abc.abstractmethod
    def get_field_type(
        self, column_name: str
    ) -> Tuple[FieldType, ExternalDataType]:
        raise NotImplementedError

    def get_field_types(self) -> FieldTypes:
        return [
            (column_name, self.get_field_type(column_name))
            for column_name in self.get_column_names()
        ]

    @abc.abstractmethod
    def take(self, count: int, offset: int) -> TableManager[Any]:
        raise NotImplementedError

    @abc.abstractmethod
    def search(self, query: str) -> TableManager[Any]:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def is_type(value: Any) -> bool:
        raise NotImplementedError

    @abc.abstractmethod
    def get_summary(self, column: str) -> ColumnSummary:
        raise NotImplementedError

    @abc.abstractmethod
    def get_num_rows(self, force: bool = True) -> Optional[int]:
        # This can be expensive to compute,
        # so we allow optionals
        raise NotImplementedError

    @abc.abstractmethod
    def get_num_columns(self) -> int:
        raise NotImplementedError

    @abc.abstractmethod
    def get_column_names(self) -> list[str]:
        raise NotImplementedError

    @abc.abstractmethod
    def get_unique_column_values(self, column: str) -> list[str | int | float]:
        raise NotImplementedError

    def __repr__(self) -> str:
        rows = self.get_num_rows(force=False)
        columns = self.get_num_columns()
        if rows is None:
            return f"{self.type}: {columns:,} columns"
        return f"{self.type}: {rows:,} rows x {columns:,} columns"

#+END_SRC
***** Class TableManagerFactory
#+BEGIN_SRC python
class TableManagerFactory(abc.ABC):
    @staticmethod
    @abc.abstractmethod
    def package_name() -> str:
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def create() -> type[TableManager[Any]]:
        raise NotImplementedError

#+END_SRC
**** utils
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.tables.utils
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/tables/utils.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import Any, List

from marimo._dependencies.dependencies import DependencyManager
from marimo._plugins.ui._impl.tables.default_table import DefaultTableManager
from marimo._plugins.ui._impl.tables.ibis_table import IbisTableManagerFactory
from marimo._plugins.ui._impl.tables.narwhals_table import NarwhalsTableManager
from marimo._plugins.ui._impl.tables.pandas_table import (
    PandasTableManagerFactory,
)
from marimo._plugins.ui._impl.tables.polars_table import (
    PolarsTableManagerFactory,
)
from marimo._plugins.ui._impl.tables.table_manager import (
    TableManager,
    TableManagerFactory,
)
from marimo._utils.narwhals_utils import can_narwhalify

#+END_SRC
***** Assignment MANAGERS
#+BEGIN_SRC python
MANAGERS: List[TableManagerFactory] = [
    PandasTableManagerFactory(),
    PolarsTableManagerFactory(),
    IbisTableManagerFactory(),
]

#+END_SRC
***** Function get_table_manager
#+BEGIN_SRC python
def get_table_manager(data: Any) -> TableManager[Any]:
    return get_table_manager_or_none(data) or DefaultTableManager(data)

#+END_SRC
***** Function get_table_manager_or_none
#+BEGIN_SRC python
def get_table_manager_or_none(data: Any) -> TableManager[Any] | None:
    if data is None:
        return None

    # Try to find a manager specifically for the data type
    for manager_factory in MANAGERS:
        # We use `imported` instead of `has()` because `has()` can be very
        # slow. If a variable created by a package is in memory, then the
        # module will have been imported.
        if DependencyManager.imported(manager_factory.package_name()):
            manager = manager_factory.create()
            if manager.is_type(data):
                return manager(data)

    # Fallback to generic NarwhalsTableManager
    if can_narwhalify(data):
        return NarwhalsTableManager.from_dataframe(data)

    return None

#+END_SRC
*** utils
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.utils
:END:
**** dataframe
:PROPERTIES:
:LITERATE_ORG_MODULE: marimo._plugins.ui._impl.utils.dataframe
:header-args: :tangle /Users/jingtao/projects/marimo/marimo/_plugins/ui/_impl/utils/dataframe.py
:END:
***** Import statements
#+BEGIN_SRC python
# Copyright 2024 Marimo. All rights reserved.
from __future__ import annotations

from typing import (
    Dict,
    List,
    Tuple,
    TypeVar,
    Union,
)

from narwhals.typing import IntoDataFrame

from marimo import _loggers
from marimo._output.mime import MIME
from marimo._plugins.core.web_component import JSONType

#+END_SRC
***** Assignment LOGGER = _loggers.marimo_logger()
#+BEGIN_SRC python
LOGGER = _loggers.marimo_logger()

#+END_SRC
***** Assignment T = TypeVar("T")
#+BEGIN_SRC python
T = TypeVar("T")

#+END_SRC
***** Assignment Numeric = Union[int, float]
#+BEGIN_SRC python
Numeric = Union[int, float]

#+END_SRC
***** Assignment ListOrTuple = Union[List[T], Tuple[T, ...]]
#+BEGIN_SRC python
ListOrTuple = Union[List[T], Tuple[T, ...]]

#+END_SRC
***** Assignment TableData
#+BEGIN_SRC python
TableData = Union[
    List[JSONType],
    ListOrTuple[Union[str, int, float, bool, MIME, None]],
    ListOrTuple[Dict[str, JSONType]],
    Dict[str, ListOrTuple[JSONType]],
    IntoDataFrame,
]

#+END_SRC
